package controller

import (
	"fmt"
	"log"
	"time"

	. "github.com/mesos/mesos-go/api/v1/lib/extras/scheduler/eventrules"
	"github.com/mesos/mesos-go/api/v1/lib/extras/store"
	"github.com/mesos/mesos-go/api/v1/lib/scheduler"
	"github.com/mesos/mesos-go/api/v1/lib/scheduler/calls"
	"github.com/mesos/mesos-go/api/v1/lib/scheduler/events"
)

// ErrEvent errors are generated by LiftErrors upon receiving an ERROR event from Mesos.
type ErrEvent string

func (e ErrEvent) Error() string {
	return string(e)
}

// LiftErrors extract the error message from a scheduler error event and returns it as an ErrEvent
// so that downstream rules/handlers may continue processing.
func LiftErrors() Rule {
	return func(e *scheduler.Event, err error, chain Chain) (*scheduler.Event, error) {
		if err != nil {
			return chain(e, err)
		}
		if e.GetType() == scheduler.Event_ERROR {
			// it's recommended that we abort and re-try subscribing; returning an
			// error here will cause the event loop to terminate and the connection
			// will be reset.
			return chain(e, ErrEvent(e.GetError().GetMessage()))
		}
		return chain(e, nil)
	}
}

// StateError is returned when the system encounters an unresolvable state transition error and
// should likely exit.
type StateError string

func (err StateError) Error() string { return string(err) }

func TrackSubscription(frameworkIDStore store.Singleton, failoverTimeout time.Duration) Rule {
	return func(e *scheduler.Event, err error, chain Chain) (*scheduler.Event, error) {
		if err != nil {
			return chain(e, err)
		}
		if e.GetType() == scheduler.Event_SUBSCRIBED {
			var (
				storedFrameworkID, err = frameworkIDStore.Get()
				frameworkID            = e.GetSubscribed().GetFrameworkID().GetValue()
			)
			if err != nil && err != store.ErrNotFound {
				return chain(e, err)
			}
			// order of `if` statements are important: tread carefully w/ respect to future changes
			if frameworkID == "" {
				// sanity check, should **never** happen
				return chain(e, StateError("mesos sent an empty frameworkID?!"))
			}
			if storedFrameworkID != "" && storedFrameworkID != frameworkID && failoverTimeout > 0 {
				return chain(e, StateError(fmt.Sprintf(
					"frameworkID changed unexpectedly; failover exceeded timeout? (%s).", failoverTimeout)))
			}
			if storedFrameworkID != frameworkID {
				frameworkIDStore.Set(frameworkID)
			}
		}
		return chain(e, nil)
	}
}

// AckStatusUpdates sends an acknowledgement of a task status update back to mesos and drops the event if
// sending the ack fails. If successful, the specified err param (if any) is forwarded. Acknowledgements
// are only attempted for task status updates tagged with a UUID.
func AckStatusUpdates(caller calls.Caller) Rule {
	return AckStatusUpdatesF(func() calls.Caller { return caller })
}

// AckStatusUpdatesF is a functional adapter for AckStatusUpdates, useful for cases where the caller may
// change over time.
func AckStatusUpdatesF(callerLookup func() calls.Caller) Rule {
	return func(e *scheduler.Event, err error, chain Chain) (*scheduler.Event, error) {
		// aggressively attempt to ack updates: even if there's pre-existing error state attempt
		// to acknowledge all status updates.
		origErr := err
		if e.GetType() == scheduler.Event_UPDATE {
			var (
				s    = e.GetUpdate().GetStatus()
				uuid = s.GetUUID()
			)
			// only ACK non-empty UUID's, as per mesos scheduler spec
			if len(uuid) > 0 {
				ack := calls.Acknowledge(
					s.GetAgentID().GetValue(),
					s.TaskID.Value,
					uuid,
				)
				err = calls.CallNoData(callerLookup(), ack)
				if err != nil {
					err = &events.AckError{Ack: ack, Cause: err}
					return nil, Error2(origErr, err) // drop
				}
			}
		}
		return chain(e, origErr)
	}
}

var (
	// EventLabel is, by default, logged as the first argument by EventLogger
	EventLabel = "event"
	// EventLogger is the logger used by the LogEvents rule generator
	EventLogger = func(e *scheduler.Event) { log.Println(EventLabel, e) }
)

// LogEvents returns a rule that logs scheduler events to the EventLogger
func LogEvents() Rule {
	return Rule(func(e *scheduler.Event, err error, chain Chain) (*scheduler.Event, error) {
		EventLogger(e)
		return chain(e, err)
	})
}
