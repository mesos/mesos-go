package apierrors

import (
	"io/ioutil"
	"net/http"
)

var (
	// MsgNotLeader is returned by Do calls that are sent to a non leading Mesos master. Deprecated.
	MsgNotLeader = "call sent to a non-leading master"
	// MsgAuth is returned by Do calls that are not successfully authenticated. Deprecated.
	MsgAuth = "call not authenticated"
	// MsgUnsubscribed is returned by Do calls that are sent before a subscription is established. Deprecated.
	MsgUnsubscribed = "no subscription established"
	// MsgVersion is returned by Do calls that are sent to an incompatible API version. Deprecated.
	MsgVersion = "incompatible API version"
	// MsgMalformed is returned by Do calls that are malformed. Deprecated.
	MsgMalformed = "malformed request"
	// MsgMediaType is returned by Do calls that are sent with an unsupported media type. Deprecated.
	MsgMediaType = "unsupported media type"
	// MsgRateLimit is returned by Do calls that are rate limited. This is a temporary condition
	// that should clear. Deprecated.
	MsgRateLimit = "rate limited"
	// MsgUnavailable is returned by Do calls that are sent to a master or agent that's in recovery, or
	// does not yet realize that it's the leader. This is a temporary condition that should clear. Deprecated.
	MsgUnavailable = "mesos server unavailable"
	// MsgNotFound could happen if the master or agent libprocess has not yet set up http routes. Deprecated.
	MsgNotFound = "mesos http endpoint not found"

	// ErrorTable maps HTTP response codes to their respective Mesos v1 API error messages.
	ErrorTable = func() map[int]Error {
		result := make(map[int]Error)
		for code, msg := range map[int]string{
			http.StatusTemporaryRedirect:  MsgNotLeader,
			http.StatusBadRequest:         MsgMalformed,
			http.StatusConflict:           MsgVersion,
			http.StatusForbidden:          MsgUnsubscribed,
			http.StatusUnauthorized:       MsgAuth,
			http.StatusNotAcceptable:      MsgMediaType,
			http.StatusNotFound:           MsgNotFound,
			http.StatusServiceUnavailable: MsgUnavailable,
			http.StatusTooManyRequests:    MsgRateLimit,
		} {
			result[code] = Error{Code: code, Message: msg}
		}
		return result
	}()
)

// Error captures HTTP v1 API error codes and messages generated by Mesos.
type Error struct {
	Code    int    // Code is the HTTP response status code generated by Mesos
	Message string // Message briefly summarizes the nature of the error
	Details string // Details captures the HTTP response entity, if any, supplied by Mesos
}

// IsErrorCode returns true for all HTTP status codes that are not considered informational or successful.
func IsErrorCode(code int) bool {
	return code >= 300
}

// FromResponse returns an `*Error` for a response containing a status code that indicates an error condition.
// The response body (if any) is captured in the Error.Details field.
// Returns nil for nil responses and responses with non-error status codes.
// See IsErrorCode.
func FromResponse(res *http.Response) error {
	if res == nil {
		return nil
	}

	code := res.StatusCode
	if !IsErrorCode(code) {
		// non-error HTTP response codes don't generate errors
		return nil
	}

	details := ""
	if res.Body != nil {
		buf, _ := ioutil.ReadAll(res.Body)
		details = string(buf)
	}

	if msg, ok := ErrorTable[code]; ok {
		// return a modified copy of whatever was in the error table
		msg.Details = details
		return &msg
	}

	// unmapped errors are OK, they're just not "interpreted" (with a Message)
	return &Error{
		Code:    code,
		Details: details,
	}
}

func (err *Error) Error() string {
	return err.Message
}

func IsErrNotLeader(err error) bool {
	apiErr, ok := err.(*Error)
	return ok && apiErr.Code == http.StatusTemporaryRedirect
}
