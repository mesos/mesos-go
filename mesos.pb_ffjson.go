// DO NOT EDIT!
// Code generated by ffjson <https://github.com/pquerna/ffjson>
// source: mesos.pb.go
// DO NOT EDIT!

package mesos

import (
	"bytes"
	"encoding/base64"
	"errors"
	"fmt"
	fflib "github.com/pquerna/ffjson/fflib/v1"
	"reflect"
)

func (mj *Address) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Address) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteByte('{')
	if mj.Hostname != nil {
		if true {
			buf.WriteString(`"hostname":`)
			fflib.WriteJsonString(buf, string(*mj.Hostname))
			buf.WriteByte(',')
		}
	}
	if mj.Ip != nil {
		if true {
			buf.WriteString(`"ip":`)
			fflib.WriteJsonString(buf, string(*mj.Ip))
			buf.WriteByte(',')
		}
	}
	buf.WriteString(`"port":`)
	fflib.FormatBits2(buf, uint64(mj.Port), 10, mj.Port < 0)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Addressbase = iota
	ffj_t_Addressno_such_key

	ffj_t_Address_Hostname

	ffj_t_Address_Ip

	ffj_t_Address_Port
)

var ffj_key_Address_Hostname = []byte("hostname")

var ffj_key_Address_Ip = []byte("ip")

var ffj_key_Address_Port = []byte("port")

func (uj *Address) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Address) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Addressbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Addressno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'h':

					if bytes.Equal(ffj_key_Address_Hostname, kn) {
						currentKey = ffj_t_Address_Hostname
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_Address_Ip, kn) {
						currentKey = ffj_t_Address_Ip
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_Address_Port, kn) {
						currentKey = ffj_t_Address_Port
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_Address_Port, kn) {
					currentKey = ffj_t_Address_Port
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Address_Ip, kn) {
					currentKey = ffj_t_Address_Ip
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Address_Hostname, kn) {
					currentKey = ffj_t_Address_Hostname
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Addressno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Address_Hostname:
					goto handle_Hostname

				case ffj_t_Address_Ip:
					goto handle_Ip

				case ffj_t_Address_Port:
					goto handle_Port

				case ffj_t_Addressno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Hostname:

	/* handler: uj.Hostname type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Hostname = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Hostname = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Ip:

	/* handler: uj.Ip type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Ip = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Ip = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Port:

	/* handler: uj.Port type=int32 kind=int32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Port = int32(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *AgentID) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *AgentID) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"value":`)
	fflib.WriteJsonString(buf, string(mj.Value))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_AgentIDbase = iota
	ffj_t_AgentIDno_such_key

	ffj_t_AgentID_Value
)

var ffj_key_AgentID_Value = []byte("value")

func (uj *AgentID) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *AgentID) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_AgentIDbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_AgentIDno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'v':

					if bytes.Equal(ffj_key_AgentID_Value, kn) {
						currentKey = ffj_t_AgentID_Value
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_AgentID_Value, kn) {
					currentKey = ffj_t_AgentID_Value
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_AgentIDno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_AgentID_Value:
					goto handle_Value

				case ffj_t_AgentIDno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Value:

	/* handler: uj.Value type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Value = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *AgentInfo) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *AgentInfo) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"hostname":`)
	fflib.WriteJsonString(buf, string(mj.Hostname))
	buf.WriteByte(',')
	if mj.Port != nil {
		if true {
			buf.WriteString(`"port":`)
			fflib.FormatBits2(buf, uint64(*mj.Port), 10, *mj.Port < 0)
			buf.WriteByte(',')
		}
	}
	buf.WriteString(`"resources":`)
	if mj.Resources != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Resources {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"attributes":`)
	if mj.Attributes != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Attributes {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte(',')
	if mj.ID != nil {
		if true {
			buf.WriteString(`"id":`)

			{

				err = mj.ID.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.Checkpoint {
		buf.WriteString(`"checkpoint":true`)
	} else {
		buf.WriteString(`"checkpoint":false`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_AgentInfobase = iota
	ffj_t_AgentInfono_such_key

	ffj_t_AgentInfo_Hostname

	ffj_t_AgentInfo_Port

	ffj_t_AgentInfo_Resources

	ffj_t_AgentInfo_Attributes

	ffj_t_AgentInfo_ID

	ffj_t_AgentInfo_Checkpoint
)

var ffj_key_AgentInfo_Hostname = []byte("hostname")

var ffj_key_AgentInfo_Port = []byte("port")

var ffj_key_AgentInfo_Resources = []byte("resources")

var ffj_key_AgentInfo_Attributes = []byte("attributes")

var ffj_key_AgentInfo_ID = []byte("id")

var ffj_key_AgentInfo_Checkpoint = []byte("checkpoint")

func (uj *AgentInfo) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *AgentInfo) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_AgentInfobase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_AgentInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_AgentInfo_Attributes, kn) {
						currentKey = ffj_t_AgentInfo_Attributes
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffj_key_AgentInfo_Checkpoint, kn) {
						currentKey = ffj_t_AgentInfo_Checkpoint
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'h':

					if bytes.Equal(ffj_key_AgentInfo_Hostname, kn) {
						currentKey = ffj_t_AgentInfo_Hostname
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_AgentInfo_ID, kn) {
						currentKey = ffj_t_AgentInfo_ID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_AgentInfo_Port, kn) {
						currentKey = ffj_t_AgentInfo_Port
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_AgentInfo_Resources, kn) {
						currentKey = ffj_t_AgentInfo_Resources
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_AgentInfo_Checkpoint, kn) {
					currentKey = ffj_t_AgentInfo_Checkpoint
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_AgentInfo_ID, kn) {
					currentKey = ffj_t_AgentInfo_ID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_AgentInfo_Attributes, kn) {
					currentKey = ffj_t_AgentInfo_Attributes
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_AgentInfo_Resources, kn) {
					currentKey = ffj_t_AgentInfo_Resources
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_AgentInfo_Port, kn) {
					currentKey = ffj_t_AgentInfo_Port
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_AgentInfo_Hostname, kn) {
					currentKey = ffj_t_AgentInfo_Hostname
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_AgentInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_AgentInfo_Hostname:
					goto handle_Hostname

				case ffj_t_AgentInfo_Port:
					goto handle_Port

				case ffj_t_AgentInfo_Resources:
					goto handle_Resources

				case ffj_t_AgentInfo_Attributes:
					goto handle_Attributes

				case ffj_t_AgentInfo_ID:
					goto handle_ID

				case ffj_t_AgentInfo_Checkpoint:
					goto handle_Checkpoint

				case ffj_t_AgentInfono_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Hostname:

	/* handler: uj.Hostname type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Hostname = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Port:

	/* handler: uj.Port type=int32 kind=int32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Port = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int32(tval)
			uj.Port = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Resources:

	/* handler: uj.Resources type=[]mesos.Resource kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Resources = nil
		} else {

			uj.Resources = make([]Resource, 0)

			wantVal := true

			for {

				var v Resource

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=mesos.Resource kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Resources = append(uj.Resources, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Attributes:

	/* handler: uj.Attributes type=[]mesos.Attribute kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Attributes = nil
		} else {

			uj.Attributes = make([]Attribute, 0)

			wantVal := true

			for {

				var v Attribute

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=mesos.Attribute kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Attributes = append(uj.Attributes, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ID:

	/* handler: uj.ID type=mesos.AgentID kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.ID = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.ID == nil {
			uj.ID = new(AgentID)
		}

		err = uj.ID.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Checkpoint:

	/* handler: uj.Checkpoint type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				uj.Checkpoint = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				uj.Checkpoint = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Attribute) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Attribute) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "name":`)
	fflib.WriteJsonString(buf, string(mj.Name))
	buf.WriteByte(',')
	if mj.Type != nil {
		if true {
			buf.WriteString(`"type":`)

			{

				obj, err = mj.Type.MarshalJSON()
				if err != nil {
					return err
				}
				buf.Write(obj)

			}
			buf.WriteByte(',')
		}
	}
	if mj.Scalar != nil {
		if true {
			buf.WriteString(`"scalar":`)

			{

				err = mj.Scalar.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.Ranges != nil {
		if true {
			buf.WriteString(`"ranges":`)

			{

				err = mj.Ranges.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.Set != nil {
		if true {
			buf.WriteString(`"set":`)

			{

				err = mj.Set.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.Text != nil {
		if true {
			buf.WriteString(`"text":`)

			{

				err = mj.Text.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Attributebase = iota
	ffj_t_Attributeno_such_key

	ffj_t_Attribute_Name

	ffj_t_Attribute_Type

	ffj_t_Attribute_Scalar

	ffj_t_Attribute_Ranges

	ffj_t_Attribute_Set

	ffj_t_Attribute_Text
)

var ffj_key_Attribute_Name = []byte("name")

var ffj_key_Attribute_Type = []byte("type")

var ffj_key_Attribute_Scalar = []byte("scalar")

var ffj_key_Attribute_Ranges = []byte("ranges")

var ffj_key_Attribute_Set = []byte("set")

var ffj_key_Attribute_Text = []byte("text")

func (uj *Attribute) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Attribute) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Attributebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Attributeno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'n':

					if bytes.Equal(ffj_key_Attribute_Name, kn) {
						currentKey = ffj_t_Attribute_Name
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_Attribute_Ranges, kn) {
						currentKey = ffj_t_Attribute_Ranges
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_Attribute_Scalar, kn) {
						currentKey = ffj_t_Attribute_Scalar
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Attribute_Set, kn) {
						currentKey = ffj_t_Attribute_Set
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_Attribute_Type, kn) {
						currentKey = ffj_t_Attribute_Type
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Attribute_Text, kn) {
						currentKey = ffj_t_Attribute_Text
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_Attribute_Text, kn) {
					currentKey = ffj_t_Attribute_Text
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Attribute_Set, kn) {
					currentKey = ffj_t_Attribute_Set
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Attribute_Ranges, kn) {
					currentKey = ffj_t_Attribute_Ranges
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Attribute_Scalar, kn) {
					currentKey = ffj_t_Attribute_Scalar
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Attribute_Type, kn) {
					currentKey = ffj_t_Attribute_Type
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Attribute_Name, kn) {
					currentKey = ffj_t_Attribute_Name
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Attributeno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Attribute_Name:
					goto handle_Name

				case ffj_t_Attribute_Type:
					goto handle_Type

				case ffj_t_Attribute_Scalar:
					goto handle_Scalar

				case ffj_t_Attribute_Ranges:
					goto handle_Ranges

				case ffj_t_Attribute_Set:
					goto handle_Set

				case ffj_t_Attribute_Text:
					goto handle_Text

				case ffj_t_Attributeno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Name:

	/* handler: uj.Name type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Name = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Type:

	/* handler: uj.Type type=mesos.Value_Type kind=int32 quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Type = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		if uj.Type == nil {
			uj.Type = new(Value_Type)
		}

		err = uj.Type.UnmarshalJSON(tbuf)
		if err != nil {
			return fs.WrapErr(err)
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Scalar:

	/* handler: uj.Scalar type=mesos.Value_Scalar kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Scalar = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Scalar == nil {
			uj.Scalar = new(Value_Scalar)
		}

		err = uj.Scalar.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Ranges:

	/* handler: uj.Ranges type=mesos.Value_Ranges kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Ranges = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Ranges == nil {
			uj.Ranges = new(Value_Ranges)
		}

		err = uj.Ranges.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Set:

	/* handler: uj.Set type=mesos.Value_Set kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Set = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Set == nil {
			uj.Set = new(Value_Set)
		}

		err = uj.Set.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Text:

	/* handler: uj.Text type=mesos.Value_Text kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Text = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Text == nil {
			uj.Text = new(Value_Text)
		}

		err = uj.Text.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *CgroupInfo) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *CgroupInfo) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.NetCLS != nil {
		if true {
			buf.WriteString(`"net_cls":`)

			{

				err = mj.NetCLS.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_CgroupInfobase = iota
	ffj_t_CgroupInfono_such_key

	ffj_t_CgroupInfo_NetCLS
)

var ffj_key_CgroupInfo_NetCLS = []byte("net_cls")

func (uj *CgroupInfo) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *CgroupInfo) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_CgroupInfobase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_CgroupInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'n':

					if bytes.Equal(ffj_key_CgroupInfo_NetCLS, kn) {
						currentKey = ffj_t_CgroupInfo_NetCLS
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_CgroupInfo_NetCLS, kn) {
					currentKey = ffj_t_CgroupInfo_NetCLS
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_CgroupInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_CgroupInfo_NetCLS:
					goto handle_NetCLS

				case ffj_t_CgroupInfono_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_NetCLS:

	/* handler: uj.NetCLS type=mesos.CgroupInfo_NetCls kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.NetCLS = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.NetCLS == nil {
			uj.NetCLS = new(CgroupInfo_NetCls)
		}

		err = uj.NetCLS.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *CgroupInfo_NetCls) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *CgroupInfo_NetCls) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.ClassID != nil {
		if true {
			buf.WriteString(`"classid":`)
			fflib.FormatBits2(buf, uint64(*mj.ClassID), 10, false)
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_CgroupInfo_NetClsbase = iota
	ffj_t_CgroupInfo_NetClsno_such_key

	ffj_t_CgroupInfo_NetCls_ClassID
)

var ffj_key_CgroupInfo_NetCls_ClassID = []byte("classid")

func (uj *CgroupInfo_NetCls) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *CgroupInfo_NetCls) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_CgroupInfo_NetClsbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_CgroupInfo_NetClsno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_CgroupInfo_NetCls_ClassID, kn) {
						currentKey = ffj_t_CgroupInfo_NetCls_ClassID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_CgroupInfo_NetCls_ClassID, kn) {
					currentKey = ffj_t_CgroupInfo_NetCls_ClassID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_CgroupInfo_NetClsno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_CgroupInfo_NetCls_ClassID:
					goto handle_ClassID

				case ffj_t_CgroupInfo_NetClsno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ClassID:

	/* handler: uj.ClassID type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.ClassID = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint32(tval)
			uj.ClassID = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *CommandInfo) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *CommandInfo) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "uris":`)
	if mj.URIs != nil {
		buf.WriteString(`[`)
		for i, v := range mj.URIs {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte(',')
	if mj.Environment != nil {
		if true {
			buf.WriteString(`"environment":`)

			{

				err = mj.Environment.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.Shell != nil {
		if true {
			if *mj.Shell {
				buf.WriteString(`"shell":true`)
			} else {
				buf.WriteString(`"shell":false`)
			}
			buf.WriteByte(',')
		}
	}
	if mj.Value != nil {
		if true {
			buf.WriteString(`"value":`)
			fflib.WriteJsonString(buf, string(*mj.Value))
			buf.WriteByte(',')
		}
	}
	if len(mj.Arguments) != 0 {
		buf.WriteString(`"arguments":`)
		if mj.Arguments != nil {
			buf.WriteString(`[`)
			for i, v := range mj.Arguments {
				if i != 0 {
					buf.WriteString(`,`)
				}
				fflib.WriteJsonString(buf, string(v))
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if mj.User != nil {
		if true {
			buf.WriteString(`"user":`)
			fflib.WriteJsonString(buf, string(*mj.User))
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_CommandInfobase = iota
	ffj_t_CommandInfono_such_key

	ffj_t_CommandInfo_URIs

	ffj_t_CommandInfo_Environment

	ffj_t_CommandInfo_Shell

	ffj_t_CommandInfo_Value

	ffj_t_CommandInfo_Arguments

	ffj_t_CommandInfo_User
)

var ffj_key_CommandInfo_URIs = []byte("uris")

var ffj_key_CommandInfo_Environment = []byte("environment")

var ffj_key_CommandInfo_Shell = []byte("shell")

var ffj_key_CommandInfo_Value = []byte("value")

var ffj_key_CommandInfo_Arguments = []byte("arguments")

var ffj_key_CommandInfo_User = []byte("user")

func (uj *CommandInfo) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *CommandInfo) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_CommandInfobase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_CommandInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_CommandInfo_Arguments, kn) {
						currentKey = ffj_t_CommandInfo_Arguments
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffj_key_CommandInfo_Environment, kn) {
						currentKey = ffj_t_CommandInfo_Environment
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_CommandInfo_Shell, kn) {
						currentKey = ffj_t_CommandInfo_Shell
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffj_key_CommandInfo_URIs, kn) {
						currentKey = ffj_t_CommandInfo_URIs
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_CommandInfo_User, kn) {
						currentKey = ffj_t_CommandInfo_User
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'v':

					if bytes.Equal(ffj_key_CommandInfo_Value, kn) {
						currentKey = ffj_t_CommandInfo_Value
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_CommandInfo_User, kn) {
					currentKey = ffj_t_CommandInfo_User
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_CommandInfo_Arguments, kn) {
					currentKey = ffj_t_CommandInfo_Arguments
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_CommandInfo_Value, kn) {
					currentKey = ffj_t_CommandInfo_Value
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_CommandInfo_Shell, kn) {
					currentKey = ffj_t_CommandInfo_Shell
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_CommandInfo_Environment, kn) {
					currentKey = ffj_t_CommandInfo_Environment
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_CommandInfo_URIs, kn) {
					currentKey = ffj_t_CommandInfo_URIs
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_CommandInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_CommandInfo_URIs:
					goto handle_URIs

				case ffj_t_CommandInfo_Environment:
					goto handle_Environment

				case ffj_t_CommandInfo_Shell:
					goto handle_Shell

				case ffj_t_CommandInfo_Value:
					goto handle_Value

				case ffj_t_CommandInfo_Arguments:
					goto handle_Arguments

				case ffj_t_CommandInfo_User:
					goto handle_User

				case ffj_t_CommandInfono_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_URIs:

	/* handler: uj.URIs type=[]mesos.CommandInfo_URI kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.URIs = nil
		} else {

			uj.URIs = make([]CommandInfo_URI, 0)

			wantVal := true

			for {

				var v CommandInfo_URI

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=mesos.CommandInfo_URI kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.URIs = append(uj.URIs, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Environment:

	/* handler: uj.Environment type=mesos.Environment kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Environment = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Environment == nil {
			uj.Environment = new(Environment)
		}

		err = uj.Environment.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Shell:

	/* handler: uj.Shell type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

			uj.Shell = nil

		} else {
			tmpb := fs.Output.Bytes()

			var tval bool

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				tval = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				tval = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

			uj.Shell = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Value:

	/* handler: uj.Value type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Value = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Value = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Arguments:

	/* handler: uj.Arguments type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Arguments = nil
		} else {

			uj.Arguments = make([]string, 0)

			wantVal := true

			for {

				var v string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						v = string(string(outBuf))

					}
				}

				uj.Arguments = append(uj.Arguments, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_User:

	/* handler: uj.User type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.User = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.User = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *CommandInfo_URI) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *CommandInfo_URI) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "value":`)
	fflib.WriteJsonString(buf, string(mj.Value))
	buf.WriteByte(',')
	if mj.Executable != nil {
		if true {
			if *mj.Executable {
				buf.WriteString(`"executable":true`)
			} else {
				buf.WriteString(`"executable":false`)
			}
			buf.WriteByte(',')
		}
	}
	if mj.Extract != nil {
		if true {
			if *mj.Extract {
				buf.WriteString(`"extract":true`)
			} else {
				buf.WriteString(`"extract":false`)
			}
			buf.WriteByte(',')
		}
	}
	if mj.Cache != nil {
		if true {
			if *mj.Cache {
				buf.WriteString(`"cache":true`)
			} else {
				buf.WriteString(`"cache":false`)
			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_CommandInfo_URIbase = iota
	ffj_t_CommandInfo_URIno_such_key

	ffj_t_CommandInfo_URI_Value

	ffj_t_CommandInfo_URI_Executable

	ffj_t_CommandInfo_URI_Extract

	ffj_t_CommandInfo_URI_Cache
)

var ffj_key_CommandInfo_URI_Value = []byte("value")

var ffj_key_CommandInfo_URI_Executable = []byte("executable")

var ffj_key_CommandInfo_URI_Extract = []byte("extract")

var ffj_key_CommandInfo_URI_Cache = []byte("cache")

func (uj *CommandInfo_URI) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *CommandInfo_URI) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_CommandInfo_URIbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_CommandInfo_URIno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_CommandInfo_URI_Cache, kn) {
						currentKey = ffj_t_CommandInfo_URI_Cache
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffj_key_CommandInfo_URI_Executable, kn) {
						currentKey = ffj_t_CommandInfo_URI_Executable
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_CommandInfo_URI_Extract, kn) {
						currentKey = ffj_t_CommandInfo_URI_Extract
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'v':

					if bytes.Equal(ffj_key_CommandInfo_URI_Value, kn) {
						currentKey = ffj_t_CommandInfo_URI_Value
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_CommandInfo_URI_Cache, kn) {
					currentKey = ffj_t_CommandInfo_URI_Cache
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_CommandInfo_URI_Extract, kn) {
					currentKey = ffj_t_CommandInfo_URI_Extract
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_CommandInfo_URI_Executable, kn) {
					currentKey = ffj_t_CommandInfo_URI_Executable
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_CommandInfo_URI_Value, kn) {
					currentKey = ffj_t_CommandInfo_URI_Value
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_CommandInfo_URIno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_CommandInfo_URI_Value:
					goto handle_Value

				case ffj_t_CommandInfo_URI_Executable:
					goto handle_Executable

				case ffj_t_CommandInfo_URI_Extract:
					goto handle_Extract

				case ffj_t_CommandInfo_URI_Cache:
					goto handle_Cache

				case ffj_t_CommandInfo_URIno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Value:

	/* handler: uj.Value type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Value = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Executable:

	/* handler: uj.Executable type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

			uj.Executable = nil

		} else {
			tmpb := fs.Output.Bytes()

			var tval bool

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				tval = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				tval = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

			uj.Executable = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Extract:

	/* handler: uj.Extract type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

			uj.Extract = nil

		} else {
			tmpb := fs.Output.Bytes()

			var tval bool

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				tval = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				tval = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

			uj.Extract = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Cache:

	/* handler: uj.Cache type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

			uj.Cache = nil

		} else {
			tmpb := fs.Output.Bytes()

			var tval bool

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				tval = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				tval = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

			uj.Cache = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *ContainerID) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ContainerID) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"value":`)
	fflib.WriteJsonString(buf, string(mj.Value))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ContainerIDbase = iota
	ffj_t_ContainerIDno_such_key

	ffj_t_ContainerID_Value
)

var ffj_key_ContainerID_Value = []byte("value")

func (uj *ContainerID) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ContainerID) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ContainerIDbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ContainerIDno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'v':

					if bytes.Equal(ffj_key_ContainerID_Value, kn) {
						currentKey = ffj_t_ContainerID_Value
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_ContainerID_Value, kn) {
					currentKey = ffj_t_ContainerID_Value
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ContainerIDno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ContainerID_Value:
					goto handle_Value

				case ffj_t_ContainerIDno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Value:

	/* handler: uj.Value type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Value = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *ContainerInfo) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ContainerInfo) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteByte('{')
	if mj.Type != nil {
		if true {
			buf.WriteString(`"type":`)

			{

				obj, err = mj.Type.MarshalJSON()
				if err != nil {
					return err
				}
				buf.Write(obj)

			}
			buf.WriteByte(',')
		}
	}
	buf.WriteString(`"volumes":`)
	if mj.Volumes != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Volumes {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte(',')
	if mj.Hostname != nil {
		if true {
			buf.WriteString(`"hostname":`)
			fflib.WriteJsonString(buf, string(*mj.Hostname))
			buf.WriteByte(',')
		}
	}
	if mj.Docker != nil {
		if true {
			buf.WriteString(`"docker":`)

			{

				err = mj.Docker.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.Mesos != nil {
		if true {
			buf.WriteString(`"mesos":`)

			{

				err = mj.Mesos.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.WriteString(`"network_infos":`)
	if mj.NetworkInfos != nil {
		buf.WriteString(`[`)
		for i, v := range mj.NetworkInfos {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ContainerInfobase = iota
	ffj_t_ContainerInfono_such_key

	ffj_t_ContainerInfo_Type

	ffj_t_ContainerInfo_Volumes

	ffj_t_ContainerInfo_Hostname

	ffj_t_ContainerInfo_Docker

	ffj_t_ContainerInfo_Mesos

	ffj_t_ContainerInfo_NetworkInfos
)

var ffj_key_ContainerInfo_Type = []byte("type")

var ffj_key_ContainerInfo_Volumes = []byte("volumes")

var ffj_key_ContainerInfo_Hostname = []byte("hostname")

var ffj_key_ContainerInfo_Docker = []byte("docker")

var ffj_key_ContainerInfo_Mesos = []byte("mesos")

var ffj_key_ContainerInfo_NetworkInfos = []byte("network_infos")

func (uj *ContainerInfo) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ContainerInfo) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ContainerInfobase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ContainerInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'd':

					if bytes.Equal(ffj_key_ContainerInfo_Docker, kn) {
						currentKey = ffj_t_ContainerInfo_Docker
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'h':

					if bytes.Equal(ffj_key_ContainerInfo_Hostname, kn) {
						currentKey = ffj_t_ContainerInfo_Hostname
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_ContainerInfo_Mesos, kn) {
						currentKey = ffj_t_ContainerInfo_Mesos
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffj_key_ContainerInfo_NetworkInfos, kn) {
						currentKey = ffj_t_ContainerInfo_NetworkInfos
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_ContainerInfo_Type, kn) {
						currentKey = ffj_t_ContainerInfo_Type
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'v':

					if bytes.Equal(ffj_key_ContainerInfo_Volumes, kn) {
						currentKey = ffj_t_ContainerInfo_Volumes
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_ContainerInfo_NetworkInfos, kn) {
					currentKey = ffj_t_ContainerInfo_NetworkInfos
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ContainerInfo_Mesos, kn) {
					currentKey = ffj_t_ContainerInfo_Mesos
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ContainerInfo_Docker, kn) {
					currentKey = ffj_t_ContainerInfo_Docker
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ContainerInfo_Hostname, kn) {
					currentKey = ffj_t_ContainerInfo_Hostname
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ContainerInfo_Volumes, kn) {
					currentKey = ffj_t_ContainerInfo_Volumes
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ContainerInfo_Type, kn) {
					currentKey = ffj_t_ContainerInfo_Type
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ContainerInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ContainerInfo_Type:
					goto handle_Type

				case ffj_t_ContainerInfo_Volumes:
					goto handle_Volumes

				case ffj_t_ContainerInfo_Hostname:
					goto handle_Hostname

				case ffj_t_ContainerInfo_Docker:
					goto handle_Docker

				case ffj_t_ContainerInfo_Mesos:
					goto handle_Mesos

				case ffj_t_ContainerInfo_NetworkInfos:
					goto handle_NetworkInfos

				case ffj_t_ContainerInfono_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Type:

	/* handler: uj.Type type=mesos.ContainerInfo_Type kind=int32 quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Type = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		if uj.Type == nil {
			uj.Type = new(ContainerInfo_Type)
		}

		err = uj.Type.UnmarshalJSON(tbuf)
		if err != nil {
			return fs.WrapErr(err)
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Volumes:

	/* handler: uj.Volumes type=[]mesos.Volume kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Volumes = nil
		} else {

			uj.Volumes = make([]Volume, 0)

			wantVal := true

			for {

				var v Volume

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=mesos.Volume kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Volumes = append(uj.Volumes, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Hostname:

	/* handler: uj.Hostname type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Hostname = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Hostname = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Docker:

	/* handler: uj.Docker type=mesos.ContainerInfo_DockerInfo kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Docker = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Docker == nil {
			uj.Docker = new(ContainerInfo_DockerInfo)
		}

		err = uj.Docker.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Mesos:

	/* handler: uj.Mesos type=mesos.ContainerInfo_MesosInfo kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Mesos = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Mesos == nil {
			uj.Mesos = new(ContainerInfo_MesosInfo)
		}

		err = uj.Mesos.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NetworkInfos:

	/* handler: uj.NetworkInfos type=[]mesos.NetworkInfo kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.NetworkInfos = nil
		} else {

			uj.NetworkInfos = make([]NetworkInfo, 0)

			wantVal := true

			for {

				var v NetworkInfo

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=mesos.NetworkInfo kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.NetworkInfos = append(uj.NetworkInfos, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *ContainerInfo_DockerInfo) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ContainerInfo_DockerInfo) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "image":`)
	fflib.WriteJsonString(buf, string(mj.Image))
	buf.WriteByte(',')
	if mj.Network != nil {
		if true {
			buf.WriteString(`"network":`)

			{

				obj, err = mj.Network.MarshalJSON()
				if err != nil {
					return err
				}
				buf.Write(obj)

			}
			buf.WriteByte(',')
		}
	}
	buf.WriteString(`"port_mappings":`)
	if mj.PortMappings != nil {
		buf.WriteString(`[`)
		for i, v := range mj.PortMappings {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte(',')
	if mj.Privileged != nil {
		if true {
			if *mj.Privileged {
				buf.WriteString(`"privileged":true`)
			} else {
				buf.WriteString(`"privileged":false`)
			}
			buf.WriteByte(',')
		}
	}
	buf.WriteString(`"parameters":`)
	if mj.Parameters != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Parameters {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte(',')
	if mj.ForcePullImage != nil {
		if true {
			if *mj.ForcePullImage {
				buf.WriteString(`"force_pull_image":true`)
			} else {
				buf.WriteString(`"force_pull_image":false`)
			}
			buf.WriteByte(',')
		}
	}
	if mj.VolumeDriver != nil {
		if true {
			buf.WriteString(`"volume_driver":`)
			fflib.WriteJsonString(buf, string(*mj.VolumeDriver))
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ContainerInfo_DockerInfobase = iota
	ffj_t_ContainerInfo_DockerInfono_such_key

	ffj_t_ContainerInfo_DockerInfo_Image

	ffj_t_ContainerInfo_DockerInfo_Network

	ffj_t_ContainerInfo_DockerInfo_PortMappings

	ffj_t_ContainerInfo_DockerInfo_Privileged

	ffj_t_ContainerInfo_DockerInfo_Parameters

	ffj_t_ContainerInfo_DockerInfo_ForcePullImage

	ffj_t_ContainerInfo_DockerInfo_VolumeDriver
)

var ffj_key_ContainerInfo_DockerInfo_Image = []byte("image")

var ffj_key_ContainerInfo_DockerInfo_Network = []byte("network")

var ffj_key_ContainerInfo_DockerInfo_PortMappings = []byte("port_mappings")

var ffj_key_ContainerInfo_DockerInfo_Privileged = []byte("privileged")

var ffj_key_ContainerInfo_DockerInfo_Parameters = []byte("parameters")

var ffj_key_ContainerInfo_DockerInfo_ForcePullImage = []byte("force_pull_image")

var ffj_key_ContainerInfo_DockerInfo_VolumeDriver = []byte("volume_driver")

func (uj *ContainerInfo_DockerInfo) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ContainerInfo_DockerInfo) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ContainerInfo_DockerInfobase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ContainerInfo_DockerInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'f':

					if bytes.Equal(ffj_key_ContainerInfo_DockerInfo_ForcePullImage, kn) {
						currentKey = ffj_t_ContainerInfo_DockerInfo_ForcePullImage
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_ContainerInfo_DockerInfo_Image, kn) {
						currentKey = ffj_t_ContainerInfo_DockerInfo_Image
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffj_key_ContainerInfo_DockerInfo_Network, kn) {
						currentKey = ffj_t_ContainerInfo_DockerInfo_Network
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_ContainerInfo_DockerInfo_PortMappings, kn) {
						currentKey = ffj_t_ContainerInfo_DockerInfo_PortMappings
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ContainerInfo_DockerInfo_Privileged, kn) {
						currentKey = ffj_t_ContainerInfo_DockerInfo_Privileged
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ContainerInfo_DockerInfo_Parameters, kn) {
						currentKey = ffj_t_ContainerInfo_DockerInfo_Parameters
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'v':

					if bytes.Equal(ffj_key_ContainerInfo_DockerInfo_VolumeDriver, kn) {
						currentKey = ffj_t_ContainerInfo_DockerInfo_VolumeDriver
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffj_key_ContainerInfo_DockerInfo_VolumeDriver, kn) {
					currentKey = ffj_t_ContainerInfo_DockerInfo_VolumeDriver
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_ContainerInfo_DockerInfo_ForcePullImage, kn) {
					currentKey = ffj_t_ContainerInfo_DockerInfo_ForcePullImage
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ContainerInfo_DockerInfo_Parameters, kn) {
					currentKey = ffj_t_ContainerInfo_DockerInfo_Parameters
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ContainerInfo_DockerInfo_Privileged, kn) {
					currentKey = ffj_t_ContainerInfo_DockerInfo_Privileged
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ContainerInfo_DockerInfo_PortMappings, kn) {
					currentKey = ffj_t_ContainerInfo_DockerInfo_PortMappings
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ContainerInfo_DockerInfo_Network, kn) {
					currentKey = ffj_t_ContainerInfo_DockerInfo_Network
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ContainerInfo_DockerInfo_Image, kn) {
					currentKey = ffj_t_ContainerInfo_DockerInfo_Image
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ContainerInfo_DockerInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ContainerInfo_DockerInfo_Image:
					goto handle_Image

				case ffj_t_ContainerInfo_DockerInfo_Network:
					goto handle_Network

				case ffj_t_ContainerInfo_DockerInfo_PortMappings:
					goto handle_PortMappings

				case ffj_t_ContainerInfo_DockerInfo_Privileged:
					goto handle_Privileged

				case ffj_t_ContainerInfo_DockerInfo_Parameters:
					goto handle_Parameters

				case ffj_t_ContainerInfo_DockerInfo_ForcePullImage:
					goto handle_ForcePullImage

				case ffj_t_ContainerInfo_DockerInfo_VolumeDriver:
					goto handle_VolumeDriver

				case ffj_t_ContainerInfo_DockerInfono_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Image:

	/* handler: uj.Image type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Image = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Network:

	/* handler: uj.Network type=mesos.ContainerInfo_DockerInfo_Network kind=int32 quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Network = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		if uj.Network == nil {
			uj.Network = new(ContainerInfo_DockerInfo_Network)
		}

		err = uj.Network.UnmarshalJSON(tbuf)
		if err != nil {
			return fs.WrapErr(err)
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PortMappings:

	/* handler: uj.PortMappings type=[]mesos.ContainerInfo_DockerInfo_PortMapping kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.PortMappings = nil
		} else {

			uj.PortMappings = make([]ContainerInfo_DockerInfo_PortMapping, 0)

			wantVal := true

			for {

				var v ContainerInfo_DockerInfo_PortMapping

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=mesos.ContainerInfo_DockerInfo_PortMapping kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.PortMappings = append(uj.PortMappings, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Privileged:

	/* handler: uj.Privileged type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

			uj.Privileged = nil

		} else {
			tmpb := fs.Output.Bytes()

			var tval bool

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				tval = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				tval = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

			uj.Privileged = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Parameters:

	/* handler: uj.Parameters type=[]mesos.Parameter kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Parameters = nil
		} else {

			uj.Parameters = make([]Parameter, 0)

			wantVal := true

			for {

				var v Parameter

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=mesos.Parameter kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Parameters = append(uj.Parameters, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ForcePullImage:

	/* handler: uj.ForcePullImage type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

			uj.ForcePullImage = nil

		} else {
			tmpb := fs.Output.Bytes()

			var tval bool

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				tval = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				tval = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

			uj.ForcePullImage = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_VolumeDriver:

	/* handler: uj.VolumeDriver type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.VolumeDriver = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.VolumeDriver = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *ContainerInfo_DockerInfo_PortMapping) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ContainerInfo_DockerInfo_PortMapping) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "host_port":`)
	fflib.FormatBits2(buf, uint64(mj.HostPort), 10, false)
	buf.WriteString(`,"container_port":`)
	fflib.FormatBits2(buf, uint64(mj.ContainerPort), 10, false)
	buf.WriteByte(',')
	if mj.Protocol != nil {
		if true {
			buf.WriteString(`"protocol":`)
			fflib.WriteJsonString(buf, string(*mj.Protocol))
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ContainerInfo_DockerInfo_PortMappingbase = iota
	ffj_t_ContainerInfo_DockerInfo_PortMappingno_such_key

	ffj_t_ContainerInfo_DockerInfo_PortMapping_HostPort

	ffj_t_ContainerInfo_DockerInfo_PortMapping_ContainerPort

	ffj_t_ContainerInfo_DockerInfo_PortMapping_Protocol
)

var ffj_key_ContainerInfo_DockerInfo_PortMapping_HostPort = []byte("host_port")

var ffj_key_ContainerInfo_DockerInfo_PortMapping_ContainerPort = []byte("container_port")

var ffj_key_ContainerInfo_DockerInfo_PortMapping_Protocol = []byte("protocol")

func (uj *ContainerInfo_DockerInfo_PortMapping) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ContainerInfo_DockerInfo_PortMapping) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ContainerInfo_DockerInfo_PortMappingbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ContainerInfo_DockerInfo_PortMappingno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_ContainerInfo_DockerInfo_PortMapping_ContainerPort, kn) {
						currentKey = ffj_t_ContainerInfo_DockerInfo_PortMapping_ContainerPort
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'h':

					if bytes.Equal(ffj_key_ContainerInfo_DockerInfo_PortMapping_HostPort, kn) {
						currentKey = ffj_t_ContainerInfo_DockerInfo_PortMapping_HostPort
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_ContainerInfo_DockerInfo_PortMapping_Protocol, kn) {
						currentKey = ffj_t_ContainerInfo_DockerInfo_PortMapping_Protocol
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_ContainerInfo_DockerInfo_PortMapping_Protocol, kn) {
					currentKey = ffj_t_ContainerInfo_DockerInfo_PortMapping_Protocol
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_ContainerInfo_DockerInfo_PortMapping_ContainerPort, kn) {
					currentKey = ffj_t_ContainerInfo_DockerInfo_PortMapping_ContainerPort
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ContainerInfo_DockerInfo_PortMapping_HostPort, kn) {
					currentKey = ffj_t_ContainerInfo_DockerInfo_PortMapping_HostPort
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ContainerInfo_DockerInfo_PortMappingno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ContainerInfo_DockerInfo_PortMapping_HostPort:
					goto handle_HostPort

				case ffj_t_ContainerInfo_DockerInfo_PortMapping_ContainerPort:
					goto handle_ContainerPort

				case ffj_t_ContainerInfo_DockerInfo_PortMapping_Protocol:
					goto handle_Protocol

				case ffj_t_ContainerInfo_DockerInfo_PortMappingno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_HostPort:

	/* handler: uj.HostPort type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.HostPort = uint32(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ContainerPort:

	/* handler: uj.ContainerPort type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.ContainerPort = uint32(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Protocol:

	/* handler: uj.Protocol type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Protocol = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Protocol = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *ContainerInfo_MesosInfo) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ContainerInfo_MesosInfo) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.Image != nil {
		if true {
			buf.WriteString(`"image":`)

			{

				err = mj.Image.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ContainerInfo_MesosInfobase = iota
	ffj_t_ContainerInfo_MesosInfono_such_key

	ffj_t_ContainerInfo_MesosInfo_Image
)

var ffj_key_ContainerInfo_MesosInfo_Image = []byte("image")

func (uj *ContainerInfo_MesosInfo) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ContainerInfo_MesosInfo) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ContainerInfo_MesosInfobase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ContainerInfo_MesosInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'i':

					if bytes.Equal(ffj_key_ContainerInfo_MesosInfo_Image, kn) {
						currentKey = ffj_t_ContainerInfo_MesosInfo_Image
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_ContainerInfo_MesosInfo_Image, kn) {
					currentKey = ffj_t_ContainerInfo_MesosInfo_Image
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ContainerInfo_MesosInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ContainerInfo_MesosInfo_Image:
					goto handle_Image

				case ffj_t_ContainerInfo_MesosInfono_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Image:

	/* handler: uj.Image type=mesos.Image kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Image = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Image == nil {
			uj.Image = new(Image)
		}

		err = uj.Image.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *ContainerStatus) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ContainerStatus) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "network_infos":`)
	if mj.NetworkInfos != nil {
		buf.WriteString(`[`)
		for i, v := range mj.NetworkInfos {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte(',')
	if mj.CgroupInfo != nil {
		if true {
			buf.WriteString(`"cgroup_info":`)

			{

				err = mj.CgroupInfo.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ContainerStatusbase = iota
	ffj_t_ContainerStatusno_such_key

	ffj_t_ContainerStatus_NetworkInfos

	ffj_t_ContainerStatus_CgroupInfo
)

var ffj_key_ContainerStatus_NetworkInfos = []byte("network_infos")

var ffj_key_ContainerStatus_CgroupInfo = []byte("cgroup_info")

func (uj *ContainerStatus) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ContainerStatus) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ContainerStatusbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ContainerStatusno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_ContainerStatus_CgroupInfo, kn) {
						currentKey = ffj_t_ContainerStatus_CgroupInfo
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffj_key_ContainerStatus_NetworkInfos, kn) {
						currentKey = ffj_t_ContainerStatus_NetworkInfos
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffj_key_ContainerStatus_CgroupInfo, kn) {
					currentKey = ffj_t_ContainerStatus_CgroupInfo
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ContainerStatus_NetworkInfos, kn) {
					currentKey = ffj_t_ContainerStatus_NetworkInfos
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ContainerStatusno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ContainerStatus_NetworkInfos:
					goto handle_NetworkInfos

				case ffj_t_ContainerStatus_CgroupInfo:
					goto handle_CgroupInfo

				case ffj_t_ContainerStatusno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_NetworkInfos:

	/* handler: uj.NetworkInfos type=[]mesos.NetworkInfo kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.NetworkInfos = nil
		} else {

			uj.NetworkInfos = make([]NetworkInfo, 0)

			wantVal := true

			for {

				var v NetworkInfo

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=mesos.NetworkInfo kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.NetworkInfos = append(uj.NetworkInfos, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CgroupInfo:

	/* handler: uj.CgroupInfo type=mesos.CgroupInfo kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.CgroupInfo = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.CgroupInfo == nil {
			uj.CgroupInfo = new(CgroupInfo)
		}

		err = uj.CgroupInfo.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Credential) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Credential) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "principal":`)
	fflib.WriteJsonString(buf, string(mj.Principal))
	buf.WriteByte(',')
	if mj.Secret != nil {
		if true {
			buf.WriteString(`"secret":`)
			fflib.WriteJsonString(buf, string(*mj.Secret))
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Credentialbase = iota
	ffj_t_Credentialno_such_key

	ffj_t_Credential_Principal

	ffj_t_Credential_Secret
)

var ffj_key_Credential_Principal = []byte("principal")

var ffj_key_Credential_Secret = []byte("secret")

func (uj *Credential) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Credential) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Credentialbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Credentialno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'p':

					if bytes.Equal(ffj_key_Credential_Principal, kn) {
						currentKey = ffj_t_Credential_Principal
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_Credential_Secret, kn) {
						currentKey = ffj_t_Credential_Secret
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_Credential_Secret, kn) {
					currentKey = ffj_t_Credential_Secret
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Credential_Principal, kn) {
					currentKey = ffj_t_Credential_Principal
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Credentialno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Credential_Principal:
					goto handle_Principal

				case ffj_t_Credential_Secret:
					goto handle_Secret

				case ffj_t_Credentialno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Principal:

	/* handler: uj.Principal type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Principal = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Secret:

	/* handler: uj.Secret type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Secret = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Secret = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Credentials) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Credentials) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"credentials":`)
	if mj.Credentials != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Credentials {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Credentialsbase = iota
	ffj_t_Credentialsno_such_key

	ffj_t_Credentials_Credentials
)

var ffj_key_Credentials_Credentials = []byte("credentials")

func (uj *Credentials) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Credentials) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Credentialsbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Credentialsno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_Credentials_Credentials, kn) {
						currentKey = ffj_t_Credentials_Credentials
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_Credentials_Credentials, kn) {
					currentKey = ffj_t_Credentials_Credentials
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Credentialsno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Credentials_Credentials:
					goto handle_Credentials

				case ffj_t_Credentialsno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Credentials:

	/* handler: uj.Credentials type=[]mesos.Credential kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Credentials = nil
		} else {

			uj.Credentials = make([]Credential, 0)

			wantVal := true

			for {

				var v Credential

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=mesos.Credential kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Credentials = append(uj.Credentials, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *DiscoveryInfo) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *DiscoveryInfo) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "visibility":`)

	{

		obj, err = mj.Visibility.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteByte(',')
	if mj.Name != nil {
		if true {
			buf.WriteString(`"name":`)
			fflib.WriteJsonString(buf, string(*mj.Name))
			buf.WriteByte(',')
		}
	}
	if mj.Environment != nil {
		if true {
			buf.WriteString(`"environment":`)
			fflib.WriteJsonString(buf, string(*mj.Environment))
			buf.WriteByte(',')
		}
	}
	if mj.Location != nil {
		if true {
			buf.WriteString(`"location":`)
			fflib.WriteJsonString(buf, string(*mj.Location))
			buf.WriteByte(',')
		}
	}
	if mj.Version != nil {
		if true {
			buf.WriteString(`"version":`)
			fflib.WriteJsonString(buf, string(*mj.Version))
			buf.WriteByte(',')
		}
	}
	if mj.Ports != nil {
		if true {
			buf.WriteString(`"ports":`)

			{

				err = mj.Ports.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.Labels != nil {
		if true {
			buf.WriteString(`"labels":`)

			{

				err = mj.Labels.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_DiscoveryInfobase = iota
	ffj_t_DiscoveryInfono_such_key

	ffj_t_DiscoveryInfo_Visibility

	ffj_t_DiscoveryInfo_Name

	ffj_t_DiscoveryInfo_Environment

	ffj_t_DiscoveryInfo_Location

	ffj_t_DiscoveryInfo_Version

	ffj_t_DiscoveryInfo_Ports

	ffj_t_DiscoveryInfo_Labels
)

var ffj_key_DiscoveryInfo_Visibility = []byte("visibility")

var ffj_key_DiscoveryInfo_Name = []byte("name")

var ffj_key_DiscoveryInfo_Environment = []byte("environment")

var ffj_key_DiscoveryInfo_Location = []byte("location")

var ffj_key_DiscoveryInfo_Version = []byte("version")

var ffj_key_DiscoveryInfo_Ports = []byte("ports")

var ffj_key_DiscoveryInfo_Labels = []byte("labels")

func (uj *DiscoveryInfo) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *DiscoveryInfo) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_DiscoveryInfobase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_DiscoveryInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'e':

					if bytes.Equal(ffj_key_DiscoveryInfo_Environment, kn) {
						currentKey = ffj_t_DiscoveryInfo_Environment
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffj_key_DiscoveryInfo_Location, kn) {
						currentKey = ffj_t_DiscoveryInfo_Location
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_DiscoveryInfo_Labels, kn) {
						currentKey = ffj_t_DiscoveryInfo_Labels
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffj_key_DiscoveryInfo_Name, kn) {
						currentKey = ffj_t_DiscoveryInfo_Name
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_DiscoveryInfo_Ports, kn) {
						currentKey = ffj_t_DiscoveryInfo_Ports
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'v':

					if bytes.Equal(ffj_key_DiscoveryInfo_Visibility, kn) {
						currentKey = ffj_t_DiscoveryInfo_Visibility
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_DiscoveryInfo_Version, kn) {
						currentKey = ffj_t_DiscoveryInfo_Version
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_DiscoveryInfo_Labels, kn) {
					currentKey = ffj_t_DiscoveryInfo_Labels
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_DiscoveryInfo_Ports, kn) {
					currentKey = ffj_t_DiscoveryInfo_Ports
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_DiscoveryInfo_Version, kn) {
					currentKey = ffj_t_DiscoveryInfo_Version
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_DiscoveryInfo_Location, kn) {
					currentKey = ffj_t_DiscoveryInfo_Location
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_DiscoveryInfo_Environment, kn) {
					currentKey = ffj_t_DiscoveryInfo_Environment
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_DiscoveryInfo_Name, kn) {
					currentKey = ffj_t_DiscoveryInfo_Name
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_DiscoveryInfo_Visibility, kn) {
					currentKey = ffj_t_DiscoveryInfo_Visibility
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_DiscoveryInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_DiscoveryInfo_Visibility:
					goto handle_Visibility

				case ffj_t_DiscoveryInfo_Name:
					goto handle_Name

				case ffj_t_DiscoveryInfo_Environment:
					goto handle_Environment

				case ffj_t_DiscoveryInfo_Location:
					goto handle_Location

				case ffj_t_DiscoveryInfo_Version:
					goto handle_Version

				case ffj_t_DiscoveryInfo_Ports:
					goto handle_Ports

				case ffj_t_DiscoveryInfo_Labels:
					goto handle_Labels

				case ffj_t_DiscoveryInfono_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Visibility:

	/* handler: uj.Visibility type=mesos.DiscoveryInfo_Visibility kind=int32 quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = uj.Visibility.UnmarshalJSON(tbuf)
		if err != nil {
			return fs.WrapErr(err)
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Name:

	/* handler: uj.Name type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Name = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Name = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Environment:

	/* handler: uj.Environment type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Environment = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Environment = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Location:

	/* handler: uj.Location type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Location = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Location = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Version:

	/* handler: uj.Version type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Version = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Version = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Ports:

	/* handler: uj.Ports type=mesos.Ports kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Ports = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Ports == nil {
			uj.Ports = new(Ports)
		}

		err = uj.Ports.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Labels:

	/* handler: uj.Labels type=mesos.Labels kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Labels = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Labels == nil {
			uj.Labels = new(Labels)
		}

		err = uj.Labels.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *DurationInfo) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *DurationInfo) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"nanoseconds":`)
	fflib.FormatBits2(buf, uint64(mj.Nanoseconds), 10, mj.Nanoseconds < 0)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_DurationInfobase = iota
	ffj_t_DurationInfono_such_key

	ffj_t_DurationInfo_Nanoseconds
)

var ffj_key_DurationInfo_Nanoseconds = []byte("nanoseconds")

func (uj *DurationInfo) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *DurationInfo) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_DurationInfobase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_DurationInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'n':

					if bytes.Equal(ffj_key_DurationInfo_Nanoseconds, kn) {
						currentKey = ffj_t_DurationInfo_Nanoseconds
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_DurationInfo_Nanoseconds, kn) {
					currentKey = ffj_t_DurationInfo_Nanoseconds
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_DurationInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_DurationInfo_Nanoseconds:
					goto handle_Nanoseconds

				case ffj_t_DurationInfono_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Nanoseconds:

	/* handler: uj.Nanoseconds type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Nanoseconds = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Environment) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Environment) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"variables":`)
	if mj.Variables != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Variables {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Environmentbase = iota
	ffj_t_Environmentno_such_key

	ffj_t_Environment_Variables
)

var ffj_key_Environment_Variables = []byte("variables")

func (uj *Environment) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Environment) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Environmentbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Environmentno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'v':

					if bytes.Equal(ffj_key_Environment_Variables, kn) {
						currentKey = ffj_t_Environment_Variables
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_Environment_Variables, kn) {
					currentKey = ffj_t_Environment_Variables
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Environmentno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Environment_Variables:
					goto handle_Variables

				case ffj_t_Environmentno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Variables:

	/* handler: uj.Variables type=[]mesos.Environment_Variable kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Variables = nil
		} else {

			uj.Variables = make([]Environment_Variable, 0)

			wantVal := true

			for {

				var v Environment_Variable

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=mesos.Environment_Variable kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Variables = append(uj.Variables, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Environment_Variable) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Environment_Variable) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"name":`)
	fflib.WriteJsonString(buf, string(mj.Name))
	buf.WriteString(`,"value":`)
	fflib.WriteJsonString(buf, string(mj.Value))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Environment_Variablebase = iota
	ffj_t_Environment_Variableno_such_key

	ffj_t_Environment_Variable_Name

	ffj_t_Environment_Variable_Value
)

var ffj_key_Environment_Variable_Name = []byte("name")

var ffj_key_Environment_Variable_Value = []byte("value")

func (uj *Environment_Variable) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Environment_Variable) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Environment_Variablebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Environment_Variableno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'n':

					if bytes.Equal(ffj_key_Environment_Variable_Name, kn) {
						currentKey = ffj_t_Environment_Variable_Name
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'v':

					if bytes.Equal(ffj_key_Environment_Variable_Value, kn) {
						currentKey = ffj_t_Environment_Variable_Value
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_Environment_Variable_Value, kn) {
					currentKey = ffj_t_Environment_Variable_Value
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Environment_Variable_Name, kn) {
					currentKey = ffj_t_Environment_Variable_Name
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Environment_Variableno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Environment_Variable_Name:
					goto handle_Name

				case ffj_t_Environment_Variable_Value:
					goto handle_Value

				case ffj_t_Environment_Variableno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Name:

	/* handler: uj.Name type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Name = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Value:

	/* handler: uj.Value type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Value = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *ExecutorID) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ExecutorID) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"value":`)
	fflib.WriteJsonString(buf, string(mj.Value))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ExecutorIDbase = iota
	ffj_t_ExecutorIDno_such_key

	ffj_t_ExecutorID_Value
)

var ffj_key_ExecutorID_Value = []byte("value")

func (uj *ExecutorID) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ExecutorID) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ExecutorIDbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ExecutorIDno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'v':

					if bytes.Equal(ffj_key_ExecutorID_Value, kn) {
						currentKey = ffj_t_ExecutorID_Value
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_ExecutorID_Value, kn) {
					currentKey = ffj_t_ExecutorID_Value
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ExecutorIDno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ExecutorID_Value:
					goto handle_Value

				case ffj_t_ExecutorIDno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Value:

	/* handler: uj.Value type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Value = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *ExecutorInfo) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ExecutorInfo) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "executor_id":`)

	{

		err = mj.ExecutorID.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte(',')
	if mj.FrameworkID != nil {
		if true {
			buf.WriteString(`"framework_id":`)

			{

				err = mj.FrameworkID.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.WriteString(`"command":`)

	{

		err = mj.Command.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte(',')
	if mj.Container != nil {
		if true {
			buf.WriteString(`"container":`)

			{

				err = mj.Container.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.WriteString(`"resources":`)
	if mj.Resources != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Resources {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte(',')
	if mj.Name != nil {
		if true {
			buf.WriteString(`"name":`)
			fflib.WriteJsonString(buf, string(*mj.Name))
			buf.WriteByte(',')
		}
	}
	if mj.Source != nil {
		if true {
			buf.WriteString(`"source":`)
			fflib.WriteJsonString(buf, string(*mj.Source))
			buf.WriteByte(',')
		}
	}
	if len(mj.Data) != 0 {
		buf.WriteString(`"data":`)
		if mj.Data != nil {
			buf.WriteString(`"`)
			{
				enc := base64.NewEncoder(base64.StdEncoding, buf)
				enc.Write(reflect.Indirect(reflect.ValueOf(mj.Data)).Bytes())
				enc.Close()
			}
			buf.WriteString(`"`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if mj.Discovery != nil {
		if true {
			buf.WriteString(`"discovery":`)

			{

				err = mj.Discovery.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ExecutorInfobase = iota
	ffj_t_ExecutorInfono_such_key

	ffj_t_ExecutorInfo_ExecutorID

	ffj_t_ExecutorInfo_FrameworkID

	ffj_t_ExecutorInfo_Command

	ffj_t_ExecutorInfo_Container

	ffj_t_ExecutorInfo_Resources

	ffj_t_ExecutorInfo_Name

	ffj_t_ExecutorInfo_Source

	ffj_t_ExecutorInfo_Data

	ffj_t_ExecutorInfo_Discovery
)

var ffj_key_ExecutorInfo_ExecutorID = []byte("executor_id")

var ffj_key_ExecutorInfo_FrameworkID = []byte("framework_id")

var ffj_key_ExecutorInfo_Command = []byte("command")

var ffj_key_ExecutorInfo_Container = []byte("container")

var ffj_key_ExecutorInfo_Resources = []byte("resources")

var ffj_key_ExecutorInfo_Name = []byte("name")

var ffj_key_ExecutorInfo_Source = []byte("source")

var ffj_key_ExecutorInfo_Data = []byte("data")

var ffj_key_ExecutorInfo_Discovery = []byte("discovery")

func (uj *ExecutorInfo) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ExecutorInfo) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ExecutorInfobase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ExecutorInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_ExecutorInfo_Command, kn) {
						currentKey = ffj_t_ExecutorInfo_Command
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ExecutorInfo_Container, kn) {
						currentKey = ffj_t_ExecutorInfo_Container
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffj_key_ExecutorInfo_Data, kn) {
						currentKey = ffj_t_ExecutorInfo_Data
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ExecutorInfo_Discovery, kn) {
						currentKey = ffj_t_ExecutorInfo_Discovery
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffj_key_ExecutorInfo_ExecutorID, kn) {
						currentKey = ffj_t_ExecutorInfo_ExecutorID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffj_key_ExecutorInfo_FrameworkID, kn) {
						currentKey = ffj_t_ExecutorInfo_FrameworkID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffj_key_ExecutorInfo_Name, kn) {
						currentKey = ffj_t_ExecutorInfo_Name
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_ExecutorInfo_Resources, kn) {
						currentKey = ffj_t_ExecutorInfo_Resources
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_ExecutorInfo_Source, kn) {
						currentKey = ffj_t_ExecutorInfo_Source
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_ExecutorInfo_Discovery, kn) {
					currentKey = ffj_t_ExecutorInfo_Discovery
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ExecutorInfo_Data, kn) {
					currentKey = ffj_t_ExecutorInfo_Data
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ExecutorInfo_Source, kn) {
					currentKey = ffj_t_ExecutorInfo_Source
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ExecutorInfo_Name, kn) {
					currentKey = ffj_t_ExecutorInfo_Name
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ExecutorInfo_Resources, kn) {
					currentKey = ffj_t_ExecutorInfo_Resources
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ExecutorInfo_Container, kn) {
					currentKey = ffj_t_ExecutorInfo_Container
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ExecutorInfo_Command, kn) {
					currentKey = ffj_t_ExecutorInfo_Command
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ExecutorInfo_FrameworkID, kn) {
					currentKey = ffj_t_ExecutorInfo_FrameworkID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_ExecutorInfo_ExecutorID, kn) {
					currentKey = ffj_t_ExecutorInfo_ExecutorID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ExecutorInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ExecutorInfo_ExecutorID:
					goto handle_ExecutorID

				case ffj_t_ExecutorInfo_FrameworkID:
					goto handle_FrameworkID

				case ffj_t_ExecutorInfo_Command:
					goto handle_Command

				case ffj_t_ExecutorInfo_Container:
					goto handle_Container

				case ffj_t_ExecutorInfo_Resources:
					goto handle_Resources

				case ffj_t_ExecutorInfo_Name:
					goto handle_Name

				case ffj_t_ExecutorInfo_Source:
					goto handle_Source

				case ffj_t_ExecutorInfo_Data:
					goto handle_Data

				case ffj_t_ExecutorInfo_Discovery:
					goto handle_Discovery

				case ffj_t_ExecutorInfono_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ExecutorID:

	/* handler: uj.ExecutorID type=mesos.ExecutorID kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.ExecutorID.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FrameworkID:

	/* handler: uj.FrameworkID type=mesos.FrameworkID kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.FrameworkID = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.FrameworkID == nil {
			uj.FrameworkID = new(FrameworkID)
		}

		err = uj.FrameworkID.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Command:

	/* handler: uj.Command type=mesos.CommandInfo kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.Command.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Container:

	/* handler: uj.Container type=mesos.ContainerInfo kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Container = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Container == nil {
			uj.Container = new(ContainerInfo)
		}

		err = uj.Container.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Resources:

	/* handler: uj.Resources type=[]mesos.Resource kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Resources = nil
		} else {

			uj.Resources = make([]Resource, 0)

			wantVal := true

			for {

				var v Resource

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=mesos.Resource kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Resources = append(uj.Resources, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Name:

	/* handler: uj.Name type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Name = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Name = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Source:

	/* handler: uj.Source type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Source = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Source = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Data:

	/* handler: uj.Data type=[]uint8 kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Data = nil
		} else {
			b := make([]byte, base64.StdEncoding.DecodedLen(fs.Output.Len()))
			n, err := base64.StdEncoding.Decode(b, fs.Output.Bytes())
			if err != nil {
				return fs.WrapErr(err)
			}

			v := reflect.ValueOf(&uj.Data).Elem()
			v.SetBytes(b[0:n])

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Discovery:

	/* handler: uj.Discovery type=mesos.DiscoveryInfo kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Discovery = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Discovery == nil {
			uj.Discovery = new(DiscoveryInfo)
		}

		err = uj.Discovery.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Filters) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Filters) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.RefuseSeconds != nil {
		if true {
			buf.WriteString(`"refuse_seconds":`)
			fflib.AppendFloat(buf, float64(*mj.RefuseSeconds), 'g', -1, 64)
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Filtersbase = iota
	ffj_t_Filtersno_such_key

	ffj_t_Filters_RefuseSeconds
)

var ffj_key_Filters_RefuseSeconds = []byte("refuse_seconds")

func (uj *Filters) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Filters) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Filtersbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Filtersno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'r':

					if bytes.Equal(ffj_key_Filters_RefuseSeconds, kn) {
						currentKey = ffj_t_Filters_RefuseSeconds
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_Filters_RefuseSeconds, kn) {
					currentKey = ffj_t_Filters_RefuseSeconds
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Filtersno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Filters_RefuseSeconds:
					goto handle_RefuseSeconds

				case ffj_t_Filtersno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_RefuseSeconds:

	/* handler: uj.RefuseSeconds type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.RefuseSeconds = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			uj.RefuseSeconds = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *FrameworkID) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *FrameworkID) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"value":`)
	fflib.WriteJsonString(buf, string(mj.Value))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_FrameworkIDbase = iota
	ffj_t_FrameworkIDno_such_key

	ffj_t_FrameworkID_Value
)

var ffj_key_FrameworkID_Value = []byte("value")

func (uj *FrameworkID) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *FrameworkID) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_FrameworkIDbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_FrameworkIDno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'v':

					if bytes.Equal(ffj_key_FrameworkID_Value, kn) {
						currentKey = ffj_t_FrameworkID_Value
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_FrameworkID_Value, kn) {
					currentKey = ffj_t_FrameworkID_Value
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_FrameworkIDno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_FrameworkID_Value:
					goto handle_Value

				case ffj_t_FrameworkIDno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Value:

	/* handler: uj.Value type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Value = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *FrameworkInfo) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *FrameworkInfo) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "user":`)
	fflib.WriteJsonString(buf, string(mj.User))
	buf.WriteString(`,"name":`)
	fflib.WriteJsonString(buf, string(mj.Name))
	buf.WriteByte(',')
	if mj.ID != nil {
		if true {
			buf.WriteString(`"id":`)

			{

				err = mj.ID.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.FailoverTimeout != nil {
		if true {
			buf.WriteString(`"failover_timeout":`)
			fflib.AppendFloat(buf, float64(*mj.FailoverTimeout), 'g', -1, 64)
			buf.WriteByte(',')
		}
	}
	if mj.Checkpoint != nil {
		if true {
			if *mj.Checkpoint {
				buf.WriteString(`"checkpoint":true`)
			} else {
				buf.WriteString(`"checkpoint":false`)
			}
			buf.WriteByte(',')
		}
	}
	if mj.Role != nil {
		if true {
			buf.WriteString(`"role":`)
			fflib.WriteJsonString(buf, string(*mj.Role))
			buf.WriteByte(',')
		}
	}
	if mj.Hostname != nil {
		if true {
			buf.WriteString(`"hostname":`)
			fflib.WriteJsonString(buf, string(*mj.Hostname))
			buf.WriteByte(',')
		}
	}
	if mj.Principal != nil {
		if true {
			buf.WriteString(`"principal":`)
			fflib.WriteJsonString(buf, string(*mj.Principal))
			buf.WriteByte(',')
		}
	}
	if mj.WebuiUrl != nil {
		if true {
			buf.WriteString(`"webui_url":`)
			fflib.WriteJsonString(buf, string(*mj.WebuiUrl))
			buf.WriteByte(',')
		}
	}
	buf.WriteString(`"capabilities":`)
	if mj.Capabilities != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Capabilities {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte(',')
	if mj.Labels != nil {
		if true {
			buf.WriteString(`"labels":`)

			{

				err = mj.Labels.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_FrameworkInfobase = iota
	ffj_t_FrameworkInfono_such_key

	ffj_t_FrameworkInfo_User

	ffj_t_FrameworkInfo_Name

	ffj_t_FrameworkInfo_ID

	ffj_t_FrameworkInfo_FailoverTimeout

	ffj_t_FrameworkInfo_Checkpoint

	ffj_t_FrameworkInfo_Role

	ffj_t_FrameworkInfo_Hostname

	ffj_t_FrameworkInfo_Principal

	ffj_t_FrameworkInfo_WebuiUrl

	ffj_t_FrameworkInfo_Capabilities

	ffj_t_FrameworkInfo_Labels
)

var ffj_key_FrameworkInfo_User = []byte("user")

var ffj_key_FrameworkInfo_Name = []byte("name")

var ffj_key_FrameworkInfo_ID = []byte("id")

var ffj_key_FrameworkInfo_FailoverTimeout = []byte("failover_timeout")

var ffj_key_FrameworkInfo_Checkpoint = []byte("checkpoint")

var ffj_key_FrameworkInfo_Role = []byte("role")

var ffj_key_FrameworkInfo_Hostname = []byte("hostname")

var ffj_key_FrameworkInfo_Principal = []byte("principal")

var ffj_key_FrameworkInfo_WebuiUrl = []byte("webui_url")

var ffj_key_FrameworkInfo_Capabilities = []byte("capabilities")

var ffj_key_FrameworkInfo_Labels = []byte("labels")

func (uj *FrameworkInfo) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *FrameworkInfo) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_FrameworkInfobase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_FrameworkInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_FrameworkInfo_Checkpoint, kn) {
						currentKey = ffj_t_FrameworkInfo_Checkpoint
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_FrameworkInfo_Capabilities, kn) {
						currentKey = ffj_t_FrameworkInfo_Capabilities
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffj_key_FrameworkInfo_FailoverTimeout, kn) {
						currentKey = ffj_t_FrameworkInfo_FailoverTimeout
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'h':

					if bytes.Equal(ffj_key_FrameworkInfo_Hostname, kn) {
						currentKey = ffj_t_FrameworkInfo_Hostname
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_FrameworkInfo_ID, kn) {
						currentKey = ffj_t_FrameworkInfo_ID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffj_key_FrameworkInfo_Labels, kn) {
						currentKey = ffj_t_FrameworkInfo_Labels
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffj_key_FrameworkInfo_Name, kn) {
						currentKey = ffj_t_FrameworkInfo_Name
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_FrameworkInfo_Principal, kn) {
						currentKey = ffj_t_FrameworkInfo_Principal
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_FrameworkInfo_Role, kn) {
						currentKey = ffj_t_FrameworkInfo_Role
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffj_key_FrameworkInfo_User, kn) {
						currentKey = ffj_t_FrameworkInfo_User
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'w':

					if bytes.Equal(ffj_key_FrameworkInfo_WebuiUrl, kn) {
						currentKey = ffj_t_FrameworkInfo_WebuiUrl
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_FrameworkInfo_Labels, kn) {
					currentKey = ffj_t_FrameworkInfo_Labels
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_FrameworkInfo_Capabilities, kn) {
					currentKey = ffj_t_FrameworkInfo_Capabilities
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_FrameworkInfo_WebuiUrl, kn) {
					currentKey = ffj_t_FrameworkInfo_WebuiUrl
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_FrameworkInfo_Principal, kn) {
					currentKey = ffj_t_FrameworkInfo_Principal
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_FrameworkInfo_Hostname, kn) {
					currentKey = ffj_t_FrameworkInfo_Hostname
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_FrameworkInfo_Role, kn) {
					currentKey = ffj_t_FrameworkInfo_Role
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_FrameworkInfo_Checkpoint, kn) {
					currentKey = ffj_t_FrameworkInfo_Checkpoint
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_FrameworkInfo_FailoverTimeout, kn) {
					currentKey = ffj_t_FrameworkInfo_FailoverTimeout
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_FrameworkInfo_ID, kn) {
					currentKey = ffj_t_FrameworkInfo_ID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_FrameworkInfo_Name, kn) {
					currentKey = ffj_t_FrameworkInfo_Name
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_FrameworkInfo_User, kn) {
					currentKey = ffj_t_FrameworkInfo_User
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_FrameworkInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_FrameworkInfo_User:
					goto handle_User

				case ffj_t_FrameworkInfo_Name:
					goto handle_Name

				case ffj_t_FrameworkInfo_ID:
					goto handle_ID

				case ffj_t_FrameworkInfo_FailoverTimeout:
					goto handle_FailoverTimeout

				case ffj_t_FrameworkInfo_Checkpoint:
					goto handle_Checkpoint

				case ffj_t_FrameworkInfo_Role:
					goto handle_Role

				case ffj_t_FrameworkInfo_Hostname:
					goto handle_Hostname

				case ffj_t_FrameworkInfo_Principal:
					goto handle_Principal

				case ffj_t_FrameworkInfo_WebuiUrl:
					goto handle_WebuiUrl

				case ffj_t_FrameworkInfo_Capabilities:
					goto handle_Capabilities

				case ffj_t_FrameworkInfo_Labels:
					goto handle_Labels

				case ffj_t_FrameworkInfono_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_User:

	/* handler: uj.User type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.User = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Name:

	/* handler: uj.Name type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Name = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ID:

	/* handler: uj.ID type=mesos.FrameworkID kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.ID = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.ID == nil {
			uj.ID = new(FrameworkID)
		}

		err = uj.ID.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FailoverTimeout:

	/* handler: uj.FailoverTimeout type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.FailoverTimeout = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			uj.FailoverTimeout = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Checkpoint:

	/* handler: uj.Checkpoint type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

			uj.Checkpoint = nil

		} else {
			tmpb := fs.Output.Bytes()

			var tval bool

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				tval = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				tval = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

			uj.Checkpoint = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Role:

	/* handler: uj.Role type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Role = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Role = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Hostname:

	/* handler: uj.Hostname type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Hostname = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Hostname = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Principal:

	/* handler: uj.Principal type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Principal = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Principal = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_WebuiUrl:

	/* handler: uj.WebuiUrl type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.WebuiUrl = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.WebuiUrl = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Capabilities:

	/* handler: uj.Capabilities type=[]mesos.FrameworkInfo_Capability kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Capabilities = nil
		} else {

			uj.Capabilities = make([]FrameworkInfo_Capability, 0)

			wantVal := true

			for {

				var v FrameworkInfo_Capability

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=mesos.FrameworkInfo_Capability kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Capabilities = append(uj.Capabilities, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Labels:

	/* handler: uj.Labels type=mesos.Labels kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Labels = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Labels == nil {
			uj.Labels = new(Labels)
		}

		err = uj.Labels.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *FrameworkInfo_Capability) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *FrameworkInfo_Capability) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"type":`)

	{

		obj, err = mj.Type.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_FrameworkInfo_Capabilitybase = iota
	ffj_t_FrameworkInfo_Capabilityno_such_key

	ffj_t_FrameworkInfo_Capability_Type
)

var ffj_key_FrameworkInfo_Capability_Type = []byte("type")

func (uj *FrameworkInfo_Capability) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *FrameworkInfo_Capability) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_FrameworkInfo_Capabilitybase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_FrameworkInfo_Capabilityno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 't':

					if bytes.Equal(ffj_key_FrameworkInfo_Capability_Type, kn) {
						currentKey = ffj_t_FrameworkInfo_Capability_Type
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_FrameworkInfo_Capability_Type, kn) {
					currentKey = ffj_t_FrameworkInfo_Capability_Type
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_FrameworkInfo_Capabilityno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_FrameworkInfo_Capability_Type:
					goto handle_Type

				case ffj_t_FrameworkInfo_Capabilityno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Type:

	/* handler: uj.Type type=mesos.FrameworkInfo_Capability_Type kind=int32 quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = uj.Type.UnmarshalJSON(tbuf)
		if err != nil {
			return fs.WrapErr(err)
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *HealthCheck) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *HealthCheck) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.Http != nil {
		if true {
			buf.WriteString(`"http":`)

			{

				err = mj.Http.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.DelaySeconds != nil {
		if true {
			buf.WriteString(`"delay_seconds":`)
			fflib.AppendFloat(buf, float64(*mj.DelaySeconds), 'g', -1, 64)
			buf.WriteByte(',')
		}
	}
	if mj.IntervalSeconds != nil {
		if true {
			buf.WriteString(`"interval_seconds":`)
			fflib.AppendFloat(buf, float64(*mj.IntervalSeconds), 'g', -1, 64)
			buf.WriteByte(',')
		}
	}
	if mj.TimeoutSeconds != nil {
		if true {
			buf.WriteString(`"timeout_seconds":`)
			fflib.AppendFloat(buf, float64(*mj.TimeoutSeconds), 'g', -1, 64)
			buf.WriteByte(',')
		}
	}
	if mj.ConsecutiveFailures != nil {
		if true {
			buf.WriteString(`"consecutive_failures":`)
			fflib.FormatBits2(buf, uint64(*mj.ConsecutiveFailures), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.GracePeriodSeconds != nil {
		if true {
			buf.WriteString(`"grace_period_seconds":`)
			fflib.AppendFloat(buf, float64(*mj.GracePeriodSeconds), 'g', -1, 64)
			buf.WriteByte(',')
		}
	}
	if mj.Command != nil {
		if true {
			buf.WriteString(`"command":`)

			{

				err = mj.Command.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_HealthCheckbase = iota
	ffj_t_HealthCheckno_such_key

	ffj_t_HealthCheck_Http

	ffj_t_HealthCheck_DelaySeconds

	ffj_t_HealthCheck_IntervalSeconds

	ffj_t_HealthCheck_TimeoutSeconds

	ffj_t_HealthCheck_ConsecutiveFailures

	ffj_t_HealthCheck_GracePeriodSeconds

	ffj_t_HealthCheck_Command
)

var ffj_key_HealthCheck_Http = []byte("http")

var ffj_key_HealthCheck_DelaySeconds = []byte("delay_seconds")

var ffj_key_HealthCheck_IntervalSeconds = []byte("interval_seconds")

var ffj_key_HealthCheck_TimeoutSeconds = []byte("timeout_seconds")

var ffj_key_HealthCheck_ConsecutiveFailures = []byte("consecutive_failures")

var ffj_key_HealthCheck_GracePeriodSeconds = []byte("grace_period_seconds")

var ffj_key_HealthCheck_Command = []byte("command")

func (uj *HealthCheck) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *HealthCheck) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_HealthCheckbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_HealthCheckno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_HealthCheck_ConsecutiveFailures, kn) {
						currentKey = ffj_t_HealthCheck_ConsecutiveFailures
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_HealthCheck_Command, kn) {
						currentKey = ffj_t_HealthCheck_Command
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffj_key_HealthCheck_DelaySeconds, kn) {
						currentKey = ffj_t_HealthCheck_DelaySeconds
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffj_key_HealthCheck_GracePeriodSeconds, kn) {
						currentKey = ffj_t_HealthCheck_GracePeriodSeconds
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'h':

					if bytes.Equal(ffj_key_HealthCheck_Http, kn) {
						currentKey = ffj_t_HealthCheck_Http
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_HealthCheck_IntervalSeconds, kn) {
						currentKey = ffj_t_HealthCheck_IntervalSeconds
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_HealthCheck_TimeoutSeconds, kn) {
						currentKey = ffj_t_HealthCheck_TimeoutSeconds
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_HealthCheck_Command, kn) {
					currentKey = ffj_t_HealthCheck_Command
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_HealthCheck_GracePeriodSeconds, kn) {
					currentKey = ffj_t_HealthCheck_GracePeriodSeconds
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_HealthCheck_ConsecutiveFailures, kn) {
					currentKey = ffj_t_HealthCheck_ConsecutiveFailures
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_HealthCheck_TimeoutSeconds, kn) {
					currentKey = ffj_t_HealthCheck_TimeoutSeconds
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_HealthCheck_IntervalSeconds, kn) {
					currentKey = ffj_t_HealthCheck_IntervalSeconds
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_HealthCheck_DelaySeconds, kn) {
					currentKey = ffj_t_HealthCheck_DelaySeconds
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_HealthCheck_Http, kn) {
					currentKey = ffj_t_HealthCheck_Http
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_HealthCheckno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_HealthCheck_Http:
					goto handle_Http

				case ffj_t_HealthCheck_DelaySeconds:
					goto handle_DelaySeconds

				case ffj_t_HealthCheck_IntervalSeconds:
					goto handle_IntervalSeconds

				case ffj_t_HealthCheck_TimeoutSeconds:
					goto handle_TimeoutSeconds

				case ffj_t_HealthCheck_ConsecutiveFailures:
					goto handle_ConsecutiveFailures

				case ffj_t_HealthCheck_GracePeriodSeconds:
					goto handle_GracePeriodSeconds

				case ffj_t_HealthCheck_Command:
					goto handle_Command

				case ffj_t_HealthCheckno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Http:

	/* handler: uj.Http type=mesos.HealthCheck_HTTP kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Http = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Http == nil {
			uj.Http = new(HealthCheck_HTTP)
		}

		err = uj.Http.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DelaySeconds:

	/* handler: uj.DelaySeconds type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.DelaySeconds = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			uj.DelaySeconds = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_IntervalSeconds:

	/* handler: uj.IntervalSeconds type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.IntervalSeconds = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			uj.IntervalSeconds = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TimeoutSeconds:

	/* handler: uj.TimeoutSeconds type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.TimeoutSeconds = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			uj.TimeoutSeconds = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ConsecutiveFailures:

	/* handler: uj.ConsecutiveFailures type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.ConsecutiveFailures = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint32(tval)
			uj.ConsecutiveFailures = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GracePeriodSeconds:

	/* handler: uj.GracePeriodSeconds type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.GracePeriodSeconds = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			uj.GracePeriodSeconds = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Command:

	/* handler: uj.Command type=mesos.CommandInfo kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Command = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Command == nil {
			uj.Command = new(CommandInfo)
		}

		err = uj.Command.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *HealthCheck_HTTP) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *HealthCheck_HTTP) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "port":`)
	fflib.FormatBits2(buf, uint64(mj.Port), 10, false)
	buf.WriteByte(',')
	if mj.Path != nil {
		if true {
			buf.WriteString(`"path":`)
			fflib.WriteJsonString(buf, string(*mj.Path))
			buf.WriteByte(',')
		}
	}
	if len(mj.Statuses) != 0 {
		buf.WriteString(`"statuses":`)
		if mj.Statuses != nil {
			buf.WriteString(`[`)
			for i, v := range mj.Statuses {
				if i != 0 {
					buf.WriteString(`,`)
				}
				fflib.FormatBits2(buf, uint64(v), 10, false)
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_HealthCheck_HTTPbase = iota
	ffj_t_HealthCheck_HTTPno_such_key

	ffj_t_HealthCheck_HTTP_Port

	ffj_t_HealthCheck_HTTP_Path

	ffj_t_HealthCheck_HTTP_Statuses
)

var ffj_key_HealthCheck_HTTP_Port = []byte("port")

var ffj_key_HealthCheck_HTTP_Path = []byte("path")

var ffj_key_HealthCheck_HTTP_Statuses = []byte("statuses")

func (uj *HealthCheck_HTTP) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *HealthCheck_HTTP) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_HealthCheck_HTTPbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_HealthCheck_HTTPno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'p':

					if bytes.Equal(ffj_key_HealthCheck_HTTP_Port, kn) {
						currentKey = ffj_t_HealthCheck_HTTP_Port
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_HealthCheck_HTTP_Path, kn) {
						currentKey = ffj_t_HealthCheck_HTTP_Path
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_HealthCheck_HTTP_Statuses, kn) {
						currentKey = ffj_t_HealthCheck_HTTP_Statuses
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_HealthCheck_HTTP_Statuses, kn) {
					currentKey = ffj_t_HealthCheck_HTTP_Statuses
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_HealthCheck_HTTP_Path, kn) {
					currentKey = ffj_t_HealthCheck_HTTP_Path
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_HealthCheck_HTTP_Port, kn) {
					currentKey = ffj_t_HealthCheck_HTTP_Port
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_HealthCheck_HTTPno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_HealthCheck_HTTP_Port:
					goto handle_Port

				case ffj_t_HealthCheck_HTTP_Path:
					goto handle_Path

				case ffj_t_HealthCheck_HTTP_Statuses:
					goto handle_Statuses

				case ffj_t_HealthCheck_HTTPno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Port:

	/* handler: uj.Port type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Port = uint32(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Path:

	/* handler: uj.Path type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Path = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Path = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Statuses:

	/* handler: uj.Statuses type=[]uint32 kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Statuses = nil
		} else {

			uj.Statuses = make([]uint32, 0)

			wantVal := true

			for {

				var v uint32

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=uint32 kind=uint32 quoted=false*/

				{
					if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
						return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
					}
				}

				{

					if tok == fflib.FFTok_null {

					} else {

						tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

						if err != nil {
							return fs.WrapErr(err)
						}

						v = uint32(tval)

					}
				}

				uj.Statuses = append(uj.Statuses, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *IcmpStatistics) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *IcmpStatistics) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.InMsgs != nil {
		if true {
			buf.WriteString(`"InMsgs":`)
			fflib.FormatBits2(buf, uint64(*mj.InMsgs), 10, *mj.InMsgs < 0)
			buf.WriteByte(',')
		}
	}
	if mj.InErrors != nil {
		if true {
			buf.WriteString(`"InErrors":`)
			fflib.FormatBits2(buf, uint64(*mj.InErrors), 10, *mj.InErrors < 0)
			buf.WriteByte(',')
		}
	}
	if mj.InCsumErrors != nil {
		if true {
			buf.WriteString(`"InCsumErrors":`)
			fflib.FormatBits2(buf, uint64(*mj.InCsumErrors), 10, *mj.InCsumErrors < 0)
			buf.WriteByte(',')
		}
	}
	if mj.InDestUnreachs != nil {
		if true {
			buf.WriteString(`"InDestUnreachs":`)
			fflib.FormatBits2(buf, uint64(*mj.InDestUnreachs), 10, *mj.InDestUnreachs < 0)
			buf.WriteByte(',')
		}
	}
	if mj.InTimeExcds != nil {
		if true {
			buf.WriteString(`"InTimeExcds":`)
			fflib.FormatBits2(buf, uint64(*mj.InTimeExcds), 10, *mj.InTimeExcds < 0)
			buf.WriteByte(',')
		}
	}
	if mj.InParmProbs != nil {
		if true {
			buf.WriteString(`"InParmProbs":`)
			fflib.FormatBits2(buf, uint64(*mj.InParmProbs), 10, *mj.InParmProbs < 0)
			buf.WriteByte(',')
		}
	}
	if mj.InSrcQuenchs != nil {
		if true {
			buf.WriteString(`"InSrcQuenchs":`)
			fflib.FormatBits2(buf, uint64(*mj.InSrcQuenchs), 10, *mj.InSrcQuenchs < 0)
			buf.WriteByte(',')
		}
	}
	if mj.InRedirects != nil {
		if true {
			buf.WriteString(`"InRedirects":`)
			fflib.FormatBits2(buf, uint64(*mj.InRedirects), 10, *mj.InRedirects < 0)
			buf.WriteByte(',')
		}
	}
	if mj.InEchos != nil {
		if true {
			buf.WriteString(`"InEchos":`)
			fflib.FormatBits2(buf, uint64(*mj.InEchos), 10, *mj.InEchos < 0)
			buf.WriteByte(',')
		}
	}
	if mj.InEchoReps != nil {
		if true {
			buf.WriteString(`"InEchoReps":`)
			fflib.FormatBits2(buf, uint64(*mj.InEchoReps), 10, *mj.InEchoReps < 0)
			buf.WriteByte(',')
		}
	}
	if mj.InTimestamps != nil {
		if true {
			buf.WriteString(`"InTimestamps":`)
			fflib.FormatBits2(buf, uint64(*mj.InTimestamps), 10, *mj.InTimestamps < 0)
			buf.WriteByte(',')
		}
	}
	if mj.InTimestampReps != nil {
		if true {
			buf.WriteString(`"InTimestampReps":`)
			fflib.FormatBits2(buf, uint64(*mj.InTimestampReps), 10, *mj.InTimestampReps < 0)
			buf.WriteByte(',')
		}
	}
	if mj.InAddrMasks != nil {
		if true {
			buf.WriteString(`"InAddrMasks":`)
			fflib.FormatBits2(buf, uint64(*mj.InAddrMasks), 10, *mj.InAddrMasks < 0)
			buf.WriteByte(',')
		}
	}
	if mj.InAddrMaskReps != nil {
		if true {
			buf.WriteString(`"InAddrMaskReps":`)
			fflib.FormatBits2(buf, uint64(*mj.InAddrMaskReps), 10, *mj.InAddrMaskReps < 0)
			buf.WriteByte(',')
		}
	}
	if mj.OutMsgs != nil {
		if true {
			buf.WriteString(`"OutMsgs":`)
			fflib.FormatBits2(buf, uint64(*mj.OutMsgs), 10, *mj.OutMsgs < 0)
			buf.WriteByte(',')
		}
	}
	if mj.OutErrors != nil {
		if true {
			buf.WriteString(`"OutErrors":`)
			fflib.FormatBits2(buf, uint64(*mj.OutErrors), 10, *mj.OutErrors < 0)
			buf.WriteByte(',')
		}
	}
	if mj.OutDestUnreachs != nil {
		if true {
			buf.WriteString(`"OutDestUnreachs":`)
			fflib.FormatBits2(buf, uint64(*mj.OutDestUnreachs), 10, *mj.OutDestUnreachs < 0)
			buf.WriteByte(',')
		}
	}
	if mj.OutTimeExcds != nil {
		if true {
			buf.WriteString(`"OutTimeExcds":`)
			fflib.FormatBits2(buf, uint64(*mj.OutTimeExcds), 10, *mj.OutTimeExcds < 0)
			buf.WriteByte(',')
		}
	}
	if mj.OutParmProbs != nil {
		if true {
			buf.WriteString(`"OutParmProbs":`)
			fflib.FormatBits2(buf, uint64(*mj.OutParmProbs), 10, *mj.OutParmProbs < 0)
			buf.WriteByte(',')
		}
	}
	if mj.OutSrcQuenchs != nil {
		if true {
			buf.WriteString(`"OutSrcQuenchs":`)
			fflib.FormatBits2(buf, uint64(*mj.OutSrcQuenchs), 10, *mj.OutSrcQuenchs < 0)
			buf.WriteByte(',')
		}
	}
	if mj.OutRedirects != nil {
		if true {
			buf.WriteString(`"OutRedirects":`)
			fflib.FormatBits2(buf, uint64(*mj.OutRedirects), 10, *mj.OutRedirects < 0)
			buf.WriteByte(',')
		}
	}
	if mj.OutEchos != nil {
		if true {
			buf.WriteString(`"OutEchos":`)
			fflib.FormatBits2(buf, uint64(*mj.OutEchos), 10, *mj.OutEchos < 0)
			buf.WriteByte(',')
		}
	}
	if mj.OutEchoReps != nil {
		if true {
			buf.WriteString(`"OutEchoReps":`)
			fflib.FormatBits2(buf, uint64(*mj.OutEchoReps), 10, *mj.OutEchoReps < 0)
			buf.WriteByte(',')
		}
	}
	if mj.OutTimestamps != nil {
		if true {
			buf.WriteString(`"OutTimestamps":`)
			fflib.FormatBits2(buf, uint64(*mj.OutTimestamps), 10, *mj.OutTimestamps < 0)
			buf.WriteByte(',')
		}
	}
	if mj.OutTimestampReps != nil {
		if true {
			buf.WriteString(`"OutTimestampReps":`)
			fflib.FormatBits2(buf, uint64(*mj.OutTimestampReps), 10, *mj.OutTimestampReps < 0)
			buf.WriteByte(',')
		}
	}
	if mj.OutAddrMasks != nil {
		if true {
			buf.WriteString(`"OutAddrMasks":`)
			fflib.FormatBits2(buf, uint64(*mj.OutAddrMasks), 10, *mj.OutAddrMasks < 0)
			buf.WriteByte(',')
		}
	}
	if mj.OutAddrMaskReps != nil {
		if true {
			buf.WriteString(`"OutAddrMaskReps":`)
			fflib.FormatBits2(buf, uint64(*mj.OutAddrMaskReps), 10, *mj.OutAddrMaskReps < 0)
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_IcmpStatisticsbase = iota
	ffj_t_IcmpStatisticsno_such_key

	ffj_t_IcmpStatistics_InMsgs

	ffj_t_IcmpStatistics_InErrors

	ffj_t_IcmpStatistics_InCsumErrors

	ffj_t_IcmpStatistics_InDestUnreachs

	ffj_t_IcmpStatistics_InTimeExcds

	ffj_t_IcmpStatistics_InParmProbs

	ffj_t_IcmpStatistics_InSrcQuenchs

	ffj_t_IcmpStatistics_InRedirects

	ffj_t_IcmpStatistics_InEchos

	ffj_t_IcmpStatistics_InEchoReps

	ffj_t_IcmpStatistics_InTimestamps

	ffj_t_IcmpStatistics_InTimestampReps

	ffj_t_IcmpStatistics_InAddrMasks

	ffj_t_IcmpStatistics_InAddrMaskReps

	ffj_t_IcmpStatistics_OutMsgs

	ffj_t_IcmpStatistics_OutErrors

	ffj_t_IcmpStatistics_OutDestUnreachs

	ffj_t_IcmpStatistics_OutTimeExcds

	ffj_t_IcmpStatistics_OutParmProbs

	ffj_t_IcmpStatistics_OutSrcQuenchs

	ffj_t_IcmpStatistics_OutRedirects

	ffj_t_IcmpStatistics_OutEchos

	ffj_t_IcmpStatistics_OutEchoReps

	ffj_t_IcmpStatistics_OutTimestamps

	ffj_t_IcmpStatistics_OutTimestampReps

	ffj_t_IcmpStatistics_OutAddrMasks

	ffj_t_IcmpStatistics_OutAddrMaskReps
)

var ffj_key_IcmpStatistics_InMsgs = []byte("InMsgs")

var ffj_key_IcmpStatistics_InErrors = []byte("InErrors")

var ffj_key_IcmpStatistics_InCsumErrors = []byte("InCsumErrors")

var ffj_key_IcmpStatistics_InDestUnreachs = []byte("InDestUnreachs")

var ffj_key_IcmpStatistics_InTimeExcds = []byte("InTimeExcds")

var ffj_key_IcmpStatistics_InParmProbs = []byte("InParmProbs")

var ffj_key_IcmpStatistics_InSrcQuenchs = []byte("InSrcQuenchs")

var ffj_key_IcmpStatistics_InRedirects = []byte("InRedirects")

var ffj_key_IcmpStatistics_InEchos = []byte("InEchos")

var ffj_key_IcmpStatistics_InEchoReps = []byte("InEchoReps")

var ffj_key_IcmpStatistics_InTimestamps = []byte("InTimestamps")

var ffj_key_IcmpStatistics_InTimestampReps = []byte("InTimestampReps")

var ffj_key_IcmpStatistics_InAddrMasks = []byte("InAddrMasks")

var ffj_key_IcmpStatistics_InAddrMaskReps = []byte("InAddrMaskReps")

var ffj_key_IcmpStatistics_OutMsgs = []byte("OutMsgs")

var ffj_key_IcmpStatistics_OutErrors = []byte("OutErrors")

var ffj_key_IcmpStatistics_OutDestUnreachs = []byte("OutDestUnreachs")

var ffj_key_IcmpStatistics_OutTimeExcds = []byte("OutTimeExcds")

var ffj_key_IcmpStatistics_OutParmProbs = []byte("OutParmProbs")

var ffj_key_IcmpStatistics_OutSrcQuenchs = []byte("OutSrcQuenchs")

var ffj_key_IcmpStatistics_OutRedirects = []byte("OutRedirects")

var ffj_key_IcmpStatistics_OutEchos = []byte("OutEchos")

var ffj_key_IcmpStatistics_OutEchoReps = []byte("OutEchoReps")

var ffj_key_IcmpStatistics_OutTimestamps = []byte("OutTimestamps")

var ffj_key_IcmpStatistics_OutTimestampReps = []byte("OutTimestampReps")

var ffj_key_IcmpStatistics_OutAddrMasks = []byte("OutAddrMasks")

var ffj_key_IcmpStatistics_OutAddrMaskReps = []byte("OutAddrMaskReps")

func (uj *IcmpStatistics) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *IcmpStatistics) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_IcmpStatisticsbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_IcmpStatisticsno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'I':

					if bytes.Equal(ffj_key_IcmpStatistics_InMsgs, kn) {
						currentKey = ffj_t_IcmpStatistics_InMsgs
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_IcmpStatistics_InErrors, kn) {
						currentKey = ffj_t_IcmpStatistics_InErrors
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_IcmpStatistics_InCsumErrors, kn) {
						currentKey = ffj_t_IcmpStatistics_InCsumErrors
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_IcmpStatistics_InDestUnreachs, kn) {
						currentKey = ffj_t_IcmpStatistics_InDestUnreachs
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_IcmpStatistics_InTimeExcds, kn) {
						currentKey = ffj_t_IcmpStatistics_InTimeExcds
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_IcmpStatistics_InParmProbs, kn) {
						currentKey = ffj_t_IcmpStatistics_InParmProbs
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_IcmpStatistics_InSrcQuenchs, kn) {
						currentKey = ffj_t_IcmpStatistics_InSrcQuenchs
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_IcmpStatistics_InRedirects, kn) {
						currentKey = ffj_t_IcmpStatistics_InRedirects
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_IcmpStatistics_InEchos, kn) {
						currentKey = ffj_t_IcmpStatistics_InEchos
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_IcmpStatistics_InEchoReps, kn) {
						currentKey = ffj_t_IcmpStatistics_InEchoReps
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_IcmpStatistics_InTimestamps, kn) {
						currentKey = ffj_t_IcmpStatistics_InTimestamps
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_IcmpStatistics_InTimestampReps, kn) {
						currentKey = ffj_t_IcmpStatistics_InTimestampReps
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_IcmpStatistics_InAddrMasks, kn) {
						currentKey = ffj_t_IcmpStatistics_InAddrMasks
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_IcmpStatistics_InAddrMaskReps, kn) {
						currentKey = ffj_t_IcmpStatistics_InAddrMaskReps
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'O':

					if bytes.Equal(ffj_key_IcmpStatistics_OutMsgs, kn) {
						currentKey = ffj_t_IcmpStatistics_OutMsgs
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_IcmpStatistics_OutErrors, kn) {
						currentKey = ffj_t_IcmpStatistics_OutErrors
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_IcmpStatistics_OutDestUnreachs, kn) {
						currentKey = ffj_t_IcmpStatistics_OutDestUnreachs
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_IcmpStatistics_OutTimeExcds, kn) {
						currentKey = ffj_t_IcmpStatistics_OutTimeExcds
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_IcmpStatistics_OutParmProbs, kn) {
						currentKey = ffj_t_IcmpStatistics_OutParmProbs
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_IcmpStatistics_OutSrcQuenchs, kn) {
						currentKey = ffj_t_IcmpStatistics_OutSrcQuenchs
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_IcmpStatistics_OutRedirects, kn) {
						currentKey = ffj_t_IcmpStatistics_OutRedirects
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_IcmpStatistics_OutEchos, kn) {
						currentKey = ffj_t_IcmpStatistics_OutEchos
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_IcmpStatistics_OutEchoReps, kn) {
						currentKey = ffj_t_IcmpStatistics_OutEchoReps
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_IcmpStatistics_OutTimestamps, kn) {
						currentKey = ffj_t_IcmpStatistics_OutTimestamps
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_IcmpStatistics_OutTimestampReps, kn) {
						currentKey = ffj_t_IcmpStatistics_OutTimestampReps
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_IcmpStatistics_OutAddrMasks, kn) {
						currentKey = ffj_t_IcmpStatistics_OutAddrMasks
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_IcmpStatistics_OutAddrMaskReps, kn) {
						currentKey = ffj_t_IcmpStatistics_OutAddrMaskReps
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_IcmpStatistics_OutAddrMaskReps, kn) {
					currentKey = ffj_t_IcmpStatistics_OutAddrMaskReps
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_IcmpStatistics_OutAddrMasks, kn) {
					currentKey = ffj_t_IcmpStatistics_OutAddrMasks
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_IcmpStatistics_OutTimestampReps, kn) {
					currentKey = ffj_t_IcmpStatistics_OutTimestampReps
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_IcmpStatistics_OutTimestamps, kn) {
					currentKey = ffj_t_IcmpStatistics_OutTimestamps
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_IcmpStatistics_OutEchoReps, kn) {
					currentKey = ffj_t_IcmpStatistics_OutEchoReps
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_IcmpStatistics_OutEchos, kn) {
					currentKey = ffj_t_IcmpStatistics_OutEchos
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_IcmpStatistics_OutRedirects, kn) {
					currentKey = ffj_t_IcmpStatistics_OutRedirects
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_IcmpStatistics_OutSrcQuenchs, kn) {
					currentKey = ffj_t_IcmpStatistics_OutSrcQuenchs
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_IcmpStatistics_OutParmProbs, kn) {
					currentKey = ffj_t_IcmpStatistics_OutParmProbs
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_IcmpStatistics_OutTimeExcds, kn) {
					currentKey = ffj_t_IcmpStatistics_OutTimeExcds
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_IcmpStatistics_OutDestUnreachs, kn) {
					currentKey = ffj_t_IcmpStatistics_OutDestUnreachs
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_IcmpStatistics_OutErrors, kn) {
					currentKey = ffj_t_IcmpStatistics_OutErrors
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_IcmpStatistics_OutMsgs, kn) {
					currentKey = ffj_t_IcmpStatistics_OutMsgs
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_IcmpStatistics_InAddrMaskReps, kn) {
					currentKey = ffj_t_IcmpStatistics_InAddrMaskReps
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_IcmpStatistics_InAddrMasks, kn) {
					currentKey = ffj_t_IcmpStatistics_InAddrMasks
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_IcmpStatistics_InTimestampReps, kn) {
					currentKey = ffj_t_IcmpStatistics_InTimestampReps
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_IcmpStatistics_InTimestamps, kn) {
					currentKey = ffj_t_IcmpStatistics_InTimestamps
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_IcmpStatistics_InEchoReps, kn) {
					currentKey = ffj_t_IcmpStatistics_InEchoReps
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_IcmpStatistics_InEchos, kn) {
					currentKey = ffj_t_IcmpStatistics_InEchos
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_IcmpStatistics_InRedirects, kn) {
					currentKey = ffj_t_IcmpStatistics_InRedirects
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_IcmpStatistics_InSrcQuenchs, kn) {
					currentKey = ffj_t_IcmpStatistics_InSrcQuenchs
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_IcmpStatistics_InParmProbs, kn) {
					currentKey = ffj_t_IcmpStatistics_InParmProbs
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_IcmpStatistics_InTimeExcds, kn) {
					currentKey = ffj_t_IcmpStatistics_InTimeExcds
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_IcmpStatistics_InDestUnreachs, kn) {
					currentKey = ffj_t_IcmpStatistics_InDestUnreachs
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_IcmpStatistics_InCsumErrors, kn) {
					currentKey = ffj_t_IcmpStatistics_InCsumErrors
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_IcmpStatistics_InErrors, kn) {
					currentKey = ffj_t_IcmpStatistics_InErrors
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_IcmpStatistics_InMsgs, kn) {
					currentKey = ffj_t_IcmpStatistics_InMsgs
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_IcmpStatisticsno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_IcmpStatistics_InMsgs:
					goto handle_InMsgs

				case ffj_t_IcmpStatistics_InErrors:
					goto handle_InErrors

				case ffj_t_IcmpStatistics_InCsumErrors:
					goto handle_InCsumErrors

				case ffj_t_IcmpStatistics_InDestUnreachs:
					goto handle_InDestUnreachs

				case ffj_t_IcmpStatistics_InTimeExcds:
					goto handle_InTimeExcds

				case ffj_t_IcmpStatistics_InParmProbs:
					goto handle_InParmProbs

				case ffj_t_IcmpStatistics_InSrcQuenchs:
					goto handle_InSrcQuenchs

				case ffj_t_IcmpStatistics_InRedirects:
					goto handle_InRedirects

				case ffj_t_IcmpStatistics_InEchos:
					goto handle_InEchos

				case ffj_t_IcmpStatistics_InEchoReps:
					goto handle_InEchoReps

				case ffj_t_IcmpStatistics_InTimestamps:
					goto handle_InTimestamps

				case ffj_t_IcmpStatistics_InTimestampReps:
					goto handle_InTimestampReps

				case ffj_t_IcmpStatistics_InAddrMasks:
					goto handle_InAddrMasks

				case ffj_t_IcmpStatistics_InAddrMaskReps:
					goto handle_InAddrMaskReps

				case ffj_t_IcmpStatistics_OutMsgs:
					goto handle_OutMsgs

				case ffj_t_IcmpStatistics_OutErrors:
					goto handle_OutErrors

				case ffj_t_IcmpStatistics_OutDestUnreachs:
					goto handle_OutDestUnreachs

				case ffj_t_IcmpStatistics_OutTimeExcds:
					goto handle_OutTimeExcds

				case ffj_t_IcmpStatistics_OutParmProbs:
					goto handle_OutParmProbs

				case ffj_t_IcmpStatistics_OutSrcQuenchs:
					goto handle_OutSrcQuenchs

				case ffj_t_IcmpStatistics_OutRedirects:
					goto handle_OutRedirects

				case ffj_t_IcmpStatistics_OutEchos:
					goto handle_OutEchos

				case ffj_t_IcmpStatistics_OutEchoReps:
					goto handle_OutEchoReps

				case ffj_t_IcmpStatistics_OutTimestamps:
					goto handle_OutTimestamps

				case ffj_t_IcmpStatistics_OutTimestampReps:
					goto handle_OutTimestampReps

				case ffj_t_IcmpStatistics_OutAddrMasks:
					goto handle_OutAddrMasks

				case ffj_t_IcmpStatistics_OutAddrMaskReps:
					goto handle_OutAddrMaskReps

				case ffj_t_IcmpStatisticsno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_InMsgs:

	/* handler: uj.InMsgs type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.InMsgs = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			uj.InMsgs = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InErrors:

	/* handler: uj.InErrors type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.InErrors = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			uj.InErrors = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InCsumErrors:

	/* handler: uj.InCsumErrors type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.InCsumErrors = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			uj.InCsumErrors = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InDestUnreachs:

	/* handler: uj.InDestUnreachs type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.InDestUnreachs = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			uj.InDestUnreachs = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InTimeExcds:

	/* handler: uj.InTimeExcds type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.InTimeExcds = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			uj.InTimeExcds = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InParmProbs:

	/* handler: uj.InParmProbs type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.InParmProbs = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			uj.InParmProbs = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InSrcQuenchs:

	/* handler: uj.InSrcQuenchs type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.InSrcQuenchs = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			uj.InSrcQuenchs = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InRedirects:

	/* handler: uj.InRedirects type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.InRedirects = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			uj.InRedirects = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InEchos:

	/* handler: uj.InEchos type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.InEchos = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			uj.InEchos = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InEchoReps:

	/* handler: uj.InEchoReps type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.InEchoReps = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			uj.InEchoReps = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InTimestamps:

	/* handler: uj.InTimestamps type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.InTimestamps = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			uj.InTimestamps = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InTimestampReps:

	/* handler: uj.InTimestampReps type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.InTimestampReps = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			uj.InTimestampReps = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InAddrMasks:

	/* handler: uj.InAddrMasks type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.InAddrMasks = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			uj.InAddrMasks = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InAddrMaskReps:

	/* handler: uj.InAddrMaskReps type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.InAddrMaskReps = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			uj.InAddrMaskReps = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_OutMsgs:

	/* handler: uj.OutMsgs type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.OutMsgs = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			uj.OutMsgs = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_OutErrors:

	/* handler: uj.OutErrors type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.OutErrors = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			uj.OutErrors = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_OutDestUnreachs:

	/* handler: uj.OutDestUnreachs type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.OutDestUnreachs = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			uj.OutDestUnreachs = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_OutTimeExcds:

	/* handler: uj.OutTimeExcds type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.OutTimeExcds = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			uj.OutTimeExcds = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_OutParmProbs:

	/* handler: uj.OutParmProbs type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.OutParmProbs = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			uj.OutParmProbs = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_OutSrcQuenchs:

	/* handler: uj.OutSrcQuenchs type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.OutSrcQuenchs = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			uj.OutSrcQuenchs = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_OutRedirects:

	/* handler: uj.OutRedirects type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.OutRedirects = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			uj.OutRedirects = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_OutEchos:

	/* handler: uj.OutEchos type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.OutEchos = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			uj.OutEchos = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_OutEchoReps:

	/* handler: uj.OutEchoReps type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.OutEchoReps = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			uj.OutEchoReps = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_OutTimestamps:

	/* handler: uj.OutTimestamps type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.OutTimestamps = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			uj.OutTimestamps = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_OutTimestampReps:

	/* handler: uj.OutTimestampReps type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.OutTimestampReps = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			uj.OutTimestampReps = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_OutAddrMasks:

	/* handler: uj.OutAddrMasks type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.OutAddrMasks = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			uj.OutAddrMasks = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_OutAddrMaskReps:

	/* handler: uj.OutAddrMaskReps type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.OutAddrMaskReps = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			uj.OutAddrMaskReps = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Image) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Image) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.Type != nil {
		if true {
			buf.WriteString(`"type":`)

			{

				obj, err = mj.Type.MarshalJSON()
				if err != nil {
					return err
				}
				buf.Write(obj)

			}
			buf.WriteByte(',')
		}
	}
	if mj.Appc != nil {
		if true {
			buf.WriteString(`"appc":`)

			{

				err = mj.Appc.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.Docker != nil {
		if true {
			buf.WriteString(`"docker":`)

			{

				err = mj.Docker.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Imagebase = iota
	ffj_t_Imageno_such_key

	ffj_t_Image_Type

	ffj_t_Image_Appc

	ffj_t_Image_Docker
)

var ffj_key_Image_Type = []byte("type")

var ffj_key_Image_Appc = []byte("appc")

var ffj_key_Image_Docker = []byte("docker")

func (uj *Image) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Image) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Imagebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Imageno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_Image_Appc, kn) {
						currentKey = ffj_t_Image_Appc
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffj_key_Image_Docker, kn) {
						currentKey = ffj_t_Image_Docker
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_Image_Type, kn) {
						currentKey = ffj_t_Image_Type
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_Image_Docker, kn) {
					currentKey = ffj_t_Image_Docker
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Image_Appc, kn) {
					currentKey = ffj_t_Image_Appc
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Image_Type, kn) {
					currentKey = ffj_t_Image_Type
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Imageno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Image_Type:
					goto handle_Type

				case ffj_t_Image_Appc:
					goto handle_Appc

				case ffj_t_Image_Docker:
					goto handle_Docker

				case ffj_t_Imageno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Type:

	/* handler: uj.Type type=mesos.Image_Type kind=int32 quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Type = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		if uj.Type == nil {
			uj.Type = new(Image_Type)
		}

		err = uj.Type.UnmarshalJSON(tbuf)
		if err != nil {
			return fs.WrapErr(err)
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Appc:

	/* handler: uj.Appc type=mesos.Image_Appc kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Appc = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Appc == nil {
			uj.Appc = new(Image_Appc)
		}

		err = uj.Appc.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Docker:

	/* handler: uj.Docker type=mesos.Image_Docker kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Docker = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Docker == nil {
			uj.Docker = new(Image_Docker)
		}

		err = uj.Docker.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Image_Appc) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Image_Appc) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "name":`)
	fflib.WriteJsonString(buf, string(mj.Name))
	buf.WriteByte(',')
	if mj.ID != nil {
		if true {
			buf.WriteString(`"id":`)
			fflib.WriteJsonString(buf, string(*mj.ID))
			buf.WriteByte(',')
		}
	}
	if mj.Labels != nil {
		if true {
			buf.WriteString(`"labels":`)

			{

				err = mj.Labels.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Image_Appcbase = iota
	ffj_t_Image_Appcno_such_key

	ffj_t_Image_Appc_Name

	ffj_t_Image_Appc_ID

	ffj_t_Image_Appc_Labels
)

var ffj_key_Image_Appc_Name = []byte("name")

var ffj_key_Image_Appc_ID = []byte("id")

var ffj_key_Image_Appc_Labels = []byte("labels")

func (uj *Image_Appc) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Image_Appc) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Image_Appcbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Image_Appcno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'i':

					if bytes.Equal(ffj_key_Image_Appc_ID, kn) {
						currentKey = ffj_t_Image_Appc_ID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffj_key_Image_Appc_Labels, kn) {
						currentKey = ffj_t_Image_Appc_Labels
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffj_key_Image_Appc_Name, kn) {
						currentKey = ffj_t_Image_Appc_Name
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_Image_Appc_Labels, kn) {
					currentKey = ffj_t_Image_Appc_Labels
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Image_Appc_ID, kn) {
					currentKey = ffj_t_Image_Appc_ID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Image_Appc_Name, kn) {
					currentKey = ffj_t_Image_Appc_Name
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Image_Appcno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Image_Appc_Name:
					goto handle_Name

				case ffj_t_Image_Appc_ID:
					goto handle_ID

				case ffj_t_Image_Appc_Labels:
					goto handle_Labels

				case ffj_t_Image_Appcno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Name:

	/* handler: uj.Name type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Name = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ID:

	/* handler: uj.ID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.ID = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.ID = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Labels:

	/* handler: uj.Labels type=mesos.Labels kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Labels = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Labels == nil {
			uj.Labels = new(Labels)
		}

		err = uj.Labels.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Image_Docker) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Image_Docker) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "name":`)
	fflib.WriteJsonString(buf, string(mj.Name))
	buf.WriteByte(',')
	if mj.Credential != nil {
		if true {
			buf.WriteString(`"credential":`)

			{

				err = mj.Credential.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Image_Dockerbase = iota
	ffj_t_Image_Dockerno_such_key

	ffj_t_Image_Docker_Name

	ffj_t_Image_Docker_Credential
)

var ffj_key_Image_Docker_Name = []byte("name")

var ffj_key_Image_Docker_Credential = []byte("credential")

func (uj *Image_Docker) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Image_Docker) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Image_Dockerbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Image_Dockerno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_Image_Docker_Credential, kn) {
						currentKey = ffj_t_Image_Docker_Credential
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffj_key_Image_Docker_Name, kn) {
						currentKey = ffj_t_Image_Docker_Name
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_Image_Docker_Credential, kn) {
					currentKey = ffj_t_Image_Docker_Credential
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Image_Docker_Name, kn) {
					currentKey = ffj_t_Image_Docker_Name
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Image_Dockerno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Image_Docker_Name:
					goto handle_Name

				case ffj_t_Image_Docker_Credential:
					goto handle_Credential

				case ffj_t_Image_Dockerno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Name:

	/* handler: uj.Name type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Name = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Credential:

	/* handler: uj.Credential type=mesos.Credential kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Credential = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Credential == nil {
			uj.Credential = new(Credential)
		}

		err = uj.Credential.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *InverseOffer) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *InverseOffer) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"id":`)

	{

		err = mj.OfferID.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte(',')
	if mj.Url != nil {
		if true {
			buf.WriteString(`"url":`)

			{

				err = mj.Url.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.WriteString(`"framework_id":`)

	{

		err = mj.FrameworkID.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte(',')
	if mj.AgentID != nil {
		if true {
			buf.WriteString(`"agent_id":`)

			{

				err = mj.AgentID.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.WriteString(`"unavailability":`)

	{

		err = mj.Unavailability.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteString(`,"resources":`)
	if mj.Resources != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Resources {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_InverseOfferbase = iota
	ffj_t_InverseOfferno_such_key

	ffj_t_InverseOffer_OfferID

	ffj_t_InverseOffer_Url

	ffj_t_InverseOffer_FrameworkID

	ffj_t_InverseOffer_AgentID

	ffj_t_InverseOffer_Unavailability

	ffj_t_InverseOffer_Resources
)

var ffj_key_InverseOffer_OfferID = []byte("id")

var ffj_key_InverseOffer_Url = []byte("url")

var ffj_key_InverseOffer_FrameworkID = []byte("framework_id")

var ffj_key_InverseOffer_AgentID = []byte("agent_id")

var ffj_key_InverseOffer_Unavailability = []byte("unavailability")

var ffj_key_InverseOffer_Resources = []byte("resources")

func (uj *InverseOffer) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *InverseOffer) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_InverseOfferbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_InverseOfferno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_InverseOffer_AgentID, kn) {
						currentKey = ffj_t_InverseOffer_AgentID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffj_key_InverseOffer_FrameworkID, kn) {
						currentKey = ffj_t_InverseOffer_FrameworkID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_InverseOffer_OfferID, kn) {
						currentKey = ffj_t_InverseOffer_OfferID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_InverseOffer_Resources, kn) {
						currentKey = ffj_t_InverseOffer_Resources
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffj_key_InverseOffer_Url, kn) {
						currentKey = ffj_t_InverseOffer_Url
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_InverseOffer_Unavailability, kn) {
						currentKey = ffj_t_InverseOffer_Unavailability
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_InverseOffer_Resources, kn) {
					currentKey = ffj_t_InverseOffer_Resources
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_InverseOffer_Unavailability, kn) {
					currentKey = ffj_t_InverseOffer_Unavailability
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_InverseOffer_AgentID, kn) {
					currentKey = ffj_t_InverseOffer_AgentID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_InverseOffer_FrameworkID, kn) {
					currentKey = ffj_t_InverseOffer_FrameworkID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_InverseOffer_Url, kn) {
					currentKey = ffj_t_InverseOffer_Url
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_InverseOffer_OfferID, kn) {
					currentKey = ffj_t_InverseOffer_OfferID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_InverseOfferno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_InverseOffer_OfferID:
					goto handle_OfferID

				case ffj_t_InverseOffer_Url:
					goto handle_Url

				case ffj_t_InverseOffer_FrameworkID:
					goto handle_FrameworkID

				case ffj_t_InverseOffer_AgentID:
					goto handle_AgentID

				case ffj_t_InverseOffer_Unavailability:
					goto handle_Unavailability

				case ffj_t_InverseOffer_Resources:
					goto handle_Resources

				case ffj_t_InverseOfferno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_OfferID:

	/* handler: uj.OfferID type=mesos.OfferID kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.OfferID.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Url:

	/* handler: uj.Url type=mesos.URL kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Url = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Url == nil {
			uj.Url = new(URL)
		}

		err = uj.Url.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FrameworkID:

	/* handler: uj.FrameworkID type=mesos.FrameworkID kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.FrameworkID.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AgentID:

	/* handler: uj.AgentID type=mesos.AgentID kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.AgentID = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.AgentID == nil {
			uj.AgentID = new(AgentID)
		}

		err = uj.AgentID.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Unavailability:

	/* handler: uj.Unavailability type=mesos.Unavailability kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.Unavailability.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Resources:

	/* handler: uj.Resources type=[]mesos.Resource kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Resources = nil
		} else {

			uj.Resources = make([]Resource, 0)

			wantVal := true

			for {

				var v Resource

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=mesos.Resource kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Resources = append(uj.Resources, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *IpStatistics) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *IpStatistics) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.Forwarding != nil {
		if true {
			buf.WriteString(`"Forwarding":`)
			fflib.FormatBits2(buf, uint64(*mj.Forwarding), 10, *mj.Forwarding < 0)
			buf.WriteByte(',')
		}
	}
	if mj.DefaultTTL != nil {
		if true {
			buf.WriteString(`"DefaultTTL":`)
			fflib.FormatBits2(buf, uint64(*mj.DefaultTTL), 10, *mj.DefaultTTL < 0)
			buf.WriteByte(',')
		}
	}
	if mj.InReceives != nil {
		if true {
			buf.WriteString(`"InReceives":`)
			fflib.FormatBits2(buf, uint64(*mj.InReceives), 10, *mj.InReceives < 0)
			buf.WriteByte(',')
		}
	}
	if mj.InHdrErrors != nil {
		if true {
			buf.WriteString(`"InHdrErrors":`)
			fflib.FormatBits2(buf, uint64(*mj.InHdrErrors), 10, *mj.InHdrErrors < 0)
			buf.WriteByte(',')
		}
	}
	if mj.InAddrErrors != nil {
		if true {
			buf.WriteString(`"InAddrErrors":`)
			fflib.FormatBits2(buf, uint64(*mj.InAddrErrors), 10, *mj.InAddrErrors < 0)
			buf.WriteByte(',')
		}
	}
	if mj.ForwDatagrams != nil {
		if true {
			buf.WriteString(`"ForwDatagrams":`)
			fflib.FormatBits2(buf, uint64(*mj.ForwDatagrams), 10, *mj.ForwDatagrams < 0)
			buf.WriteByte(',')
		}
	}
	if mj.InUnknownProtos != nil {
		if true {
			buf.WriteString(`"InUnknownProtos":`)
			fflib.FormatBits2(buf, uint64(*mj.InUnknownProtos), 10, *mj.InUnknownProtos < 0)
			buf.WriteByte(',')
		}
	}
	if mj.InDiscards != nil {
		if true {
			buf.WriteString(`"InDiscards":`)
			fflib.FormatBits2(buf, uint64(*mj.InDiscards), 10, *mj.InDiscards < 0)
			buf.WriteByte(',')
		}
	}
	if mj.InDelivers != nil {
		if true {
			buf.WriteString(`"InDelivers":`)
			fflib.FormatBits2(buf, uint64(*mj.InDelivers), 10, *mj.InDelivers < 0)
			buf.WriteByte(',')
		}
	}
	if mj.OutRequests != nil {
		if true {
			buf.WriteString(`"OutRequests":`)
			fflib.FormatBits2(buf, uint64(*mj.OutRequests), 10, *mj.OutRequests < 0)
			buf.WriteByte(',')
		}
	}
	if mj.OutDiscards != nil {
		if true {
			buf.WriteString(`"OutDiscards":`)
			fflib.FormatBits2(buf, uint64(*mj.OutDiscards), 10, *mj.OutDiscards < 0)
			buf.WriteByte(',')
		}
	}
	if mj.OutNoRoutes != nil {
		if true {
			buf.WriteString(`"OutNoRoutes":`)
			fflib.FormatBits2(buf, uint64(*mj.OutNoRoutes), 10, *mj.OutNoRoutes < 0)
			buf.WriteByte(',')
		}
	}
	if mj.ReasmTimeout != nil {
		if true {
			buf.WriteString(`"ReasmTimeout":`)
			fflib.FormatBits2(buf, uint64(*mj.ReasmTimeout), 10, *mj.ReasmTimeout < 0)
			buf.WriteByte(',')
		}
	}
	if mj.ReasmReqds != nil {
		if true {
			buf.WriteString(`"ReasmReqds":`)
			fflib.FormatBits2(buf, uint64(*mj.ReasmReqds), 10, *mj.ReasmReqds < 0)
			buf.WriteByte(',')
		}
	}
	if mj.ReasmOKs != nil {
		if true {
			buf.WriteString(`"ReasmOKs":`)
			fflib.FormatBits2(buf, uint64(*mj.ReasmOKs), 10, *mj.ReasmOKs < 0)
			buf.WriteByte(',')
		}
	}
	if mj.ReasmFails != nil {
		if true {
			buf.WriteString(`"ReasmFails":`)
			fflib.FormatBits2(buf, uint64(*mj.ReasmFails), 10, *mj.ReasmFails < 0)
			buf.WriteByte(',')
		}
	}
	if mj.FragOKs != nil {
		if true {
			buf.WriteString(`"FragOKs":`)
			fflib.FormatBits2(buf, uint64(*mj.FragOKs), 10, *mj.FragOKs < 0)
			buf.WriteByte(',')
		}
	}
	if mj.FragFails != nil {
		if true {
			buf.WriteString(`"FragFails":`)
			fflib.FormatBits2(buf, uint64(*mj.FragFails), 10, *mj.FragFails < 0)
			buf.WriteByte(',')
		}
	}
	if mj.FragCreates != nil {
		if true {
			buf.WriteString(`"FragCreates":`)
			fflib.FormatBits2(buf, uint64(*mj.FragCreates), 10, *mj.FragCreates < 0)
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_IpStatisticsbase = iota
	ffj_t_IpStatisticsno_such_key

	ffj_t_IpStatistics_Forwarding

	ffj_t_IpStatistics_DefaultTTL

	ffj_t_IpStatistics_InReceives

	ffj_t_IpStatistics_InHdrErrors

	ffj_t_IpStatistics_InAddrErrors

	ffj_t_IpStatistics_ForwDatagrams

	ffj_t_IpStatistics_InUnknownProtos

	ffj_t_IpStatistics_InDiscards

	ffj_t_IpStatistics_InDelivers

	ffj_t_IpStatistics_OutRequests

	ffj_t_IpStatistics_OutDiscards

	ffj_t_IpStatistics_OutNoRoutes

	ffj_t_IpStatistics_ReasmTimeout

	ffj_t_IpStatistics_ReasmReqds

	ffj_t_IpStatistics_ReasmOKs

	ffj_t_IpStatistics_ReasmFails

	ffj_t_IpStatistics_FragOKs

	ffj_t_IpStatistics_FragFails

	ffj_t_IpStatistics_FragCreates
)

var ffj_key_IpStatistics_Forwarding = []byte("Forwarding")

var ffj_key_IpStatistics_DefaultTTL = []byte("DefaultTTL")

var ffj_key_IpStatistics_InReceives = []byte("InReceives")

var ffj_key_IpStatistics_InHdrErrors = []byte("InHdrErrors")

var ffj_key_IpStatistics_InAddrErrors = []byte("InAddrErrors")

var ffj_key_IpStatistics_ForwDatagrams = []byte("ForwDatagrams")

var ffj_key_IpStatistics_InUnknownProtos = []byte("InUnknownProtos")

var ffj_key_IpStatistics_InDiscards = []byte("InDiscards")

var ffj_key_IpStatistics_InDelivers = []byte("InDelivers")

var ffj_key_IpStatistics_OutRequests = []byte("OutRequests")

var ffj_key_IpStatistics_OutDiscards = []byte("OutDiscards")

var ffj_key_IpStatistics_OutNoRoutes = []byte("OutNoRoutes")

var ffj_key_IpStatistics_ReasmTimeout = []byte("ReasmTimeout")

var ffj_key_IpStatistics_ReasmReqds = []byte("ReasmReqds")

var ffj_key_IpStatistics_ReasmOKs = []byte("ReasmOKs")

var ffj_key_IpStatistics_ReasmFails = []byte("ReasmFails")

var ffj_key_IpStatistics_FragOKs = []byte("FragOKs")

var ffj_key_IpStatistics_FragFails = []byte("FragFails")

var ffj_key_IpStatistics_FragCreates = []byte("FragCreates")

func (uj *IpStatistics) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *IpStatistics) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_IpStatisticsbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_IpStatisticsno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'D':

					if bytes.Equal(ffj_key_IpStatistics_DefaultTTL, kn) {
						currentKey = ffj_t_IpStatistics_DefaultTTL
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'F':

					if bytes.Equal(ffj_key_IpStatistics_Forwarding, kn) {
						currentKey = ffj_t_IpStatistics_Forwarding
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_IpStatistics_ForwDatagrams, kn) {
						currentKey = ffj_t_IpStatistics_ForwDatagrams
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_IpStatistics_FragOKs, kn) {
						currentKey = ffj_t_IpStatistics_FragOKs
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_IpStatistics_FragFails, kn) {
						currentKey = ffj_t_IpStatistics_FragFails
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_IpStatistics_FragCreates, kn) {
						currentKey = ffj_t_IpStatistics_FragCreates
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'I':

					if bytes.Equal(ffj_key_IpStatistics_InReceives, kn) {
						currentKey = ffj_t_IpStatistics_InReceives
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_IpStatistics_InHdrErrors, kn) {
						currentKey = ffj_t_IpStatistics_InHdrErrors
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_IpStatistics_InAddrErrors, kn) {
						currentKey = ffj_t_IpStatistics_InAddrErrors
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_IpStatistics_InUnknownProtos, kn) {
						currentKey = ffj_t_IpStatistics_InUnknownProtos
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_IpStatistics_InDiscards, kn) {
						currentKey = ffj_t_IpStatistics_InDiscards
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_IpStatistics_InDelivers, kn) {
						currentKey = ffj_t_IpStatistics_InDelivers
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'O':

					if bytes.Equal(ffj_key_IpStatistics_OutRequests, kn) {
						currentKey = ffj_t_IpStatistics_OutRequests
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_IpStatistics_OutDiscards, kn) {
						currentKey = ffj_t_IpStatistics_OutDiscards
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_IpStatistics_OutNoRoutes, kn) {
						currentKey = ffj_t_IpStatistics_OutNoRoutes
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'R':

					if bytes.Equal(ffj_key_IpStatistics_ReasmTimeout, kn) {
						currentKey = ffj_t_IpStatistics_ReasmTimeout
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_IpStatistics_ReasmReqds, kn) {
						currentKey = ffj_t_IpStatistics_ReasmReqds
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_IpStatistics_ReasmOKs, kn) {
						currentKey = ffj_t_IpStatistics_ReasmOKs
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_IpStatistics_ReasmFails, kn) {
						currentKey = ffj_t_IpStatistics_ReasmFails
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_IpStatistics_FragCreates, kn) {
					currentKey = ffj_t_IpStatistics_FragCreates
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_IpStatistics_FragFails, kn) {
					currentKey = ffj_t_IpStatistics_FragFails
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_IpStatistics_FragOKs, kn) {
					currentKey = ffj_t_IpStatistics_FragOKs
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_IpStatistics_ReasmFails, kn) {
					currentKey = ffj_t_IpStatistics_ReasmFails
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_IpStatistics_ReasmOKs, kn) {
					currentKey = ffj_t_IpStatistics_ReasmOKs
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_IpStatistics_ReasmReqds, kn) {
					currentKey = ffj_t_IpStatistics_ReasmReqds
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_IpStatistics_ReasmTimeout, kn) {
					currentKey = ffj_t_IpStatistics_ReasmTimeout
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_IpStatistics_OutNoRoutes, kn) {
					currentKey = ffj_t_IpStatistics_OutNoRoutes
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_IpStatistics_OutDiscards, kn) {
					currentKey = ffj_t_IpStatistics_OutDiscards
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_IpStatistics_OutRequests, kn) {
					currentKey = ffj_t_IpStatistics_OutRequests
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_IpStatistics_InDelivers, kn) {
					currentKey = ffj_t_IpStatistics_InDelivers
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_IpStatistics_InDiscards, kn) {
					currentKey = ffj_t_IpStatistics_InDiscards
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_IpStatistics_InUnknownProtos, kn) {
					currentKey = ffj_t_IpStatistics_InUnknownProtos
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_IpStatistics_ForwDatagrams, kn) {
					currentKey = ffj_t_IpStatistics_ForwDatagrams
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_IpStatistics_InAddrErrors, kn) {
					currentKey = ffj_t_IpStatistics_InAddrErrors
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_IpStatistics_InHdrErrors, kn) {
					currentKey = ffj_t_IpStatistics_InHdrErrors
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_IpStatistics_InReceives, kn) {
					currentKey = ffj_t_IpStatistics_InReceives
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_IpStatistics_DefaultTTL, kn) {
					currentKey = ffj_t_IpStatistics_DefaultTTL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_IpStatistics_Forwarding, kn) {
					currentKey = ffj_t_IpStatistics_Forwarding
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_IpStatisticsno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_IpStatistics_Forwarding:
					goto handle_Forwarding

				case ffj_t_IpStatistics_DefaultTTL:
					goto handle_DefaultTTL

				case ffj_t_IpStatistics_InReceives:
					goto handle_InReceives

				case ffj_t_IpStatistics_InHdrErrors:
					goto handle_InHdrErrors

				case ffj_t_IpStatistics_InAddrErrors:
					goto handle_InAddrErrors

				case ffj_t_IpStatistics_ForwDatagrams:
					goto handle_ForwDatagrams

				case ffj_t_IpStatistics_InUnknownProtos:
					goto handle_InUnknownProtos

				case ffj_t_IpStatistics_InDiscards:
					goto handle_InDiscards

				case ffj_t_IpStatistics_InDelivers:
					goto handle_InDelivers

				case ffj_t_IpStatistics_OutRequests:
					goto handle_OutRequests

				case ffj_t_IpStatistics_OutDiscards:
					goto handle_OutDiscards

				case ffj_t_IpStatistics_OutNoRoutes:
					goto handle_OutNoRoutes

				case ffj_t_IpStatistics_ReasmTimeout:
					goto handle_ReasmTimeout

				case ffj_t_IpStatistics_ReasmReqds:
					goto handle_ReasmReqds

				case ffj_t_IpStatistics_ReasmOKs:
					goto handle_ReasmOKs

				case ffj_t_IpStatistics_ReasmFails:
					goto handle_ReasmFails

				case ffj_t_IpStatistics_FragOKs:
					goto handle_FragOKs

				case ffj_t_IpStatistics_FragFails:
					goto handle_FragFails

				case ffj_t_IpStatistics_FragCreates:
					goto handle_FragCreates

				case ffj_t_IpStatisticsno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Forwarding:

	/* handler: uj.Forwarding type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Forwarding = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			uj.Forwarding = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DefaultTTL:

	/* handler: uj.DefaultTTL type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.DefaultTTL = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			uj.DefaultTTL = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InReceives:

	/* handler: uj.InReceives type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.InReceives = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			uj.InReceives = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InHdrErrors:

	/* handler: uj.InHdrErrors type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.InHdrErrors = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			uj.InHdrErrors = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InAddrErrors:

	/* handler: uj.InAddrErrors type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.InAddrErrors = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			uj.InAddrErrors = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ForwDatagrams:

	/* handler: uj.ForwDatagrams type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.ForwDatagrams = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			uj.ForwDatagrams = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InUnknownProtos:

	/* handler: uj.InUnknownProtos type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.InUnknownProtos = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			uj.InUnknownProtos = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InDiscards:

	/* handler: uj.InDiscards type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.InDiscards = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			uj.InDiscards = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InDelivers:

	/* handler: uj.InDelivers type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.InDelivers = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			uj.InDelivers = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_OutRequests:

	/* handler: uj.OutRequests type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.OutRequests = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			uj.OutRequests = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_OutDiscards:

	/* handler: uj.OutDiscards type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.OutDiscards = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			uj.OutDiscards = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_OutNoRoutes:

	/* handler: uj.OutNoRoutes type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.OutNoRoutes = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			uj.OutNoRoutes = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReasmTimeout:

	/* handler: uj.ReasmTimeout type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.ReasmTimeout = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			uj.ReasmTimeout = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReasmReqds:

	/* handler: uj.ReasmReqds type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.ReasmReqds = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			uj.ReasmReqds = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReasmOKs:

	/* handler: uj.ReasmOKs type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.ReasmOKs = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			uj.ReasmOKs = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReasmFails:

	/* handler: uj.ReasmFails type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.ReasmFails = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			uj.ReasmFails = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FragOKs:

	/* handler: uj.FragOKs type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.FragOKs = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			uj.FragOKs = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FragFails:

	/* handler: uj.FragFails type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.FragFails = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			uj.FragFails = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FragCreates:

	/* handler: uj.FragCreates type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.FragCreates = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			uj.FragCreates = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Label) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Label) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "key":`)
	fflib.WriteJsonString(buf, string(mj.Key))
	buf.WriteByte(',')
	if mj.Value != nil {
		if true {
			buf.WriteString(`"value":`)
			fflib.WriteJsonString(buf, string(*mj.Value))
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Labelbase = iota
	ffj_t_Labelno_such_key

	ffj_t_Label_Key

	ffj_t_Label_Value
)

var ffj_key_Label_Key = []byte("key")

var ffj_key_Label_Value = []byte("value")

func (uj *Label) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Label) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Labelbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Labelno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'k':

					if bytes.Equal(ffj_key_Label_Key, kn) {
						currentKey = ffj_t_Label_Key
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'v':

					if bytes.Equal(ffj_key_Label_Value, kn) {
						currentKey = ffj_t_Label_Value
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_Label_Value, kn) {
					currentKey = ffj_t_Label_Value
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Label_Key, kn) {
					currentKey = ffj_t_Label_Key
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Labelno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Label_Key:
					goto handle_Key

				case ffj_t_Label_Value:
					goto handle_Value

				case ffj_t_Labelno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Key:

	/* handler: uj.Key type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Key = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Value:

	/* handler: uj.Value type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Value = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Value = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Labels) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Labels) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"labels":`)
	if mj.Labels != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Labels {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Labelsbase = iota
	ffj_t_Labelsno_such_key

	ffj_t_Labels_Labels
)

var ffj_key_Labels_Labels = []byte("labels")

func (uj *Labels) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Labels) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Labelsbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Labelsno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'l':

					if bytes.Equal(ffj_key_Labels_Labels, kn) {
						currentKey = ffj_t_Labels_Labels
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_Labels_Labels, kn) {
					currentKey = ffj_t_Labels_Labels
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Labelsno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Labels_Labels:
					goto handle_Labels

				case ffj_t_Labelsno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Labels:

	/* handler: uj.Labels type=[]mesos.Label kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Labels = nil
		} else {

			uj.Labels = make([]Label, 0)

			wantVal := true

			for {

				var v Label

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=mesos.Label kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Labels = append(uj.Labels, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *MachineID) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *MachineID) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.Hostname != nil {
		if true {
			buf.WriteString(`"hostname":`)
			fflib.WriteJsonString(buf, string(*mj.Hostname))
			buf.WriteByte(',')
		}
	}
	if mj.Ip != nil {
		if true {
			buf.WriteString(`"ip":`)
			fflib.WriteJsonString(buf, string(*mj.Ip))
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_MachineIDbase = iota
	ffj_t_MachineIDno_such_key

	ffj_t_MachineID_Hostname

	ffj_t_MachineID_Ip
)

var ffj_key_MachineID_Hostname = []byte("hostname")

var ffj_key_MachineID_Ip = []byte("ip")

func (uj *MachineID) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *MachineID) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_MachineIDbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_MachineIDno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'h':

					if bytes.Equal(ffj_key_MachineID_Hostname, kn) {
						currentKey = ffj_t_MachineID_Hostname
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_MachineID_Ip, kn) {
						currentKey = ffj_t_MachineID_Ip
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_MachineID_Ip, kn) {
					currentKey = ffj_t_MachineID_Ip
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_MachineID_Hostname, kn) {
					currentKey = ffj_t_MachineID_Hostname
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_MachineIDno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_MachineID_Hostname:
					goto handle_Hostname

				case ffj_t_MachineID_Ip:
					goto handle_Ip

				case ffj_t_MachineIDno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Hostname:

	/* handler: uj.Hostname type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Hostname = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Hostname = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Ip:

	/* handler: uj.Ip type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Ip = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Ip = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *MachineInfo) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *MachineInfo) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "id":`)

	{

		err = mj.ID.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte(',')
	if mj.Mode != nil {
		if true {
			buf.WriteString(`"mode":`)

			{

				obj, err = mj.Mode.MarshalJSON()
				if err != nil {
					return err
				}
				buf.Write(obj)

			}
			buf.WriteByte(',')
		}
	}
	if mj.Unavailability != nil {
		if true {
			buf.WriteString(`"unavailability":`)

			{

				err = mj.Unavailability.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_MachineInfobase = iota
	ffj_t_MachineInfono_such_key

	ffj_t_MachineInfo_ID

	ffj_t_MachineInfo_Mode

	ffj_t_MachineInfo_Unavailability
)

var ffj_key_MachineInfo_ID = []byte("id")

var ffj_key_MachineInfo_Mode = []byte("mode")

var ffj_key_MachineInfo_Unavailability = []byte("unavailability")

func (uj *MachineInfo) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *MachineInfo) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_MachineInfobase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_MachineInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'i':

					if bytes.Equal(ffj_key_MachineInfo_ID, kn) {
						currentKey = ffj_t_MachineInfo_ID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_MachineInfo_Mode, kn) {
						currentKey = ffj_t_MachineInfo_Mode
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffj_key_MachineInfo_Unavailability, kn) {
						currentKey = ffj_t_MachineInfo_Unavailability
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_MachineInfo_Unavailability, kn) {
					currentKey = ffj_t_MachineInfo_Unavailability
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_MachineInfo_Mode, kn) {
					currentKey = ffj_t_MachineInfo_Mode
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_MachineInfo_ID, kn) {
					currentKey = ffj_t_MachineInfo_ID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_MachineInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_MachineInfo_ID:
					goto handle_ID

				case ffj_t_MachineInfo_Mode:
					goto handle_Mode

				case ffj_t_MachineInfo_Unavailability:
					goto handle_Unavailability

				case ffj_t_MachineInfono_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ID:

	/* handler: uj.ID type=mesos.MachineID kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.ID.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Mode:

	/* handler: uj.Mode type=mesos.MachineInfo_Mode kind=int32 quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Mode = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		if uj.Mode == nil {
			uj.Mode = new(MachineInfo_Mode)
		}

		err = uj.Mode.UnmarshalJSON(tbuf)
		if err != nil {
			return fs.WrapErr(err)
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Unavailability:

	/* handler: uj.Unavailability type=mesos.Unavailability kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Unavailability = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Unavailability == nil {
			uj.Unavailability = new(Unavailability)
		}

		err = uj.Unavailability.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *MasterInfo) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *MasterInfo) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "id":`)
	fflib.WriteJsonString(buf, string(mj.ID))
	buf.WriteString(`,"ip":`)
	fflib.FormatBits2(buf, uint64(mj.IP), 10, false)
	buf.WriteByte(',')
	if mj.Port != nil {
		if true {
			buf.WriteString(`"port":`)
			fflib.FormatBits2(buf, uint64(*mj.Port), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.PID != nil {
		if true {
			buf.WriteString(`"pid":`)
			fflib.WriteJsonString(buf, string(*mj.PID))
			buf.WriteByte(',')
		}
	}
	if mj.Hostname != nil {
		if true {
			buf.WriteString(`"hostname":`)
			fflib.WriteJsonString(buf, string(*mj.Hostname))
			buf.WriteByte(',')
		}
	}
	if mj.Version != nil {
		if true {
			buf.WriteString(`"version":`)
			fflib.WriteJsonString(buf, string(*mj.Version))
			buf.WriteByte(',')
		}
	}
	if mj.Address != nil {
		if true {
			buf.WriteString(`"address":`)

			{

				err = mj.Address.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_MasterInfobase = iota
	ffj_t_MasterInfono_such_key

	ffj_t_MasterInfo_ID

	ffj_t_MasterInfo_IP

	ffj_t_MasterInfo_Port

	ffj_t_MasterInfo_PID

	ffj_t_MasterInfo_Hostname

	ffj_t_MasterInfo_Version

	ffj_t_MasterInfo_Address
)

var ffj_key_MasterInfo_ID = []byte("id")

var ffj_key_MasterInfo_IP = []byte("ip")

var ffj_key_MasterInfo_Port = []byte("port")

var ffj_key_MasterInfo_PID = []byte("pid")

var ffj_key_MasterInfo_Hostname = []byte("hostname")

var ffj_key_MasterInfo_Version = []byte("version")

var ffj_key_MasterInfo_Address = []byte("address")

func (uj *MasterInfo) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *MasterInfo) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_MasterInfobase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_MasterInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_MasterInfo_Address, kn) {
						currentKey = ffj_t_MasterInfo_Address
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'h':

					if bytes.Equal(ffj_key_MasterInfo_Hostname, kn) {
						currentKey = ffj_t_MasterInfo_Hostname
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_MasterInfo_ID, kn) {
						currentKey = ffj_t_MasterInfo_ID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_MasterInfo_IP, kn) {
						currentKey = ffj_t_MasterInfo_IP
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_MasterInfo_Port, kn) {
						currentKey = ffj_t_MasterInfo_Port
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_MasterInfo_PID, kn) {
						currentKey = ffj_t_MasterInfo_PID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'v':

					if bytes.Equal(ffj_key_MasterInfo_Version, kn) {
						currentKey = ffj_t_MasterInfo_Version
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_MasterInfo_Address, kn) {
					currentKey = ffj_t_MasterInfo_Address
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_MasterInfo_Version, kn) {
					currentKey = ffj_t_MasterInfo_Version
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_MasterInfo_Hostname, kn) {
					currentKey = ffj_t_MasterInfo_Hostname
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_MasterInfo_PID, kn) {
					currentKey = ffj_t_MasterInfo_PID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_MasterInfo_Port, kn) {
					currentKey = ffj_t_MasterInfo_Port
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_MasterInfo_IP, kn) {
					currentKey = ffj_t_MasterInfo_IP
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_MasterInfo_ID, kn) {
					currentKey = ffj_t_MasterInfo_ID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_MasterInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_MasterInfo_ID:
					goto handle_ID

				case ffj_t_MasterInfo_IP:
					goto handle_IP

				case ffj_t_MasterInfo_Port:
					goto handle_Port

				case ffj_t_MasterInfo_PID:
					goto handle_PID

				case ffj_t_MasterInfo_Hostname:
					goto handle_Hostname

				case ffj_t_MasterInfo_Version:
					goto handle_Version

				case ffj_t_MasterInfo_Address:
					goto handle_Address

				case ffj_t_MasterInfono_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ID:

	/* handler: uj.ID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.ID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_IP:

	/* handler: uj.IP type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.IP = uint32(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Port:

	/* handler: uj.Port type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Port = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint32(tval)
			uj.Port = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PID:

	/* handler: uj.PID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.PID = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.PID = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Hostname:

	/* handler: uj.Hostname type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Hostname = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Hostname = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Version:

	/* handler: uj.Version type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Version = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Version = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Address:

	/* handler: uj.Address type=mesos.Address kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Address = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Address == nil {
			uj.Address = new(Address)
		}

		err = uj.Address.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *NetworkInfo) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *NetworkInfo) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "ip_addresses":`)
	if mj.IPAddresses != nil {
		buf.WriteString(`[`)
		for i, v := range mj.IPAddresses {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte(',')
	if mj.Protocol != nil {
		if true {
			buf.WriteString(`"protocol":`)

			{

				obj, err = mj.Protocol.MarshalJSON()
				if err != nil {
					return err
				}
				buf.Write(obj)

			}
			buf.WriteByte(',')
		}
	}
	if mj.IPAddress != nil {
		if true {
			buf.WriteString(`"ip_address":`)
			fflib.WriteJsonString(buf, string(*mj.IPAddress))
			buf.WriteByte(',')
		}
	}
	if len(mj.Groups) != 0 {
		buf.WriteString(`"groups":`)
		if mj.Groups != nil {
			buf.WriteString(`[`)
			for i, v := range mj.Groups {
				if i != 0 {
					buf.WriteString(`,`)
				}
				fflib.WriteJsonString(buf, string(v))
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if mj.Labels != nil {
		if true {
			buf.WriteString(`"labels":`)

			{

				err = mj.Labels.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_NetworkInfobase = iota
	ffj_t_NetworkInfono_such_key

	ffj_t_NetworkInfo_IPAddresses

	ffj_t_NetworkInfo_Protocol

	ffj_t_NetworkInfo_IPAddress

	ffj_t_NetworkInfo_Groups

	ffj_t_NetworkInfo_Labels
)

var ffj_key_NetworkInfo_IPAddresses = []byte("ip_addresses")

var ffj_key_NetworkInfo_Protocol = []byte("protocol")

var ffj_key_NetworkInfo_IPAddress = []byte("ip_address")

var ffj_key_NetworkInfo_Groups = []byte("groups")

var ffj_key_NetworkInfo_Labels = []byte("labels")

func (uj *NetworkInfo) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *NetworkInfo) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_NetworkInfobase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_NetworkInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'g':

					if bytes.Equal(ffj_key_NetworkInfo_Groups, kn) {
						currentKey = ffj_t_NetworkInfo_Groups
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_NetworkInfo_IPAddresses, kn) {
						currentKey = ffj_t_NetworkInfo_IPAddresses
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_NetworkInfo_IPAddress, kn) {
						currentKey = ffj_t_NetworkInfo_IPAddress
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffj_key_NetworkInfo_Labels, kn) {
						currentKey = ffj_t_NetworkInfo_Labels
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_NetworkInfo_Protocol, kn) {
						currentKey = ffj_t_NetworkInfo_Protocol
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_NetworkInfo_Labels, kn) {
					currentKey = ffj_t_NetworkInfo_Labels
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_NetworkInfo_Groups, kn) {
					currentKey = ffj_t_NetworkInfo_Groups
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_NetworkInfo_IPAddress, kn) {
					currentKey = ffj_t_NetworkInfo_IPAddress
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_NetworkInfo_Protocol, kn) {
					currentKey = ffj_t_NetworkInfo_Protocol
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_NetworkInfo_IPAddresses, kn) {
					currentKey = ffj_t_NetworkInfo_IPAddresses
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_NetworkInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_NetworkInfo_IPAddresses:
					goto handle_IPAddresses

				case ffj_t_NetworkInfo_Protocol:
					goto handle_Protocol

				case ffj_t_NetworkInfo_IPAddress:
					goto handle_IPAddress

				case ffj_t_NetworkInfo_Groups:
					goto handle_Groups

				case ffj_t_NetworkInfo_Labels:
					goto handle_Labels

				case ffj_t_NetworkInfono_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_IPAddresses:

	/* handler: uj.IPAddresses type=[]mesos.NetworkInfo_IPAddress kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.IPAddresses = nil
		} else {

			uj.IPAddresses = make([]NetworkInfo_IPAddress, 0)

			wantVal := true

			for {

				var v NetworkInfo_IPAddress

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=mesos.NetworkInfo_IPAddress kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.IPAddresses = append(uj.IPAddresses, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Protocol:

	/* handler: uj.Protocol type=mesos.NetworkInfo_Protocol kind=int32 quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Protocol = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		if uj.Protocol == nil {
			uj.Protocol = new(NetworkInfo_Protocol)
		}

		err = uj.Protocol.UnmarshalJSON(tbuf)
		if err != nil {
			return fs.WrapErr(err)
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_IPAddress:

	/* handler: uj.IPAddress type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.IPAddress = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.IPAddress = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Groups:

	/* handler: uj.Groups type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Groups = nil
		} else {

			uj.Groups = make([]string, 0)

			wantVal := true

			for {

				var v string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						v = string(string(outBuf))

					}
				}

				uj.Groups = append(uj.Groups, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Labels:

	/* handler: uj.Labels type=mesos.Labels kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Labels = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Labels == nil {
			uj.Labels = new(Labels)
		}

		err = uj.Labels.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *NetworkInfo_IPAddress) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *NetworkInfo_IPAddress) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.Protocol != nil {
		if true {
			buf.WriteString(`"protocol":`)

			{

				obj, err = mj.Protocol.MarshalJSON()
				if err != nil {
					return err
				}
				buf.Write(obj)

			}
			buf.WriteByte(',')
		}
	}
	if mj.IPAddress != nil {
		if true {
			buf.WriteString(`"ip_address":`)
			fflib.WriteJsonString(buf, string(*mj.IPAddress))
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_NetworkInfo_IPAddressbase = iota
	ffj_t_NetworkInfo_IPAddressno_such_key

	ffj_t_NetworkInfo_IPAddress_Protocol

	ffj_t_NetworkInfo_IPAddress_IPAddress
)

var ffj_key_NetworkInfo_IPAddress_Protocol = []byte("protocol")

var ffj_key_NetworkInfo_IPAddress_IPAddress = []byte("ip_address")

func (uj *NetworkInfo_IPAddress) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *NetworkInfo_IPAddress) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_NetworkInfo_IPAddressbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_NetworkInfo_IPAddressno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'i':

					if bytes.Equal(ffj_key_NetworkInfo_IPAddress_IPAddress, kn) {
						currentKey = ffj_t_NetworkInfo_IPAddress_IPAddress
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_NetworkInfo_IPAddress_Protocol, kn) {
						currentKey = ffj_t_NetworkInfo_IPAddress_Protocol
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_NetworkInfo_IPAddress_IPAddress, kn) {
					currentKey = ffj_t_NetworkInfo_IPAddress_IPAddress
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_NetworkInfo_IPAddress_Protocol, kn) {
					currentKey = ffj_t_NetworkInfo_IPAddress_Protocol
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_NetworkInfo_IPAddressno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_NetworkInfo_IPAddress_Protocol:
					goto handle_Protocol

				case ffj_t_NetworkInfo_IPAddress_IPAddress:
					goto handle_IPAddress

				case ffj_t_NetworkInfo_IPAddressno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Protocol:

	/* handler: uj.Protocol type=mesos.NetworkInfo_Protocol kind=int32 quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Protocol = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		if uj.Protocol == nil {
			uj.Protocol = new(NetworkInfo_Protocol)
		}

		err = uj.Protocol.UnmarshalJSON(tbuf)
		if err != nil {
			return fs.WrapErr(err)
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_IPAddress:

	/* handler: uj.IPAddress type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.IPAddress = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.IPAddress = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Offer) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Offer) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "id":`)

	{

		err = mj.ID.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteString(`,"framework_id":`)

	{

		err = mj.FrameworkID.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteString(`,"agent_id":`)

	{

		err = mj.AgentID.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteString(`,"hostname":`)
	fflib.WriteJsonString(buf, string(mj.Hostname))
	buf.WriteByte(',')
	if mj.Url != nil {
		if true {
			buf.WriteString(`"url":`)

			{

				err = mj.Url.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.WriteString(`"resources":`)
	if mj.Resources != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Resources {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"attributes":`)
	if mj.Attributes != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Attributes {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"executor_ids":`)
	if mj.ExecutorIDs != nil {
		buf.WriteString(`[`)
		for i, v := range mj.ExecutorIDs {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte(',')
	if mj.Unavailability != nil {
		if true {
			buf.WriteString(`"unavailability":`)

			{

				err = mj.Unavailability.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Offerbase = iota
	ffj_t_Offerno_such_key

	ffj_t_Offer_ID

	ffj_t_Offer_FrameworkID

	ffj_t_Offer_AgentID

	ffj_t_Offer_Hostname

	ffj_t_Offer_Url

	ffj_t_Offer_Resources

	ffj_t_Offer_Attributes

	ffj_t_Offer_ExecutorIDs

	ffj_t_Offer_Unavailability
)

var ffj_key_Offer_ID = []byte("id")

var ffj_key_Offer_FrameworkID = []byte("framework_id")

var ffj_key_Offer_AgentID = []byte("agent_id")

var ffj_key_Offer_Hostname = []byte("hostname")

var ffj_key_Offer_Url = []byte("url")

var ffj_key_Offer_Resources = []byte("resources")

var ffj_key_Offer_Attributes = []byte("attributes")

var ffj_key_Offer_ExecutorIDs = []byte("executor_ids")

var ffj_key_Offer_Unavailability = []byte("unavailability")

func (uj *Offer) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Offer) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Offerbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Offerno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_Offer_AgentID, kn) {
						currentKey = ffj_t_Offer_AgentID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Offer_Attributes, kn) {
						currentKey = ffj_t_Offer_Attributes
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffj_key_Offer_ExecutorIDs, kn) {
						currentKey = ffj_t_Offer_ExecutorIDs
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffj_key_Offer_FrameworkID, kn) {
						currentKey = ffj_t_Offer_FrameworkID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'h':

					if bytes.Equal(ffj_key_Offer_Hostname, kn) {
						currentKey = ffj_t_Offer_Hostname
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_Offer_ID, kn) {
						currentKey = ffj_t_Offer_ID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_Offer_Resources, kn) {
						currentKey = ffj_t_Offer_Resources
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffj_key_Offer_Url, kn) {
						currentKey = ffj_t_Offer_Url
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Offer_Unavailability, kn) {
						currentKey = ffj_t_Offer_Unavailability
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_Offer_Unavailability, kn) {
					currentKey = ffj_t_Offer_Unavailability
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Offer_ExecutorIDs, kn) {
					currentKey = ffj_t_Offer_ExecutorIDs
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Offer_Attributes, kn) {
					currentKey = ffj_t_Offer_Attributes
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Offer_Resources, kn) {
					currentKey = ffj_t_Offer_Resources
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Offer_Url, kn) {
					currentKey = ffj_t_Offer_Url
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Offer_Hostname, kn) {
					currentKey = ffj_t_Offer_Hostname
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_Offer_AgentID, kn) {
					currentKey = ffj_t_Offer_AgentID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Offer_FrameworkID, kn) {
					currentKey = ffj_t_Offer_FrameworkID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Offer_ID, kn) {
					currentKey = ffj_t_Offer_ID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Offerno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Offer_ID:
					goto handle_ID

				case ffj_t_Offer_FrameworkID:
					goto handle_FrameworkID

				case ffj_t_Offer_AgentID:
					goto handle_AgentID

				case ffj_t_Offer_Hostname:
					goto handle_Hostname

				case ffj_t_Offer_Url:
					goto handle_Url

				case ffj_t_Offer_Resources:
					goto handle_Resources

				case ffj_t_Offer_Attributes:
					goto handle_Attributes

				case ffj_t_Offer_ExecutorIDs:
					goto handle_ExecutorIDs

				case ffj_t_Offer_Unavailability:
					goto handle_Unavailability

				case ffj_t_Offerno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ID:

	/* handler: uj.ID type=mesos.OfferID kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.ID.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FrameworkID:

	/* handler: uj.FrameworkID type=mesos.FrameworkID kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.FrameworkID.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AgentID:

	/* handler: uj.AgentID type=mesos.AgentID kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.AgentID.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Hostname:

	/* handler: uj.Hostname type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Hostname = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Url:

	/* handler: uj.Url type=mesos.URL kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Url = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Url == nil {
			uj.Url = new(URL)
		}

		err = uj.Url.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Resources:

	/* handler: uj.Resources type=[]mesos.Resource kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Resources = nil
		} else {

			uj.Resources = make([]Resource, 0)

			wantVal := true

			for {

				var v Resource

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=mesos.Resource kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Resources = append(uj.Resources, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Attributes:

	/* handler: uj.Attributes type=[]mesos.Attribute kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Attributes = nil
		} else {

			uj.Attributes = make([]Attribute, 0)

			wantVal := true

			for {

				var v Attribute

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=mesos.Attribute kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Attributes = append(uj.Attributes, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ExecutorIDs:

	/* handler: uj.ExecutorIDs type=[]mesos.ExecutorID kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.ExecutorIDs = nil
		} else {

			uj.ExecutorIDs = make([]ExecutorID, 0)

			wantVal := true

			for {

				var v ExecutorID

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=mesos.ExecutorID kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.ExecutorIDs = append(uj.ExecutorIDs, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Unavailability:

	/* handler: uj.Unavailability type=mesos.Unavailability kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Unavailability = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Unavailability == nil {
			uj.Unavailability = new(Unavailability)
		}

		err = uj.Unavailability.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *OfferID) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *OfferID) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"value":`)
	fflib.WriteJsonString(buf, string(mj.Value))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_OfferIDbase = iota
	ffj_t_OfferIDno_such_key

	ffj_t_OfferID_Value
)

var ffj_key_OfferID_Value = []byte("value")

func (uj *OfferID) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *OfferID) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_OfferIDbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_OfferIDno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'v':

					if bytes.Equal(ffj_key_OfferID_Value, kn) {
						currentKey = ffj_t_OfferID_Value
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_OfferID_Value, kn) {
					currentKey = ffj_t_OfferID_Value
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_OfferIDno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_OfferID_Value:
					goto handle_Value

				case ffj_t_OfferIDno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Value:

	/* handler: uj.Value type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Value = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Offer_Operation) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Offer_Operation) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.Type != nil {
		if true {
			buf.WriteString(`"type":`)

			{

				obj, err = mj.Type.MarshalJSON()
				if err != nil {
					return err
				}
				buf.Write(obj)

			}
			buf.WriteByte(',')
		}
	}
	if mj.Launch != nil {
		if true {
			buf.WriteString(`"launch":`)

			{

				err = mj.Launch.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.Reserve != nil {
		if true {
			buf.WriteString(`"reserve":`)

			{

				err = mj.Reserve.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.Unreserve != nil {
		if true {
			buf.WriteString(`"unreserve":`)

			{

				err = mj.Unreserve.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.Create != nil {
		if true {
			buf.WriteString(`"create":`)

			{

				err = mj.Create.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.Destroy != nil {
		if true {
			buf.WriteString(`"destroy":`)

			{

				err = mj.Destroy.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Offer_Operationbase = iota
	ffj_t_Offer_Operationno_such_key

	ffj_t_Offer_Operation_Type

	ffj_t_Offer_Operation_Launch

	ffj_t_Offer_Operation_Reserve

	ffj_t_Offer_Operation_Unreserve

	ffj_t_Offer_Operation_Create

	ffj_t_Offer_Operation_Destroy
)

var ffj_key_Offer_Operation_Type = []byte("type")

var ffj_key_Offer_Operation_Launch = []byte("launch")

var ffj_key_Offer_Operation_Reserve = []byte("reserve")

var ffj_key_Offer_Operation_Unreserve = []byte("unreserve")

var ffj_key_Offer_Operation_Create = []byte("create")

var ffj_key_Offer_Operation_Destroy = []byte("destroy")

func (uj *Offer_Operation) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Offer_Operation) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Offer_Operationbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Offer_Operationno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_Offer_Operation_Create, kn) {
						currentKey = ffj_t_Offer_Operation_Create
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffj_key_Offer_Operation_Destroy, kn) {
						currentKey = ffj_t_Offer_Operation_Destroy
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffj_key_Offer_Operation_Launch, kn) {
						currentKey = ffj_t_Offer_Operation_Launch
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_Offer_Operation_Reserve, kn) {
						currentKey = ffj_t_Offer_Operation_Reserve
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_Offer_Operation_Type, kn) {
						currentKey = ffj_t_Offer_Operation_Type
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffj_key_Offer_Operation_Unreserve, kn) {
						currentKey = ffj_t_Offer_Operation_Unreserve
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_Offer_Operation_Destroy, kn) {
					currentKey = ffj_t_Offer_Operation_Destroy
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Offer_Operation_Create, kn) {
					currentKey = ffj_t_Offer_Operation_Create
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Offer_Operation_Unreserve, kn) {
					currentKey = ffj_t_Offer_Operation_Unreserve
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Offer_Operation_Reserve, kn) {
					currentKey = ffj_t_Offer_Operation_Reserve
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Offer_Operation_Launch, kn) {
					currentKey = ffj_t_Offer_Operation_Launch
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Offer_Operation_Type, kn) {
					currentKey = ffj_t_Offer_Operation_Type
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Offer_Operationno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Offer_Operation_Type:
					goto handle_Type

				case ffj_t_Offer_Operation_Launch:
					goto handle_Launch

				case ffj_t_Offer_Operation_Reserve:
					goto handle_Reserve

				case ffj_t_Offer_Operation_Unreserve:
					goto handle_Unreserve

				case ffj_t_Offer_Operation_Create:
					goto handle_Create

				case ffj_t_Offer_Operation_Destroy:
					goto handle_Destroy

				case ffj_t_Offer_Operationno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Type:

	/* handler: uj.Type type=mesos.Offer_Operation_Type kind=int32 quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Type = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		if uj.Type == nil {
			uj.Type = new(Offer_Operation_Type)
		}

		err = uj.Type.UnmarshalJSON(tbuf)
		if err != nil {
			return fs.WrapErr(err)
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Launch:

	/* handler: uj.Launch type=mesos.Offer_Operation_Launch kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Launch = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Launch == nil {
			uj.Launch = new(Offer_Operation_Launch)
		}

		err = uj.Launch.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Reserve:

	/* handler: uj.Reserve type=mesos.Offer_Operation_Reserve kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Reserve = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Reserve == nil {
			uj.Reserve = new(Offer_Operation_Reserve)
		}

		err = uj.Reserve.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Unreserve:

	/* handler: uj.Unreserve type=mesos.Offer_Operation_Unreserve kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Unreserve = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Unreserve == nil {
			uj.Unreserve = new(Offer_Operation_Unreserve)
		}

		err = uj.Unreserve.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Create:

	/* handler: uj.Create type=mesos.Offer_Operation_Create kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Create = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Create == nil {
			uj.Create = new(Offer_Operation_Create)
		}

		err = uj.Create.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Destroy:

	/* handler: uj.Destroy type=mesos.Offer_Operation_Destroy kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Destroy = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Destroy == nil {
			uj.Destroy = new(Offer_Operation_Destroy)
		}

		err = uj.Destroy.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Offer_Operation_Create) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Offer_Operation_Create) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"volumes":`)
	if mj.Volumes != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Volumes {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Offer_Operation_Createbase = iota
	ffj_t_Offer_Operation_Createno_such_key

	ffj_t_Offer_Operation_Create_Volumes
)

var ffj_key_Offer_Operation_Create_Volumes = []byte("volumes")

func (uj *Offer_Operation_Create) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Offer_Operation_Create) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Offer_Operation_Createbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Offer_Operation_Createno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'v':

					if bytes.Equal(ffj_key_Offer_Operation_Create_Volumes, kn) {
						currentKey = ffj_t_Offer_Operation_Create_Volumes
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_Offer_Operation_Create_Volumes, kn) {
					currentKey = ffj_t_Offer_Operation_Create_Volumes
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Offer_Operation_Createno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Offer_Operation_Create_Volumes:
					goto handle_Volumes

				case ffj_t_Offer_Operation_Createno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Volumes:

	/* handler: uj.Volumes type=[]mesos.Resource kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Volumes = nil
		} else {

			uj.Volumes = make([]Resource, 0)

			wantVal := true

			for {

				var v Resource

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=mesos.Resource kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Volumes = append(uj.Volumes, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Offer_Operation_Destroy) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Offer_Operation_Destroy) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"volumes":`)
	if mj.Volumes != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Volumes {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Offer_Operation_Destroybase = iota
	ffj_t_Offer_Operation_Destroyno_such_key

	ffj_t_Offer_Operation_Destroy_Volumes
)

var ffj_key_Offer_Operation_Destroy_Volumes = []byte("volumes")

func (uj *Offer_Operation_Destroy) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Offer_Operation_Destroy) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Offer_Operation_Destroybase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Offer_Operation_Destroyno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'v':

					if bytes.Equal(ffj_key_Offer_Operation_Destroy_Volumes, kn) {
						currentKey = ffj_t_Offer_Operation_Destroy_Volumes
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_Offer_Operation_Destroy_Volumes, kn) {
					currentKey = ffj_t_Offer_Operation_Destroy_Volumes
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Offer_Operation_Destroyno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Offer_Operation_Destroy_Volumes:
					goto handle_Volumes

				case ffj_t_Offer_Operation_Destroyno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Volumes:

	/* handler: uj.Volumes type=[]mesos.Resource kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Volumes = nil
		} else {

			uj.Volumes = make([]Resource, 0)

			wantVal := true

			for {

				var v Resource

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=mesos.Resource kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Volumes = append(uj.Volumes, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Offer_Operation_Launch) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Offer_Operation_Launch) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"task_infos":`)
	if mj.TaskInfos != nil {
		buf.WriteString(`[`)
		for i, v := range mj.TaskInfos {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Offer_Operation_Launchbase = iota
	ffj_t_Offer_Operation_Launchno_such_key

	ffj_t_Offer_Operation_Launch_TaskInfos
)

var ffj_key_Offer_Operation_Launch_TaskInfos = []byte("task_infos")

func (uj *Offer_Operation_Launch) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Offer_Operation_Launch) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Offer_Operation_Launchbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Offer_Operation_Launchno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 't':

					if bytes.Equal(ffj_key_Offer_Operation_Launch_TaskInfos, kn) {
						currentKey = ffj_t_Offer_Operation_Launch_TaskInfos
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_Offer_Operation_Launch_TaskInfos, kn) {
					currentKey = ffj_t_Offer_Operation_Launch_TaskInfos
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Offer_Operation_Launchno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Offer_Operation_Launch_TaskInfos:
					goto handle_TaskInfos

				case ffj_t_Offer_Operation_Launchno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_TaskInfos:

	/* handler: uj.TaskInfos type=[]mesos.TaskInfo kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.TaskInfos = nil
		} else {

			uj.TaskInfos = make([]TaskInfo, 0)

			wantVal := true

			for {

				var v TaskInfo

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=mesos.TaskInfo kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.TaskInfos = append(uj.TaskInfos, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Offer_Operation_Reserve) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Offer_Operation_Reserve) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"resources":`)
	if mj.Resources != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Resources {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Offer_Operation_Reservebase = iota
	ffj_t_Offer_Operation_Reserveno_such_key

	ffj_t_Offer_Operation_Reserve_Resources
)

var ffj_key_Offer_Operation_Reserve_Resources = []byte("resources")

func (uj *Offer_Operation_Reserve) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Offer_Operation_Reserve) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Offer_Operation_Reservebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Offer_Operation_Reserveno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'r':

					if bytes.Equal(ffj_key_Offer_Operation_Reserve_Resources, kn) {
						currentKey = ffj_t_Offer_Operation_Reserve_Resources
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_Offer_Operation_Reserve_Resources, kn) {
					currentKey = ffj_t_Offer_Operation_Reserve_Resources
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Offer_Operation_Reserveno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Offer_Operation_Reserve_Resources:
					goto handle_Resources

				case ffj_t_Offer_Operation_Reserveno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Resources:

	/* handler: uj.Resources type=[]mesos.Resource kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Resources = nil
		} else {

			uj.Resources = make([]Resource, 0)

			wantVal := true

			for {

				var v Resource

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=mesos.Resource kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Resources = append(uj.Resources, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Offer_Operation_Unreserve) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Offer_Operation_Unreserve) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"resources":`)
	if mj.Resources != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Resources {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Offer_Operation_Unreservebase = iota
	ffj_t_Offer_Operation_Unreserveno_such_key

	ffj_t_Offer_Operation_Unreserve_Resources
)

var ffj_key_Offer_Operation_Unreserve_Resources = []byte("resources")

func (uj *Offer_Operation_Unreserve) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Offer_Operation_Unreserve) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Offer_Operation_Unreservebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Offer_Operation_Unreserveno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'r':

					if bytes.Equal(ffj_key_Offer_Operation_Unreserve_Resources, kn) {
						currentKey = ffj_t_Offer_Operation_Unreserve_Resources
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_Offer_Operation_Unreserve_Resources, kn) {
					currentKey = ffj_t_Offer_Operation_Unreserve_Resources
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Offer_Operation_Unreserveno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Offer_Operation_Unreserve_Resources:
					goto handle_Resources

				case ffj_t_Offer_Operation_Unreserveno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Resources:

	/* handler: uj.Resources type=[]mesos.Resource kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Resources = nil
		} else {

			uj.Resources = make([]Resource, 0)

			wantVal := true

			for {

				var v Resource

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=mesos.Resource kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Resources = append(uj.Resources, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Parameter) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Parameter) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"key":`)
	fflib.WriteJsonString(buf, string(mj.Key))
	buf.WriteString(`,"value":`)
	fflib.WriteJsonString(buf, string(mj.Value))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Parameterbase = iota
	ffj_t_Parameterno_such_key

	ffj_t_Parameter_Key

	ffj_t_Parameter_Value
)

var ffj_key_Parameter_Key = []byte("key")

var ffj_key_Parameter_Value = []byte("value")

func (uj *Parameter) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Parameter) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Parameterbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Parameterno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'k':

					if bytes.Equal(ffj_key_Parameter_Key, kn) {
						currentKey = ffj_t_Parameter_Key
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'v':

					if bytes.Equal(ffj_key_Parameter_Value, kn) {
						currentKey = ffj_t_Parameter_Value
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_Parameter_Value, kn) {
					currentKey = ffj_t_Parameter_Value
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Parameter_Key, kn) {
					currentKey = ffj_t_Parameter_Key
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Parameterno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Parameter_Key:
					goto handle_Key

				case ffj_t_Parameter_Value:
					goto handle_Value

				case ffj_t_Parameterno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Key:

	/* handler: uj.Key type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Key = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Value:

	/* handler: uj.Value type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Value = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Parameters) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Parameters) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"parameter":`)
	if mj.Parameter != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Parameter {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Parametersbase = iota
	ffj_t_Parametersno_such_key

	ffj_t_Parameters_Parameter
)

var ffj_key_Parameters_Parameter = []byte("parameter")

func (uj *Parameters) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Parameters) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Parametersbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Parametersno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'p':

					if bytes.Equal(ffj_key_Parameters_Parameter, kn) {
						currentKey = ffj_t_Parameters_Parameter
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_Parameters_Parameter, kn) {
					currentKey = ffj_t_Parameters_Parameter
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Parametersno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Parameters_Parameter:
					goto handle_Parameter

				case ffj_t_Parametersno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Parameter:

	/* handler: uj.Parameter type=[]mesos.Parameter kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Parameter = nil
		} else {

			uj.Parameter = make([]Parameter, 0)

			wantVal := true

			for {

				var v Parameter

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=mesos.Parameter kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Parameter = append(uj.Parameter, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *PerfStatistics) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *PerfStatistics) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "timestamp":`)
	fflib.AppendFloat(buf, float64(mj.Timestamp), 'g', -1, 64)
	buf.WriteString(`,"duration":`)
	fflib.AppendFloat(buf, float64(mj.Duration), 'g', -1, 64)
	buf.WriteByte(',')
	if mj.Cycles != nil {
		if true {
			buf.WriteString(`"cycles":`)
			fflib.FormatBits2(buf, uint64(*mj.Cycles), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.StalledCyclesFrontend != nil {
		if true {
			buf.WriteString(`"stalled_cycles_frontend":`)
			fflib.FormatBits2(buf, uint64(*mj.StalledCyclesFrontend), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.StalledCyclesBackend != nil {
		if true {
			buf.WriteString(`"stalled_cycles_backend":`)
			fflib.FormatBits2(buf, uint64(*mj.StalledCyclesBackend), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.Instructions != nil {
		if true {
			buf.WriteString(`"instructions":`)
			fflib.FormatBits2(buf, uint64(*mj.Instructions), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.CacheReferences != nil {
		if true {
			buf.WriteString(`"cache_references":`)
			fflib.FormatBits2(buf, uint64(*mj.CacheReferences), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.CacheMisses != nil {
		if true {
			buf.WriteString(`"cache_misses":`)
			fflib.FormatBits2(buf, uint64(*mj.CacheMisses), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.Branches != nil {
		if true {
			buf.WriteString(`"branches":`)
			fflib.FormatBits2(buf, uint64(*mj.Branches), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.BranchMisses != nil {
		if true {
			buf.WriteString(`"branch_misses":`)
			fflib.FormatBits2(buf, uint64(*mj.BranchMisses), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.BusCycles != nil {
		if true {
			buf.WriteString(`"bus_cycles":`)
			fflib.FormatBits2(buf, uint64(*mj.BusCycles), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.RefCycles != nil {
		if true {
			buf.WriteString(`"ref_cycles":`)
			fflib.FormatBits2(buf, uint64(*mj.RefCycles), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.CpuClock != nil {
		if true {
			buf.WriteString(`"cpu_clock":`)
			fflib.AppendFloat(buf, float64(*mj.CpuClock), 'g', -1, 64)
			buf.WriteByte(',')
		}
	}
	if mj.TaskClock != nil {
		if true {
			buf.WriteString(`"task_clock":`)
			fflib.AppendFloat(buf, float64(*mj.TaskClock), 'g', -1, 64)
			buf.WriteByte(',')
		}
	}
	if mj.PageFaults != nil {
		if true {
			buf.WriteString(`"page_faults":`)
			fflib.FormatBits2(buf, uint64(*mj.PageFaults), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.MinorFaults != nil {
		if true {
			buf.WriteString(`"minor_faults":`)
			fflib.FormatBits2(buf, uint64(*mj.MinorFaults), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.MajorFaults != nil {
		if true {
			buf.WriteString(`"major_faults":`)
			fflib.FormatBits2(buf, uint64(*mj.MajorFaults), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.ContextSwitches != nil {
		if true {
			buf.WriteString(`"context_switches":`)
			fflib.FormatBits2(buf, uint64(*mj.ContextSwitches), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.CpuMigrations != nil {
		if true {
			buf.WriteString(`"cpu_migrations":`)
			fflib.FormatBits2(buf, uint64(*mj.CpuMigrations), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.AlignmentFaults != nil {
		if true {
			buf.WriteString(`"alignment_faults":`)
			fflib.FormatBits2(buf, uint64(*mj.AlignmentFaults), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.EmulationFaults != nil {
		if true {
			buf.WriteString(`"emulation_faults":`)
			fflib.FormatBits2(buf, uint64(*mj.EmulationFaults), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.L1DcacheLoads != nil {
		if true {
			buf.WriteString(`"l1_dcache_loads":`)
			fflib.FormatBits2(buf, uint64(*mj.L1DcacheLoads), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.L1DcacheLoadMisses != nil {
		if true {
			buf.WriteString(`"l1_dcache_load_misses":`)
			fflib.FormatBits2(buf, uint64(*mj.L1DcacheLoadMisses), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.L1DcacheStores != nil {
		if true {
			buf.WriteString(`"l1_dcache_stores":`)
			fflib.FormatBits2(buf, uint64(*mj.L1DcacheStores), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.L1DcacheStoreMisses != nil {
		if true {
			buf.WriteString(`"l1_dcache_store_misses":`)
			fflib.FormatBits2(buf, uint64(*mj.L1DcacheStoreMisses), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.L1DcachePrefetches != nil {
		if true {
			buf.WriteString(`"l1_dcache_prefetches":`)
			fflib.FormatBits2(buf, uint64(*mj.L1DcachePrefetches), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.L1DcachePrefetchMisses != nil {
		if true {
			buf.WriteString(`"l1_dcache_prefetch_misses":`)
			fflib.FormatBits2(buf, uint64(*mj.L1DcachePrefetchMisses), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.L1IcacheLoads != nil {
		if true {
			buf.WriteString(`"l1_icache_loads":`)
			fflib.FormatBits2(buf, uint64(*mj.L1IcacheLoads), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.L1IcacheLoadMisses != nil {
		if true {
			buf.WriteString(`"l1_icache_load_misses":`)
			fflib.FormatBits2(buf, uint64(*mj.L1IcacheLoadMisses), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.L1IcachePrefetches != nil {
		if true {
			buf.WriteString(`"l1_icache_prefetches":`)
			fflib.FormatBits2(buf, uint64(*mj.L1IcachePrefetches), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.L1IcachePrefetchMisses != nil {
		if true {
			buf.WriteString(`"l1_icache_prefetch_misses":`)
			fflib.FormatBits2(buf, uint64(*mj.L1IcachePrefetchMisses), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.LlcLoads != nil {
		if true {
			buf.WriteString(`"llc_loads":`)
			fflib.FormatBits2(buf, uint64(*mj.LlcLoads), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.LlcLoadMisses != nil {
		if true {
			buf.WriteString(`"llc_load_misses":`)
			fflib.FormatBits2(buf, uint64(*mj.LlcLoadMisses), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.LlcStores != nil {
		if true {
			buf.WriteString(`"llc_stores":`)
			fflib.FormatBits2(buf, uint64(*mj.LlcStores), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.LlcStoreMisses != nil {
		if true {
			buf.WriteString(`"llc_store_misses":`)
			fflib.FormatBits2(buf, uint64(*mj.LlcStoreMisses), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.LlcPrefetches != nil {
		if true {
			buf.WriteString(`"llc_prefetches":`)
			fflib.FormatBits2(buf, uint64(*mj.LlcPrefetches), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.LlcPrefetchMisses != nil {
		if true {
			buf.WriteString(`"llc_prefetch_misses":`)
			fflib.FormatBits2(buf, uint64(*mj.LlcPrefetchMisses), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.DtlbLoads != nil {
		if true {
			buf.WriteString(`"dtlb_loads":`)
			fflib.FormatBits2(buf, uint64(*mj.DtlbLoads), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.DtlbLoadMisses != nil {
		if true {
			buf.WriteString(`"dtlb_load_misses":`)
			fflib.FormatBits2(buf, uint64(*mj.DtlbLoadMisses), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.DtlbStores != nil {
		if true {
			buf.WriteString(`"dtlb_stores":`)
			fflib.FormatBits2(buf, uint64(*mj.DtlbStores), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.DtlbStoreMisses != nil {
		if true {
			buf.WriteString(`"dtlb_store_misses":`)
			fflib.FormatBits2(buf, uint64(*mj.DtlbStoreMisses), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.DtlbPrefetches != nil {
		if true {
			buf.WriteString(`"dtlb_prefetches":`)
			fflib.FormatBits2(buf, uint64(*mj.DtlbPrefetches), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.DtlbPrefetchMisses != nil {
		if true {
			buf.WriteString(`"dtlb_prefetch_misses":`)
			fflib.FormatBits2(buf, uint64(*mj.DtlbPrefetchMisses), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.ItlbLoads != nil {
		if true {
			buf.WriteString(`"itlb_loads":`)
			fflib.FormatBits2(buf, uint64(*mj.ItlbLoads), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.ItlbLoadMisses != nil {
		if true {
			buf.WriteString(`"itlb_load_misses":`)
			fflib.FormatBits2(buf, uint64(*mj.ItlbLoadMisses), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.BranchLoads != nil {
		if true {
			buf.WriteString(`"branch_loads":`)
			fflib.FormatBits2(buf, uint64(*mj.BranchLoads), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.BranchLoadMisses != nil {
		if true {
			buf.WriteString(`"branch_load_misses":`)
			fflib.FormatBits2(buf, uint64(*mj.BranchLoadMisses), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.NodeLoads != nil {
		if true {
			buf.WriteString(`"node_loads":`)
			fflib.FormatBits2(buf, uint64(*mj.NodeLoads), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.NodeLoadMisses != nil {
		if true {
			buf.WriteString(`"node_load_misses":`)
			fflib.FormatBits2(buf, uint64(*mj.NodeLoadMisses), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.NodeStores != nil {
		if true {
			buf.WriteString(`"node_stores":`)
			fflib.FormatBits2(buf, uint64(*mj.NodeStores), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.NodeStoreMisses != nil {
		if true {
			buf.WriteString(`"node_store_misses":`)
			fflib.FormatBits2(buf, uint64(*mj.NodeStoreMisses), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.NodePrefetches != nil {
		if true {
			buf.WriteString(`"node_prefetches":`)
			fflib.FormatBits2(buf, uint64(*mj.NodePrefetches), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.NodePrefetchMisses != nil {
		if true {
			buf.WriteString(`"node_prefetch_misses":`)
			fflib.FormatBits2(buf, uint64(*mj.NodePrefetchMisses), 10, false)
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_PerfStatisticsbase = iota
	ffj_t_PerfStatisticsno_such_key

	ffj_t_PerfStatistics_Timestamp

	ffj_t_PerfStatistics_Duration

	ffj_t_PerfStatistics_Cycles

	ffj_t_PerfStatistics_StalledCyclesFrontend

	ffj_t_PerfStatistics_StalledCyclesBackend

	ffj_t_PerfStatistics_Instructions

	ffj_t_PerfStatistics_CacheReferences

	ffj_t_PerfStatistics_CacheMisses

	ffj_t_PerfStatistics_Branches

	ffj_t_PerfStatistics_BranchMisses

	ffj_t_PerfStatistics_BusCycles

	ffj_t_PerfStatistics_RefCycles

	ffj_t_PerfStatistics_CpuClock

	ffj_t_PerfStatistics_TaskClock

	ffj_t_PerfStatistics_PageFaults

	ffj_t_PerfStatistics_MinorFaults

	ffj_t_PerfStatistics_MajorFaults

	ffj_t_PerfStatistics_ContextSwitches

	ffj_t_PerfStatistics_CpuMigrations

	ffj_t_PerfStatistics_AlignmentFaults

	ffj_t_PerfStatistics_EmulationFaults

	ffj_t_PerfStatistics_L1DcacheLoads

	ffj_t_PerfStatistics_L1DcacheLoadMisses

	ffj_t_PerfStatistics_L1DcacheStores

	ffj_t_PerfStatistics_L1DcacheStoreMisses

	ffj_t_PerfStatistics_L1DcachePrefetches

	ffj_t_PerfStatistics_L1DcachePrefetchMisses

	ffj_t_PerfStatistics_L1IcacheLoads

	ffj_t_PerfStatistics_L1IcacheLoadMisses

	ffj_t_PerfStatistics_L1IcachePrefetches

	ffj_t_PerfStatistics_L1IcachePrefetchMisses

	ffj_t_PerfStatistics_LlcLoads

	ffj_t_PerfStatistics_LlcLoadMisses

	ffj_t_PerfStatistics_LlcStores

	ffj_t_PerfStatistics_LlcStoreMisses

	ffj_t_PerfStatistics_LlcPrefetches

	ffj_t_PerfStatistics_LlcPrefetchMisses

	ffj_t_PerfStatistics_DtlbLoads

	ffj_t_PerfStatistics_DtlbLoadMisses

	ffj_t_PerfStatistics_DtlbStores

	ffj_t_PerfStatistics_DtlbStoreMisses

	ffj_t_PerfStatistics_DtlbPrefetches

	ffj_t_PerfStatistics_DtlbPrefetchMisses

	ffj_t_PerfStatistics_ItlbLoads

	ffj_t_PerfStatistics_ItlbLoadMisses

	ffj_t_PerfStatistics_BranchLoads

	ffj_t_PerfStatistics_BranchLoadMisses

	ffj_t_PerfStatistics_NodeLoads

	ffj_t_PerfStatistics_NodeLoadMisses

	ffj_t_PerfStatistics_NodeStores

	ffj_t_PerfStatistics_NodeStoreMisses

	ffj_t_PerfStatistics_NodePrefetches

	ffj_t_PerfStatistics_NodePrefetchMisses
)

var ffj_key_PerfStatistics_Timestamp = []byte("timestamp")

var ffj_key_PerfStatistics_Duration = []byte("duration")

var ffj_key_PerfStatistics_Cycles = []byte("cycles")

var ffj_key_PerfStatistics_StalledCyclesFrontend = []byte("stalled_cycles_frontend")

var ffj_key_PerfStatistics_StalledCyclesBackend = []byte("stalled_cycles_backend")

var ffj_key_PerfStatistics_Instructions = []byte("instructions")

var ffj_key_PerfStatistics_CacheReferences = []byte("cache_references")

var ffj_key_PerfStatistics_CacheMisses = []byte("cache_misses")

var ffj_key_PerfStatistics_Branches = []byte("branches")

var ffj_key_PerfStatistics_BranchMisses = []byte("branch_misses")

var ffj_key_PerfStatistics_BusCycles = []byte("bus_cycles")

var ffj_key_PerfStatistics_RefCycles = []byte("ref_cycles")

var ffj_key_PerfStatistics_CpuClock = []byte("cpu_clock")

var ffj_key_PerfStatistics_TaskClock = []byte("task_clock")

var ffj_key_PerfStatistics_PageFaults = []byte("page_faults")

var ffj_key_PerfStatistics_MinorFaults = []byte("minor_faults")

var ffj_key_PerfStatistics_MajorFaults = []byte("major_faults")

var ffj_key_PerfStatistics_ContextSwitches = []byte("context_switches")

var ffj_key_PerfStatistics_CpuMigrations = []byte("cpu_migrations")

var ffj_key_PerfStatistics_AlignmentFaults = []byte("alignment_faults")

var ffj_key_PerfStatistics_EmulationFaults = []byte("emulation_faults")

var ffj_key_PerfStatistics_L1DcacheLoads = []byte("l1_dcache_loads")

var ffj_key_PerfStatistics_L1DcacheLoadMisses = []byte("l1_dcache_load_misses")

var ffj_key_PerfStatistics_L1DcacheStores = []byte("l1_dcache_stores")

var ffj_key_PerfStatistics_L1DcacheStoreMisses = []byte("l1_dcache_store_misses")

var ffj_key_PerfStatistics_L1DcachePrefetches = []byte("l1_dcache_prefetches")

var ffj_key_PerfStatistics_L1DcachePrefetchMisses = []byte("l1_dcache_prefetch_misses")

var ffj_key_PerfStatistics_L1IcacheLoads = []byte("l1_icache_loads")

var ffj_key_PerfStatistics_L1IcacheLoadMisses = []byte("l1_icache_load_misses")

var ffj_key_PerfStatistics_L1IcachePrefetches = []byte("l1_icache_prefetches")

var ffj_key_PerfStatistics_L1IcachePrefetchMisses = []byte("l1_icache_prefetch_misses")

var ffj_key_PerfStatistics_LlcLoads = []byte("llc_loads")

var ffj_key_PerfStatistics_LlcLoadMisses = []byte("llc_load_misses")

var ffj_key_PerfStatistics_LlcStores = []byte("llc_stores")

var ffj_key_PerfStatistics_LlcStoreMisses = []byte("llc_store_misses")

var ffj_key_PerfStatistics_LlcPrefetches = []byte("llc_prefetches")

var ffj_key_PerfStatistics_LlcPrefetchMisses = []byte("llc_prefetch_misses")

var ffj_key_PerfStatistics_DtlbLoads = []byte("dtlb_loads")

var ffj_key_PerfStatistics_DtlbLoadMisses = []byte("dtlb_load_misses")

var ffj_key_PerfStatistics_DtlbStores = []byte("dtlb_stores")

var ffj_key_PerfStatistics_DtlbStoreMisses = []byte("dtlb_store_misses")

var ffj_key_PerfStatistics_DtlbPrefetches = []byte("dtlb_prefetches")

var ffj_key_PerfStatistics_DtlbPrefetchMisses = []byte("dtlb_prefetch_misses")

var ffj_key_PerfStatistics_ItlbLoads = []byte("itlb_loads")

var ffj_key_PerfStatistics_ItlbLoadMisses = []byte("itlb_load_misses")

var ffj_key_PerfStatistics_BranchLoads = []byte("branch_loads")

var ffj_key_PerfStatistics_BranchLoadMisses = []byte("branch_load_misses")

var ffj_key_PerfStatistics_NodeLoads = []byte("node_loads")

var ffj_key_PerfStatistics_NodeLoadMisses = []byte("node_load_misses")

var ffj_key_PerfStatistics_NodeStores = []byte("node_stores")

var ffj_key_PerfStatistics_NodeStoreMisses = []byte("node_store_misses")

var ffj_key_PerfStatistics_NodePrefetches = []byte("node_prefetches")

var ffj_key_PerfStatistics_NodePrefetchMisses = []byte("node_prefetch_misses")

func (uj *PerfStatistics) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *PerfStatistics) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_PerfStatisticsbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_PerfStatisticsno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_PerfStatistics_AlignmentFaults, kn) {
						currentKey = ffj_t_PerfStatistics_AlignmentFaults
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'b':

					if bytes.Equal(ffj_key_PerfStatistics_Branches, kn) {
						currentKey = ffj_t_PerfStatistics_Branches
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PerfStatistics_BranchMisses, kn) {
						currentKey = ffj_t_PerfStatistics_BranchMisses
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PerfStatistics_BusCycles, kn) {
						currentKey = ffj_t_PerfStatistics_BusCycles
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PerfStatistics_BranchLoads, kn) {
						currentKey = ffj_t_PerfStatistics_BranchLoads
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PerfStatistics_BranchLoadMisses, kn) {
						currentKey = ffj_t_PerfStatistics_BranchLoadMisses
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffj_key_PerfStatistics_Cycles, kn) {
						currentKey = ffj_t_PerfStatistics_Cycles
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PerfStatistics_CacheReferences, kn) {
						currentKey = ffj_t_PerfStatistics_CacheReferences
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PerfStatistics_CacheMisses, kn) {
						currentKey = ffj_t_PerfStatistics_CacheMisses
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PerfStatistics_CpuClock, kn) {
						currentKey = ffj_t_PerfStatistics_CpuClock
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PerfStatistics_ContextSwitches, kn) {
						currentKey = ffj_t_PerfStatistics_ContextSwitches
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PerfStatistics_CpuMigrations, kn) {
						currentKey = ffj_t_PerfStatistics_CpuMigrations
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffj_key_PerfStatistics_Duration, kn) {
						currentKey = ffj_t_PerfStatistics_Duration
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PerfStatistics_DtlbLoads, kn) {
						currentKey = ffj_t_PerfStatistics_DtlbLoads
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PerfStatistics_DtlbLoadMisses, kn) {
						currentKey = ffj_t_PerfStatistics_DtlbLoadMisses
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PerfStatistics_DtlbStores, kn) {
						currentKey = ffj_t_PerfStatistics_DtlbStores
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PerfStatistics_DtlbStoreMisses, kn) {
						currentKey = ffj_t_PerfStatistics_DtlbStoreMisses
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PerfStatistics_DtlbPrefetches, kn) {
						currentKey = ffj_t_PerfStatistics_DtlbPrefetches
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PerfStatistics_DtlbPrefetchMisses, kn) {
						currentKey = ffj_t_PerfStatistics_DtlbPrefetchMisses
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffj_key_PerfStatistics_EmulationFaults, kn) {
						currentKey = ffj_t_PerfStatistics_EmulationFaults
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_PerfStatistics_Instructions, kn) {
						currentKey = ffj_t_PerfStatistics_Instructions
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PerfStatistics_ItlbLoads, kn) {
						currentKey = ffj_t_PerfStatistics_ItlbLoads
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PerfStatistics_ItlbLoadMisses, kn) {
						currentKey = ffj_t_PerfStatistics_ItlbLoadMisses
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffj_key_PerfStatistics_L1DcacheLoads, kn) {
						currentKey = ffj_t_PerfStatistics_L1DcacheLoads
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PerfStatistics_L1DcacheLoadMisses, kn) {
						currentKey = ffj_t_PerfStatistics_L1DcacheLoadMisses
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PerfStatistics_L1DcacheStores, kn) {
						currentKey = ffj_t_PerfStatistics_L1DcacheStores
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PerfStatistics_L1DcacheStoreMisses, kn) {
						currentKey = ffj_t_PerfStatistics_L1DcacheStoreMisses
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PerfStatistics_L1DcachePrefetches, kn) {
						currentKey = ffj_t_PerfStatistics_L1DcachePrefetches
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PerfStatistics_L1DcachePrefetchMisses, kn) {
						currentKey = ffj_t_PerfStatistics_L1DcachePrefetchMisses
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PerfStatistics_L1IcacheLoads, kn) {
						currentKey = ffj_t_PerfStatistics_L1IcacheLoads
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PerfStatistics_L1IcacheLoadMisses, kn) {
						currentKey = ffj_t_PerfStatistics_L1IcacheLoadMisses
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PerfStatistics_L1IcachePrefetches, kn) {
						currentKey = ffj_t_PerfStatistics_L1IcachePrefetches
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PerfStatistics_L1IcachePrefetchMisses, kn) {
						currentKey = ffj_t_PerfStatistics_L1IcachePrefetchMisses
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PerfStatistics_LlcLoads, kn) {
						currentKey = ffj_t_PerfStatistics_LlcLoads
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PerfStatistics_LlcLoadMisses, kn) {
						currentKey = ffj_t_PerfStatistics_LlcLoadMisses
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PerfStatistics_LlcStores, kn) {
						currentKey = ffj_t_PerfStatistics_LlcStores
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PerfStatistics_LlcStoreMisses, kn) {
						currentKey = ffj_t_PerfStatistics_LlcStoreMisses
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PerfStatistics_LlcPrefetches, kn) {
						currentKey = ffj_t_PerfStatistics_LlcPrefetches
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PerfStatistics_LlcPrefetchMisses, kn) {
						currentKey = ffj_t_PerfStatistics_LlcPrefetchMisses
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_PerfStatistics_MinorFaults, kn) {
						currentKey = ffj_t_PerfStatistics_MinorFaults
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PerfStatistics_MajorFaults, kn) {
						currentKey = ffj_t_PerfStatistics_MajorFaults
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffj_key_PerfStatistics_NodeLoads, kn) {
						currentKey = ffj_t_PerfStatistics_NodeLoads
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PerfStatistics_NodeLoadMisses, kn) {
						currentKey = ffj_t_PerfStatistics_NodeLoadMisses
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PerfStatistics_NodeStores, kn) {
						currentKey = ffj_t_PerfStatistics_NodeStores
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PerfStatistics_NodeStoreMisses, kn) {
						currentKey = ffj_t_PerfStatistics_NodeStoreMisses
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PerfStatistics_NodePrefetches, kn) {
						currentKey = ffj_t_PerfStatistics_NodePrefetches
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PerfStatistics_NodePrefetchMisses, kn) {
						currentKey = ffj_t_PerfStatistics_NodePrefetchMisses
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_PerfStatistics_PageFaults, kn) {
						currentKey = ffj_t_PerfStatistics_PageFaults
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_PerfStatistics_RefCycles, kn) {
						currentKey = ffj_t_PerfStatistics_RefCycles
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_PerfStatistics_StalledCyclesFrontend, kn) {
						currentKey = ffj_t_PerfStatistics_StalledCyclesFrontend
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PerfStatistics_StalledCyclesBackend, kn) {
						currentKey = ffj_t_PerfStatistics_StalledCyclesBackend
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_PerfStatistics_Timestamp, kn) {
						currentKey = ffj_t_PerfStatistics_Timestamp
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PerfStatistics_TaskClock, kn) {
						currentKey = ffj_t_PerfStatistics_TaskClock
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_NodePrefetchMisses, kn) {
					currentKey = ffj_t_PerfStatistics_NodePrefetchMisses
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_NodePrefetches, kn) {
					currentKey = ffj_t_PerfStatistics_NodePrefetches
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_NodeStoreMisses, kn) {
					currentKey = ffj_t_PerfStatistics_NodeStoreMisses
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_NodeStores, kn) {
					currentKey = ffj_t_PerfStatistics_NodeStores
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_NodeLoadMisses, kn) {
					currentKey = ffj_t_PerfStatistics_NodeLoadMisses
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_NodeLoads, kn) {
					currentKey = ffj_t_PerfStatistics_NodeLoads
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_BranchLoadMisses, kn) {
					currentKey = ffj_t_PerfStatistics_BranchLoadMisses
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_BranchLoads, kn) {
					currentKey = ffj_t_PerfStatistics_BranchLoads
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_ItlbLoadMisses, kn) {
					currentKey = ffj_t_PerfStatistics_ItlbLoadMisses
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_ItlbLoads, kn) {
					currentKey = ffj_t_PerfStatistics_ItlbLoads
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_DtlbPrefetchMisses, kn) {
					currentKey = ffj_t_PerfStatistics_DtlbPrefetchMisses
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_DtlbPrefetches, kn) {
					currentKey = ffj_t_PerfStatistics_DtlbPrefetches
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_DtlbStoreMisses, kn) {
					currentKey = ffj_t_PerfStatistics_DtlbStoreMisses
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_DtlbStores, kn) {
					currentKey = ffj_t_PerfStatistics_DtlbStores
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_DtlbLoadMisses, kn) {
					currentKey = ffj_t_PerfStatistics_DtlbLoadMisses
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_DtlbLoads, kn) {
					currentKey = ffj_t_PerfStatistics_DtlbLoads
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_LlcPrefetchMisses, kn) {
					currentKey = ffj_t_PerfStatistics_LlcPrefetchMisses
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_LlcPrefetches, kn) {
					currentKey = ffj_t_PerfStatistics_LlcPrefetches
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_LlcStoreMisses, kn) {
					currentKey = ffj_t_PerfStatistics_LlcStoreMisses
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_LlcStores, kn) {
					currentKey = ffj_t_PerfStatistics_LlcStores
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_LlcLoadMisses, kn) {
					currentKey = ffj_t_PerfStatistics_LlcLoadMisses
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_LlcLoads, kn) {
					currentKey = ffj_t_PerfStatistics_LlcLoads
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_L1IcachePrefetchMisses, kn) {
					currentKey = ffj_t_PerfStatistics_L1IcachePrefetchMisses
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_L1IcachePrefetches, kn) {
					currentKey = ffj_t_PerfStatistics_L1IcachePrefetches
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_L1IcacheLoadMisses, kn) {
					currentKey = ffj_t_PerfStatistics_L1IcacheLoadMisses
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_L1IcacheLoads, kn) {
					currentKey = ffj_t_PerfStatistics_L1IcacheLoads
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_L1DcachePrefetchMisses, kn) {
					currentKey = ffj_t_PerfStatistics_L1DcachePrefetchMisses
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_L1DcachePrefetches, kn) {
					currentKey = ffj_t_PerfStatistics_L1DcachePrefetches
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_L1DcacheStoreMisses, kn) {
					currentKey = ffj_t_PerfStatistics_L1DcacheStoreMisses
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_L1DcacheStores, kn) {
					currentKey = ffj_t_PerfStatistics_L1DcacheStores
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_L1DcacheLoadMisses, kn) {
					currentKey = ffj_t_PerfStatistics_L1DcacheLoadMisses
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_L1DcacheLoads, kn) {
					currentKey = ffj_t_PerfStatistics_L1DcacheLoads
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_EmulationFaults, kn) {
					currentKey = ffj_t_PerfStatistics_EmulationFaults
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_AlignmentFaults, kn) {
					currentKey = ffj_t_PerfStatistics_AlignmentFaults
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_CpuMigrations, kn) {
					currentKey = ffj_t_PerfStatistics_CpuMigrations
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_ContextSwitches, kn) {
					currentKey = ffj_t_PerfStatistics_ContextSwitches
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_MajorFaults, kn) {
					currentKey = ffj_t_PerfStatistics_MajorFaults
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_MinorFaults, kn) {
					currentKey = ffj_t_PerfStatistics_MinorFaults
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_PageFaults, kn) {
					currentKey = ffj_t_PerfStatistics_PageFaults
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_TaskClock, kn) {
					currentKey = ffj_t_PerfStatistics_TaskClock
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_CpuClock, kn) {
					currentKey = ffj_t_PerfStatistics_CpuClock
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_RefCycles, kn) {
					currentKey = ffj_t_PerfStatistics_RefCycles
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_BusCycles, kn) {
					currentKey = ffj_t_PerfStatistics_BusCycles
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_BranchMisses, kn) {
					currentKey = ffj_t_PerfStatistics_BranchMisses
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_Branches, kn) {
					currentKey = ffj_t_PerfStatistics_Branches
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_CacheMisses, kn) {
					currentKey = ffj_t_PerfStatistics_CacheMisses
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_CacheReferences, kn) {
					currentKey = ffj_t_PerfStatistics_CacheReferences
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_Instructions, kn) {
					currentKey = ffj_t_PerfStatistics_Instructions
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_StalledCyclesBackend, kn) {
					currentKey = ffj_t_PerfStatistics_StalledCyclesBackend
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_StalledCyclesFrontend, kn) {
					currentKey = ffj_t_PerfStatistics_StalledCyclesFrontend
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_Cycles, kn) {
					currentKey = ffj_t_PerfStatistics_Cycles
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_PerfStatistics_Duration, kn) {
					currentKey = ffj_t_PerfStatistics_Duration
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_Timestamp, kn) {
					currentKey = ffj_t_PerfStatistics_Timestamp
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_PerfStatisticsno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_PerfStatistics_Timestamp:
					goto handle_Timestamp

				case ffj_t_PerfStatistics_Duration:
					goto handle_Duration

				case ffj_t_PerfStatistics_Cycles:
					goto handle_Cycles

				case ffj_t_PerfStatistics_StalledCyclesFrontend:
					goto handle_StalledCyclesFrontend

				case ffj_t_PerfStatistics_StalledCyclesBackend:
					goto handle_StalledCyclesBackend

				case ffj_t_PerfStatistics_Instructions:
					goto handle_Instructions

				case ffj_t_PerfStatistics_CacheReferences:
					goto handle_CacheReferences

				case ffj_t_PerfStatistics_CacheMisses:
					goto handle_CacheMisses

				case ffj_t_PerfStatistics_Branches:
					goto handle_Branches

				case ffj_t_PerfStatistics_BranchMisses:
					goto handle_BranchMisses

				case ffj_t_PerfStatistics_BusCycles:
					goto handle_BusCycles

				case ffj_t_PerfStatistics_RefCycles:
					goto handle_RefCycles

				case ffj_t_PerfStatistics_CpuClock:
					goto handle_CpuClock

				case ffj_t_PerfStatistics_TaskClock:
					goto handle_TaskClock

				case ffj_t_PerfStatistics_PageFaults:
					goto handle_PageFaults

				case ffj_t_PerfStatistics_MinorFaults:
					goto handle_MinorFaults

				case ffj_t_PerfStatistics_MajorFaults:
					goto handle_MajorFaults

				case ffj_t_PerfStatistics_ContextSwitches:
					goto handle_ContextSwitches

				case ffj_t_PerfStatistics_CpuMigrations:
					goto handle_CpuMigrations

				case ffj_t_PerfStatistics_AlignmentFaults:
					goto handle_AlignmentFaults

				case ffj_t_PerfStatistics_EmulationFaults:
					goto handle_EmulationFaults

				case ffj_t_PerfStatistics_L1DcacheLoads:
					goto handle_L1DcacheLoads

				case ffj_t_PerfStatistics_L1DcacheLoadMisses:
					goto handle_L1DcacheLoadMisses

				case ffj_t_PerfStatistics_L1DcacheStores:
					goto handle_L1DcacheStores

				case ffj_t_PerfStatistics_L1DcacheStoreMisses:
					goto handle_L1DcacheStoreMisses

				case ffj_t_PerfStatistics_L1DcachePrefetches:
					goto handle_L1DcachePrefetches

				case ffj_t_PerfStatistics_L1DcachePrefetchMisses:
					goto handle_L1DcachePrefetchMisses

				case ffj_t_PerfStatistics_L1IcacheLoads:
					goto handle_L1IcacheLoads

				case ffj_t_PerfStatistics_L1IcacheLoadMisses:
					goto handle_L1IcacheLoadMisses

				case ffj_t_PerfStatistics_L1IcachePrefetches:
					goto handle_L1IcachePrefetches

				case ffj_t_PerfStatistics_L1IcachePrefetchMisses:
					goto handle_L1IcachePrefetchMisses

				case ffj_t_PerfStatistics_LlcLoads:
					goto handle_LlcLoads

				case ffj_t_PerfStatistics_LlcLoadMisses:
					goto handle_LlcLoadMisses

				case ffj_t_PerfStatistics_LlcStores:
					goto handle_LlcStores

				case ffj_t_PerfStatistics_LlcStoreMisses:
					goto handle_LlcStoreMisses

				case ffj_t_PerfStatistics_LlcPrefetches:
					goto handle_LlcPrefetches

				case ffj_t_PerfStatistics_LlcPrefetchMisses:
					goto handle_LlcPrefetchMisses

				case ffj_t_PerfStatistics_DtlbLoads:
					goto handle_DtlbLoads

				case ffj_t_PerfStatistics_DtlbLoadMisses:
					goto handle_DtlbLoadMisses

				case ffj_t_PerfStatistics_DtlbStores:
					goto handle_DtlbStores

				case ffj_t_PerfStatistics_DtlbStoreMisses:
					goto handle_DtlbStoreMisses

				case ffj_t_PerfStatistics_DtlbPrefetches:
					goto handle_DtlbPrefetches

				case ffj_t_PerfStatistics_DtlbPrefetchMisses:
					goto handle_DtlbPrefetchMisses

				case ffj_t_PerfStatistics_ItlbLoads:
					goto handle_ItlbLoads

				case ffj_t_PerfStatistics_ItlbLoadMisses:
					goto handle_ItlbLoadMisses

				case ffj_t_PerfStatistics_BranchLoads:
					goto handle_BranchLoads

				case ffj_t_PerfStatistics_BranchLoadMisses:
					goto handle_BranchLoadMisses

				case ffj_t_PerfStatistics_NodeLoads:
					goto handle_NodeLoads

				case ffj_t_PerfStatistics_NodeLoadMisses:
					goto handle_NodeLoadMisses

				case ffj_t_PerfStatistics_NodeStores:
					goto handle_NodeStores

				case ffj_t_PerfStatistics_NodeStoreMisses:
					goto handle_NodeStoreMisses

				case ffj_t_PerfStatistics_NodePrefetches:
					goto handle_NodePrefetches

				case ffj_t_PerfStatistics_NodePrefetchMisses:
					goto handle_NodePrefetchMisses

				case ffj_t_PerfStatisticsno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Timestamp:

	/* handler: uj.Timestamp type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Timestamp = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Duration:

	/* handler: uj.Duration type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Duration = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Cycles:

	/* handler: uj.Cycles type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Cycles = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.Cycles = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_StalledCyclesFrontend:

	/* handler: uj.StalledCyclesFrontend type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.StalledCyclesFrontend = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.StalledCyclesFrontend = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_StalledCyclesBackend:

	/* handler: uj.StalledCyclesBackend type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.StalledCyclesBackend = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.StalledCyclesBackend = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Instructions:

	/* handler: uj.Instructions type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Instructions = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.Instructions = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CacheReferences:

	/* handler: uj.CacheReferences type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.CacheReferences = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.CacheReferences = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CacheMisses:

	/* handler: uj.CacheMisses type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.CacheMisses = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.CacheMisses = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Branches:

	/* handler: uj.Branches type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Branches = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.Branches = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_BranchMisses:

	/* handler: uj.BranchMisses type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.BranchMisses = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.BranchMisses = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_BusCycles:

	/* handler: uj.BusCycles type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.BusCycles = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.BusCycles = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RefCycles:

	/* handler: uj.RefCycles type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.RefCycles = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.RefCycles = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CpuClock:

	/* handler: uj.CpuClock type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.CpuClock = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			uj.CpuClock = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TaskClock:

	/* handler: uj.TaskClock type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.TaskClock = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			uj.TaskClock = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PageFaults:

	/* handler: uj.PageFaults type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.PageFaults = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.PageFaults = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MinorFaults:

	/* handler: uj.MinorFaults type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.MinorFaults = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.MinorFaults = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MajorFaults:

	/* handler: uj.MajorFaults type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.MajorFaults = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.MajorFaults = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ContextSwitches:

	/* handler: uj.ContextSwitches type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.ContextSwitches = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.ContextSwitches = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CpuMigrations:

	/* handler: uj.CpuMigrations type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.CpuMigrations = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.CpuMigrations = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AlignmentFaults:

	/* handler: uj.AlignmentFaults type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.AlignmentFaults = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.AlignmentFaults = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_EmulationFaults:

	/* handler: uj.EmulationFaults type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.EmulationFaults = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.EmulationFaults = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_L1DcacheLoads:

	/* handler: uj.L1DcacheLoads type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.L1DcacheLoads = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.L1DcacheLoads = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_L1DcacheLoadMisses:

	/* handler: uj.L1DcacheLoadMisses type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.L1DcacheLoadMisses = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.L1DcacheLoadMisses = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_L1DcacheStores:

	/* handler: uj.L1DcacheStores type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.L1DcacheStores = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.L1DcacheStores = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_L1DcacheStoreMisses:

	/* handler: uj.L1DcacheStoreMisses type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.L1DcacheStoreMisses = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.L1DcacheStoreMisses = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_L1DcachePrefetches:

	/* handler: uj.L1DcachePrefetches type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.L1DcachePrefetches = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.L1DcachePrefetches = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_L1DcachePrefetchMisses:

	/* handler: uj.L1DcachePrefetchMisses type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.L1DcachePrefetchMisses = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.L1DcachePrefetchMisses = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_L1IcacheLoads:

	/* handler: uj.L1IcacheLoads type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.L1IcacheLoads = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.L1IcacheLoads = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_L1IcacheLoadMisses:

	/* handler: uj.L1IcacheLoadMisses type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.L1IcacheLoadMisses = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.L1IcacheLoadMisses = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_L1IcachePrefetches:

	/* handler: uj.L1IcachePrefetches type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.L1IcachePrefetches = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.L1IcachePrefetches = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_L1IcachePrefetchMisses:

	/* handler: uj.L1IcachePrefetchMisses type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.L1IcachePrefetchMisses = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.L1IcachePrefetchMisses = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LlcLoads:

	/* handler: uj.LlcLoads type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.LlcLoads = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.LlcLoads = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LlcLoadMisses:

	/* handler: uj.LlcLoadMisses type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.LlcLoadMisses = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.LlcLoadMisses = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LlcStores:

	/* handler: uj.LlcStores type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.LlcStores = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.LlcStores = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LlcStoreMisses:

	/* handler: uj.LlcStoreMisses type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.LlcStoreMisses = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.LlcStoreMisses = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LlcPrefetches:

	/* handler: uj.LlcPrefetches type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.LlcPrefetches = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.LlcPrefetches = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LlcPrefetchMisses:

	/* handler: uj.LlcPrefetchMisses type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.LlcPrefetchMisses = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.LlcPrefetchMisses = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DtlbLoads:

	/* handler: uj.DtlbLoads type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.DtlbLoads = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.DtlbLoads = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DtlbLoadMisses:

	/* handler: uj.DtlbLoadMisses type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.DtlbLoadMisses = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.DtlbLoadMisses = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DtlbStores:

	/* handler: uj.DtlbStores type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.DtlbStores = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.DtlbStores = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DtlbStoreMisses:

	/* handler: uj.DtlbStoreMisses type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.DtlbStoreMisses = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.DtlbStoreMisses = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DtlbPrefetches:

	/* handler: uj.DtlbPrefetches type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.DtlbPrefetches = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.DtlbPrefetches = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DtlbPrefetchMisses:

	/* handler: uj.DtlbPrefetchMisses type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.DtlbPrefetchMisses = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.DtlbPrefetchMisses = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ItlbLoads:

	/* handler: uj.ItlbLoads type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.ItlbLoads = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.ItlbLoads = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ItlbLoadMisses:

	/* handler: uj.ItlbLoadMisses type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.ItlbLoadMisses = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.ItlbLoadMisses = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_BranchLoads:

	/* handler: uj.BranchLoads type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.BranchLoads = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.BranchLoads = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_BranchLoadMisses:

	/* handler: uj.BranchLoadMisses type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.BranchLoadMisses = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.BranchLoadMisses = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NodeLoads:

	/* handler: uj.NodeLoads type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.NodeLoads = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.NodeLoads = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NodeLoadMisses:

	/* handler: uj.NodeLoadMisses type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.NodeLoadMisses = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.NodeLoadMisses = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NodeStores:

	/* handler: uj.NodeStores type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.NodeStores = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.NodeStores = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NodeStoreMisses:

	/* handler: uj.NodeStoreMisses type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.NodeStoreMisses = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.NodeStoreMisses = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NodePrefetches:

	/* handler: uj.NodePrefetches type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.NodePrefetches = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.NodePrefetches = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NodePrefetchMisses:

	/* handler: uj.NodePrefetchMisses type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.NodePrefetchMisses = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.NodePrefetchMisses = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Port) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Port) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "number":`)
	fflib.FormatBits2(buf, uint64(mj.Number), 10, false)
	buf.WriteByte(',')
	if mj.Name != nil {
		if true {
			buf.WriteString(`"name":`)
			fflib.WriteJsonString(buf, string(*mj.Name))
			buf.WriteByte(',')
		}
	}
	if mj.Protocol != nil {
		if true {
			buf.WriteString(`"protocol":`)
			fflib.WriteJsonString(buf, string(*mj.Protocol))
			buf.WriteByte(',')
		}
	}
	if mj.Visibility != nil {
		if true {
			buf.WriteString(`"visibility":`)

			{

				obj, err = mj.Visibility.MarshalJSON()
				if err != nil {
					return err
				}
				buf.Write(obj)

			}
			buf.WriteByte(',')
		}
	}
	if mj.Labels != nil {
		if true {
			buf.WriteString(`"labels":`)

			{

				err = mj.Labels.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Portbase = iota
	ffj_t_Portno_such_key

	ffj_t_Port_Number

	ffj_t_Port_Name

	ffj_t_Port_Protocol

	ffj_t_Port_Visibility

	ffj_t_Port_Labels
)

var ffj_key_Port_Number = []byte("number")

var ffj_key_Port_Name = []byte("name")

var ffj_key_Port_Protocol = []byte("protocol")

var ffj_key_Port_Visibility = []byte("visibility")

var ffj_key_Port_Labels = []byte("labels")

func (uj *Port) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Port) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Portbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Portno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'l':

					if bytes.Equal(ffj_key_Port_Labels, kn) {
						currentKey = ffj_t_Port_Labels
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffj_key_Port_Number, kn) {
						currentKey = ffj_t_Port_Number
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Port_Name, kn) {
						currentKey = ffj_t_Port_Name
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_Port_Protocol, kn) {
						currentKey = ffj_t_Port_Protocol
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'v':

					if bytes.Equal(ffj_key_Port_Visibility, kn) {
						currentKey = ffj_t_Port_Visibility
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_Port_Labels, kn) {
					currentKey = ffj_t_Port_Labels
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Port_Visibility, kn) {
					currentKey = ffj_t_Port_Visibility
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Port_Protocol, kn) {
					currentKey = ffj_t_Port_Protocol
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Port_Name, kn) {
					currentKey = ffj_t_Port_Name
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Port_Number, kn) {
					currentKey = ffj_t_Port_Number
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Portno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Port_Number:
					goto handle_Number

				case ffj_t_Port_Name:
					goto handle_Name

				case ffj_t_Port_Protocol:
					goto handle_Protocol

				case ffj_t_Port_Visibility:
					goto handle_Visibility

				case ffj_t_Port_Labels:
					goto handle_Labels

				case ffj_t_Portno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Number:

	/* handler: uj.Number type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Number = uint32(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Name:

	/* handler: uj.Name type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Name = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Name = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Protocol:

	/* handler: uj.Protocol type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Protocol = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Protocol = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Visibility:

	/* handler: uj.Visibility type=mesos.DiscoveryInfo_Visibility kind=int32 quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Visibility = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		if uj.Visibility == nil {
			uj.Visibility = new(DiscoveryInfo_Visibility)
		}

		err = uj.Visibility.UnmarshalJSON(tbuf)
		if err != nil {
			return fs.WrapErr(err)
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Labels:

	/* handler: uj.Labels type=mesos.Labels kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Labels = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Labels == nil {
			uj.Labels = new(Labels)
		}

		err = uj.Labels.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Ports) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Ports) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"ports":`)
	if mj.Ports != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Ports {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Portsbase = iota
	ffj_t_Portsno_such_key

	ffj_t_Ports_Ports
)

var ffj_key_Ports_Ports = []byte("ports")

func (uj *Ports) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Ports) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Portsbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Portsno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'p':

					if bytes.Equal(ffj_key_Ports_Ports, kn) {
						currentKey = ffj_t_Ports_Ports
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_Ports_Ports, kn) {
					currentKey = ffj_t_Ports_Ports
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Portsno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Ports_Ports:
					goto handle_Ports

				case ffj_t_Portsno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Ports:

	/* handler: uj.Ports type=[]mesos.Port kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Ports = nil
		} else {

			uj.Ports = make([]Port, 0)

			wantVal := true

			for {

				var v Port

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=mesos.Port kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Ports = append(uj.Ports, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *RateLimit) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *RateLimit) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.Qps != nil {
		if true {
			buf.WriteString(`"qps":`)
			fflib.AppendFloat(buf, float64(*mj.Qps), 'g', -1, 64)
			buf.WriteByte(',')
		}
	}
	buf.WriteString(`"principal":`)
	fflib.WriteJsonString(buf, string(mj.Principal))
	buf.WriteByte(',')
	if mj.Capacity != nil {
		if true {
			buf.WriteString(`"capacity":`)
			fflib.FormatBits2(buf, uint64(*mj.Capacity), 10, false)
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_RateLimitbase = iota
	ffj_t_RateLimitno_such_key

	ffj_t_RateLimit_Qps

	ffj_t_RateLimit_Principal

	ffj_t_RateLimit_Capacity
)

var ffj_key_RateLimit_Qps = []byte("qps")

var ffj_key_RateLimit_Principal = []byte("principal")

var ffj_key_RateLimit_Capacity = []byte("capacity")

func (uj *RateLimit) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *RateLimit) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_RateLimitbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_RateLimitno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_RateLimit_Capacity, kn) {
						currentKey = ffj_t_RateLimit_Capacity
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_RateLimit_Principal, kn) {
						currentKey = ffj_t_RateLimit_Principal
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'q':

					if bytes.Equal(ffj_key_RateLimit_Qps, kn) {
						currentKey = ffj_t_RateLimit_Qps
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_RateLimit_Capacity, kn) {
					currentKey = ffj_t_RateLimit_Capacity
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_RateLimit_Principal, kn) {
					currentKey = ffj_t_RateLimit_Principal
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_RateLimit_Qps, kn) {
					currentKey = ffj_t_RateLimit_Qps
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_RateLimitno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_RateLimit_Qps:
					goto handle_Qps

				case ffj_t_RateLimit_Principal:
					goto handle_Principal

				case ffj_t_RateLimit_Capacity:
					goto handle_Capacity

				case ffj_t_RateLimitno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Qps:

	/* handler: uj.Qps type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Qps = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			uj.Qps = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Principal:

	/* handler: uj.Principal type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Principal = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Capacity:

	/* handler: uj.Capacity type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Capacity = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.Capacity = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *RateLimits) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *RateLimits) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "limits":`)
	if mj.Limits != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Limits {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte(',')
	if mj.AggregateDefaultQps != nil {
		if true {
			buf.WriteString(`"aggregate_default_qps":`)
			fflib.AppendFloat(buf, float64(*mj.AggregateDefaultQps), 'g', -1, 64)
			buf.WriteByte(',')
		}
	}
	if mj.AggregateDefaultCapacity != nil {
		if true {
			buf.WriteString(`"aggregate_default_capacity":`)
			fflib.FormatBits2(buf, uint64(*mj.AggregateDefaultCapacity), 10, false)
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_RateLimitsbase = iota
	ffj_t_RateLimitsno_such_key

	ffj_t_RateLimits_Limits

	ffj_t_RateLimits_AggregateDefaultQps

	ffj_t_RateLimits_AggregateDefaultCapacity
)

var ffj_key_RateLimits_Limits = []byte("limits")

var ffj_key_RateLimits_AggregateDefaultQps = []byte("aggregate_default_qps")

var ffj_key_RateLimits_AggregateDefaultCapacity = []byte("aggregate_default_capacity")

func (uj *RateLimits) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *RateLimits) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_RateLimitsbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_RateLimitsno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_RateLimits_AggregateDefaultQps, kn) {
						currentKey = ffj_t_RateLimits_AggregateDefaultQps
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_RateLimits_AggregateDefaultCapacity, kn) {
						currentKey = ffj_t_RateLimits_AggregateDefaultCapacity
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffj_key_RateLimits_Limits, kn) {
						currentKey = ffj_t_RateLimits_Limits
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffj_key_RateLimits_AggregateDefaultCapacity, kn) {
					currentKey = ffj_t_RateLimits_AggregateDefaultCapacity
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_RateLimits_AggregateDefaultQps, kn) {
					currentKey = ffj_t_RateLimits_AggregateDefaultQps
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_RateLimits_Limits, kn) {
					currentKey = ffj_t_RateLimits_Limits
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_RateLimitsno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_RateLimits_Limits:
					goto handle_Limits

				case ffj_t_RateLimits_AggregateDefaultQps:
					goto handle_AggregateDefaultQps

				case ffj_t_RateLimits_AggregateDefaultCapacity:
					goto handle_AggregateDefaultCapacity

				case ffj_t_RateLimitsno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Limits:

	/* handler: uj.Limits type=[]mesos.RateLimit kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Limits = nil
		} else {

			uj.Limits = make([]RateLimit, 0)

			wantVal := true

			for {

				var v RateLimit

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=mesos.RateLimit kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Limits = append(uj.Limits, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AggregateDefaultQps:

	/* handler: uj.AggregateDefaultQps type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.AggregateDefaultQps = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			uj.AggregateDefaultQps = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AggregateDefaultCapacity:

	/* handler: uj.AggregateDefaultCapacity type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.AggregateDefaultCapacity = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.AggregateDefaultCapacity = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Request) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Request) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteByte('{')
	if mj.AgentID != nil {
		if true {
			buf.WriteString(`"agent_id":`)

			{

				err = mj.AgentID.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.WriteString(`"resources":`)
	if mj.Resources != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Resources {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Requestbase = iota
	ffj_t_Requestno_such_key

	ffj_t_Request_AgentID

	ffj_t_Request_Resources
)

var ffj_key_Request_AgentID = []byte("agent_id")

var ffj_key_Request_Resources = []byte("resources")

func (uj *Request) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Request) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Requestbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Requestno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_Request_AgentID, kn) {
						currentKey = ffj_t_Request_AgentID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_Request_Resources, kn) {
						currentKey = ffj_t_Request_Resources
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_Request_Resources, kn) {
					currentKey = ffj_t_Request_Resources
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_Request_AgentID, kn) {
					currentKey = ffj_t_Request_AgentID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Requestno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Request_AgentID:
					goto handle_AgentID

				case ffj_t_Request_Resources:
					goto handle_Resources

				case ffj_t_Requestno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_AgentID:

	/* handler: uj.AgentID type=mesos.AgentID kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.AgentID = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.AgentID == nil {
			uj.AgentID = new(AgentID)
		}

		err = uj.AgentID.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Resources:

	/* handler: uj.Resources type=[]mesos.Resource kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Resources = nil
		} else {

			uj.Resources = make([]Resource, 0)

			wantVal := true

			for {

				var v Resource

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=mesos.Resource kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Resources = append(uj.Resources, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Resource) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Resource) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "name":`)
	fflib.WriteJsonString(buf, string(mj.Name))
	buf.WriteByte(',')
	if mj.Type != nil {
		if true {
			buf.WriteString(`"type":`)

			{

				obj, err = mj.Type.MarshalJSON()
				if err != nil {
					return err
				}
				buf.Write(obj)

			}
			buf.WriteByte(',')
		}
	}
	if mj.Scalar != nil {
		if true {
			buf.WriteString(`"scalar":`)

			{

				err = mj.Scalar.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.Ranges != nil {
		if true {
			buf.WriteString(`"ranges":`)

			{

				err = mj.Ranges.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.Set != nil {
		if true {
			buf.WriteString(`"set":`)

			{

				err = mj.Set.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.Role != nil {
		if true {
			buf.WriteString(`"role":`)
			fflib.WriteJsonString(buf, string(*mj.Role))
			buf.WriteByte(',')
		}
	}
	if mj.Reservation != nil {
		if true {
			buf.WriteString(`"reservation":`)

			{

				err = mj.Reservation.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.Disk != nil {
		if true {
			buf.WriteString(`"disk":`)

			{

				err = mj.Disk.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.Revocable != nil {
		if true {
			buf.WriteString(`"revocable":`)

			{

				err = mj.Revocable.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Resourcebase = iota
	ffj_t_Resourceno_such_key

	ffj_t_Resource_Name

	ffj_t_Resource_Type

	ffj_t_Resource_Scalar

	ffj_t_Resource_Ranges

	ffj_t_Resource_Set

	ffj_t_Resource_Role

	ffj_t_Resource_Reservation

	ffj_t_Resource_Disk

	ffj_t_Resource_Revocable
)

var ffj_key_Resource_Name = []byte("name")

var ffj_key_Resource_Type = []byte("type")

var ffj_key_Resource_Scalar = []byte("scalar")

var ffj_key_Resource_Ranges = []byte("ranges")

var ffj_key_Resource_Set = []byte("set")

var ffj_key_Resource_Role = []byte("role")

var ffj_key_Resource_Reservation = []byte("reservation")

var ffj_key_Resource_Disk = []byte("disk")

var ffj_key_Resource_Revocable = []byte("revocable")

func (uj *Resource) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Resource) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Resourcebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Resourceno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'd':

					if bytes.Equal(ffj_key_Resource_Disk, kn) {
						currentKey = ffj_t_Resource_Disk
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffj_key_Resource_Name, kn) {
						currentKey = ffj_t_Resource_Name
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_Resource_Ranges, kn) {
						currentKey = ffj_t_Resource_Ranges
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Resource_Role, kn) {
						currentKey = ffj_t_Resource_Role
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Resource_Reservation, kn) {
						currentKey = ffj_t_Resource_Reservation
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Resource_Revocable, kn) {
						currentKey = ffj_t_Resource_Revocable
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_Resource_Scalar, kn) {
						currentKey = ffj_t_Resource_Scalar
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Resource_Set, kn) {
						currentKey = ffj_t_Resource_Set
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_Resource_Type, kn) {
						currentKey = ffj_t_Resource_Type
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_Resource_Revocable, kn) {
					currentKey = ffj_t_Resource_Revocable
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Resource_Disk, kn) {
					currentKey = ffj_t_Resource_Disk
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Resource_Reservation, kn) {
					currentKey = ffj_t_Resource_Reservation
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Resource_Role, kn) {
					currentKey = ffj_t_Resource_Role
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Resource_Set, kn) {
					currentKey = ffj_t_Resource_Set
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Resource_Ranges, kn) {
					currentKey = ffj_t_Resource_Ranges
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Resource_Scalar, kn) {
					currentKey = ffj_t_Resource_Scalar
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Resource_Type, kn) {
					currentKey = ffj_t_Resource_Type
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Resource_Name, kn) {
					currentKey = ffj_t_Resource_Name
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Resourceno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Resource_Name:
					goto handle_Name

				case ffj_t_Resource_Type:
					goto handle_Type

				case ffj_t_Resource_Scalar:
					goto handle_Scalar

				case ffj_t_Resource_Ranges:
					goto handle_Ranges

				case ffj_t_Resource_Set:
					goto handle_Set

				case ffj_t_Resource_Role:
					goto handle_Role

				case ffj_t_Resource_Reservation:
					goto handle_Reservation

				case ffj_t_Resource_Disk:
					goto handle_Disk

				case ffj_t_Resource_Revocable:
					goto handle_Revocable

				case ffj_t_Resourceno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Name:

	/* handler: uj.Name type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Name = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Type:

	/* handler: uj.Type type=mesos.Value_Type kind=int32 quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Type = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		if uj.Type == nil {
			uj.Type = new(Value_Type)
		}

		err = uj.Type.UnmarshalJSON(tbuf)
		if err != nil {
			return fs.WrapErr(err)
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Scalar:

	/* handler: uj.Scalar type=mesos.Value_Scalar kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Scalar = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Scalar == nil {
			uj.Scalar = new(Value_Scalar)
		}

		err = uj.Scalar.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Ranges:

	/* handler: uj.Ranges type=mesos.Value_Ranges kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Ranges = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Ranges == nil {
			uj.Ranges = new(Value_Ranges)
		}

		err = uj.Ranges.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Set:

	/* handler: uj.Set type=mesos.Value_Set kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Set = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Set == nil {
			uj.Set = new(Value_Set)
		}

		err = uj.Set.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Role:

	/* handler: uj.Role type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Role = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Role = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Reservation:

	/* handler: uj.Reservation type=mesos.Resource_ReservationInfo kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Reservation = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Reservation == nil {
			uj.Reservation = new(Resource_ReservationInfo)
		}

		err = uj.Reservation.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Disk:

	/* handler: uj.Disk type=mesos.Resource_DiskInfo kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Disk = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Disk == nil {
			uj.Disk = new(Resource_DiskInfo)
		}

		err = uj.Disk.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Revocable:

	/* handler: uj.Revocable type=mesos.Resource_RevocableInfo kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Revocable = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Revocable == nil {
			uj.Revocable = new(Resource_RevocableInfo)
		}

		err = uj.Revocable.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *ResourceStatistics) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ResourceStatistics) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "timestamp":`)
	fflib.AppendFloat(buf, float64(mj.Timestamp), 'g', -1, 64)
	buf.WriteByte(',')
	if mj.Processes != nil {
		if true {
			buf.WriteString(`"processes":`)
			fflib.FormatBits2(buf, uint64(*mj.Processes), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.Threads != nil {
		if true {
			buf.WriteString(`"threads":`)
			fflib.FormatBits2(buf, uint64(*mj.Threads), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.CpusUserTimeSecs != nil {
		if true {
			buf.WriteString(`"cpus_user_time_secs":`)
			fflib.AppendFloat(buf, float64(*mj.CpusUserTimeSecs), 'g', -1, 64)
			buf.WriteByte(',')
		}
	}
	if mj.CpusSystemTimeSecs != nil {
		if true {
			buf.WriteString(`"cpus_system_time_secs":`)
			fflib.AppendFloat(buf, float64(*mj.CpusSystemTimeSecs), 'g', -1, 64)
			buf.WriteByte(',')
		}
	}
	if mj.CpusLimit != nil {
		if true {
			buf.WriteString(`"cpus_limit":`)
			fflib.AppendFloat(buf, float64(*mj.CpusLimit), 'g', -1, 64)
			buf.WriteByte(',')
		}
	}
	if mj.CpusNrPeriods != nil {
		if true {
			buf.WriteString(`"cpus_nr_periods":`)
			fflib.FormatBits2(buf, uint64(*mj.CpusNrPeriods), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.CpusNrThrottled != nil {
		if true {
			buf.WriteString(`"cpus_nr_throttled":`)
			fflib.FormatBits2(buf, uint64(*mj.CpusNrThrottled), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.CpusThrottledTimeSecs != nil {
		if true {
			buf.WriteString(`"cpus_throttled_time_secs":`)
			fflib.AppendFloat(buf, float64(*mj.CpusThrottledTimeSecs), 'g', -1, 64)
			buf.WriteByte(',')
		}
	}
	if mj.MemTotalBytes != nil {
		if true {
			buf.WriteString(`"mem_total_bytes":`)
			fflib.FormatBits2(buf, uint64(*mj.MemTotalBytes), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.MemTotalMemswBytes != nil {
		if true {
			buf.WriteString(`"mem_total_memsw_bytes":`)
			fflib.FormatBits2(buf, uint64(*mj.MemTotalMemswBytes), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.MemLimitBytes != nil {
		if true {
			buf.WriteString(`"mem_limit_bytes":`)
			fflib.FormatBits2(buf, uint64(*mj.MemLimitBytes), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.MemSoftLimitBytes != nil {
		if true {
			buf.WriteString(`"mem_soft_limit_bytes":`)
			fflib.FormatBits2(buf, uint64(*mj.MemSoftLimitBytes), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.MemFileBytes != nil {
		if true {
			buf.WriteString(`"mem_file_bytes":`)
			fflib.FormatBits2(buf, uint64(*mj.MemFileBytes), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.MemAnonBytes != nil {
		if true {
			buf.WriteString(`"mem_anon_bytes":`)
			fflib.FormatBits2(buf, uint64(*mj.MemAnonBytes), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.MemCacheBytes != nil {
		if true {
			buf.WriteString(`"mem_cache_bytes":`)
			fflib.FormatBits2(buf, uint64(*mj.MemCacheBytes), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.MemRssBytes != nil {
		if true {
			buf.WriteString(`"mem_rss_bytes":`)
			fflib.FormatBits2(buf, uint64(*mj.MemRssBytes), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.MemMappedFileBytes != nil {
		if true {
			buf.WriteString(`"mem_mapped_file_bytes":`)
			fflib.FormatBits2(buf, uint64(*mj.MemMappedFileBytes), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.MemSwapBytes != nil {
		if true {
			buf.WriteString(`"mem_swap_bytes":`)
			fflib.FormatBits2(buf, uint64(*mj.MemSwapBytes), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.MemUnevictableBytes != nil {
		if true {
			buf.WriteString(`"mem_unevictable_bytes":`)
			fflib.FormatBits2(buf, uint64(*mj.MemUnevictableBytes), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.MemLowPressureCounter != nil {
		if true {
			buf.WriteString(`"mem_low_pressure_counter":`)
			fflib.FormatBits2(buf, uint64(*mj.MemLowPressureCounter), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.MemMediumPressureCounter != nil {
		if true {
			buf.WriteString(`"mem_medium_pressure_counter":`)
			fflib.FormatBits2(buf, uint64(*mj.MemMediumPressureCounter), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.MemCriticalPressureCounter != nil {
		if true {
			buf.WriteString(`"mem_critical_pressure_counter":`)
			fflib.FormatBits2(buf, uint64(*mj.MemCriticalPressureCounter), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.DiskLimitBytes != nil {
		if true {
			buf.WriteString(`"disk_limit_bytes":`)
			fflib.FormatBits2(buf, uint64(*mj.DiskLimitBytes), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.DiskUsedBytes != nil {
		if true {
			buf.WriteString(`"disk_used_bytes":`)
			fflib.FormatBits2(buf, uint64(*mj.DiskUsedBytes), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.Perf != nil {
		if true {
			buf.WriteString(`"perf":`)

			{

				err = mj.Perf.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.NetRxPackets != nil {
		if true {
			buf.WriteString(`"net_rx_packets":`)
			fflib.FormatBits2(buf, uint64(*mj.NetRxPackets), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.NetRxBytes != nil {
		if true {
			buf.WriteString(`"net_rx_bytes":`)
			fflib.FormatBits2(buf, uint64(*mj.NetRxBytes), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.NetRxErrors != nil {
		if true {
			buf.WriteString(`"net_rx_errors":`)
			fflib.FormatBits2(buf, uint64(*mj.NetRxErrors), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.NetRxDropped != nil {
		if true {
			buf.WriteString(`"net_rx_dropped":`)
			fflib.FormatBits2(buf, uint64(*mj.NetRxDropped), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.NetTxPackets != nil {
		if true {
			buf.WriteString(`"net_tx_packets":`)
			fflib.FormatBits2(buf, uint64(*mj.NetTxPackets), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.NetTxBytes != nil {
		if true {
			buf.WriteString(`"net_tx_bytes":`)
			fflib.FormatBits2(buf, uint64(*mj.NetTxBytes), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.NetTxErrors != nil {
		if true {
			buf.WriteString(`"net_tx_errors":`)
			fflib.FormatBits2(buf, uint64(*mj.NetTxErrors), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.NetTxDropped != nil {
		if true {
			buf.WriteString(`"net_tx_dropped":`)
			fflib.FormatBits2(buf, uint64(*mj.NetTxDropped), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.NetTcpRttMicrosecsP50 != nil {
		if true {
			buf.WriteString(`"net_tcp_rtt_microsecs_p50":`)
			fflib.AppendFloat(buf, float64(*mj.NetTcpRttMicrosecsP50), 'g', -1, 64)
			buf.WriteByte(',')
		}
	}
	if mj.NetTcpRttMicrosecsP90 != nil {
		if true {
			buf.WriteString(`"net_tcp_rtt_microsecs_p90":`)
			fflib.AppendFloat(buf, float64(*mj.NetTcpRttMicrosecsP90), 'g', -1, 64)
			buf.WriteByte(',')
		}
	}
	if mj.NetTcpRttMicrosecsP95 != nil {
		if true {
			buf.WriteString(`"net_tcp_rtt_microsecs_p95":`)
			fflib.AppendFloat(buf, float64(*mj.NetTcpRttMicrosecsP95), 'g', -1, 64)
			buf.WriteByte(',')
		}
	}
	if mj.NetTcpRttMicrosecsP99 != nil {
		if true {
			buf.WriteString(`"net_tcp_rtt_microsecs_p99":`)
			fflib.AppendFloat(buf, float64(*mj.NetTcpRttMicrosecsP99), 'g', -1, 64)
			buf.WriteByte(',')
		}
	}
	if mj.NetTcpActiveConnections != nil {
		if true {
			buf.WriteString(`"net_tcp_active_connections":`)
			fflib.AppendFloat(buf, float64(*mj.NetTcpActiveConnections), 'g', -1, 64)
			buf.WriteByte(',')
		}
	}
	if mj.NetTcpTimeWaitConnections != nil {
		if true {
			buf.WriteString(`"net_tcp_time_wait_connections":`)
			fflib.AppendFloat(buf, float64(*mj.NetTcpTimeWaitConnections), 'g', -1, 64)
			buf.WriteByte(',')
		}
	}
	buf.WriteString(`"net_traffic_control_statistics":`)
	if mj.NetTrafficControlStatistics != nil {
		buf.WriteString(`[`)
		for i, v := range mj.NetTrafficControlStatistics {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte(',')
	if mj.NetSnmpStatistics != nil {
		if true {
			buf.WriteString(`"net_snmp_statistics":`)

			{

				err = mj.NetSnmpStatistics.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ResourceStatisticsbase = iota
	ffj_t_ResourceStatisticsno_such_key

	ffj_t_ResourceStatistics_Timestamp

	ffj_t_ResourceStatistics_Processes

	ffj_t_ResourceStatistics_Threads

	ffj_t_ResourceStatistics_CpusUserTimeSecs

	ffj_t_ResourceStatistics_CpusSystemTimeSecs

	ffj_t_ResourceStatistics_CpusLimit

	ffj_t_ResourceStatistics_CpusNrPeriods

	ffj_t_ResourceStatistics_CpusNrThrottled

	ffj_t_ResourceStatistics_CpusThrottledTimeSecs

	ffj_t_ResourceStatistics_MemTotalBytes

	ffj_t_ResourceStatistics_MemTotalMemswBytes

	ffj_t_ResourceStatistics_MemLimitBytes

	ffj_t_ResourceStatistics_MemSoftLimitBytes

	ffj_t_ResourceStatistics_MemFileBytes

	ffj_t_ResourceStatistics_MemAnonBytes

	ffj_t_ResourceStatistics_MemCacheBytes

	ffj_t_ResourceStatistics_MemRssBytes

	ffj_t_ResourceStatistics_MemMappedFileBytes

	ffj_t_ResourceStatistics_MemSwapBytes

	ffj_t_ResourceStatistics_MemUnevictableBytes

	ffj_t_ResourceStatistics_MemLowPressureCounter

	ffj_t_ResourceStatistics_MemMediumPressureCounter

	ffj_t_ResourceStatistics_MemCriticalPressureCounter

	ffj_t_ResourceStatistics_DiskLimitBytes

	ffj_t_ResourceStatistics_DiskUsedBytes

	ffj_t_ResourceStatistics_Perf

	ffj_t_ResourceStatistics_NetRxPackets

	ffj_t_ResourceStatistics_NetRxBytes

	ffj_t_ResourceStatistics_NetRxErrors

	ffj_t_ResourceStatistics_NetRxDropped

	ffj_t_ResourceStatistics_NetTxPackets

	ffj_t_ResourceStatistics_NetTxBytes

	ffj_t_ResourceStatistics_NetTxErrors

	ffj_t_ResourceStatistics_NetTxDropped

	ffj_t_ResourceStatistics_NetTcpRttMicrosecsP50

	ffj_t_ResourceStatistics_NetTcpRttMicrosecsP90

	ffj_t_ResourceStatistics_NetTcpRttMicrosecsP95

	ffj_t_ResourceStatistics_NetTcpRttMicrosecsP99

	ffj_t_ResourceStatistics_NetTcpActiveConnections

	ffj_t_ResourceStatistics_NetTcpTimeWaitConnections

	ffj_t_ResourceStatistics_NetTrafficControlStatistics

	ffj_t_ResourceStatistics_NetSnmpStatistics
)

var ffj_key_ResourceStatistics_Timestamp = []byte("timestamp")

var ffj_key_ResourceStatistics_Processes = []byte("processes")

var ffj_key_ResourceStatistics_Threads = []byte("threads")

var ffj_key_ResourceStatistics_CpusUserTimeSecs = []byte("cpus_user_time_secs")

var ffj_key_ResourceStatistics_CpusSystemTimeSecs = []byte("cpus_system_time_secs")

var ffj_key_ResourceStatistics_CpusLimit = []byte("cpus_limit")

var ffj_key_ResourceStatistics_CpusNrPeriods = []byte("cpus_nr_periods")

var ffj_key_ResourceStatistics_CpusNrThrottled = []byte("cpus_nr_throttled")

var ffj_key_ResourceStatistics_CpusThrottledTimeSecs = []byte("cpus_throttled_time_secs")

var ffj_key_ResourceStatistics_MemTotalBytes = []byte("mem_total_bytes")

var ffj_key_ResourceStatistics_MemTotalMemswBytes = []byte("mem_total_memsw_bytes")

var ffj_key_ResourceStatistics_MemLimitBytes = []byte("mem_limit_bytes")

var ffj_key_ResourceStatistics_MemSoftLimitBytes = []byte("mem_soft_limit_bytes")

var ffj_key_ResourceStatistics_MemFileBytes = []byte("mem_file_bytes")

var ffj_key_ResourceStatistics_MemAnonBytes = []byte("mem_anon_bytes")

var ffj_key_ResourceStatistics_MemCacheBytes = []byte("mem_cache_bytes")

var ffj_key_ResourceStatistics_MemRssBytes = []byte("mem_rss_bytes")

var ffj_key_ResourceStatistics_MemMappedFileBytes = []byte("mem_mapped_file_bytes")

var ffj_key_ResourceStatistics_MemSwapBytes = []byte("mem_swap_bytes")

var ffj_key_ResourceStatistics_MemUnevictableBytes = []byte("mem_unevictable_bytes")

var ffj_key_ResourceStatistics_MemLowPressureCounter = []byte("mem_low_pressure_counter")

var ffj_key_ResourceStatistics_MemMediumPressureCounter = []byte("mem_medium_pressure_counter")

var ffj_key_ResourceStatistics_MemCriticalPressureCounter = []byte("mem_critical_pressure_counter")

var ffj_key_ResourceStatistics_DiskLimitBytes = []byte("disk_limit_bytes")

var ffj_key_ResourceStatistics_DiskUsedBytes = []byte("disk_used_bytes")

var ffj_key_ResourceStatistics_Perf = []byte("perf")

var ffj_key_ResourceStatistics_NetRxPackets = []byte("net_rx_packets")

var ffj_key_ResourceStatistics_NetRxBytes = []byte("net_rx_bytes")

var ffj_key_ResourceStatistics_NetRxErrors = []byte("net_rx_errors")

var ffj_key_ResourceStatistics_NetRxDropped = []byte("net_rx_dropped")

var ffj_key_ResourceStatistics_NetTxPackets = []byte("net_tx_packets")

var ffj_key_ResourceStatistics_NetTxBytes = []byte("net_tx_bytes")

var ffj_key_ResourceStatistics_NetTxErrors = []byte("net_tx_errors")

var ffj_key_ResourceStatistics_NetTxDropped = []byte("net_tx_dropped")

var ffj_key_ResourceStatistics_NetTcpRttMicrosecsP50 = []byte("net_tcp_rtt_microsecs_p50")

var ffj_key_ResourceStatistics_NetTcpRttMicrosecsP90 = []byte("net_tcp_rtt_microsecs_p90")

var ffj_key_ResourceStatistics_NetTcpRttMicrosecsP95 = []byte("net_tcp_rtt_microsecs_p95")

var ffj_key_ResourceStatistics_NetTcpRttMicrosecsP99 = []byte("net_tcp_rtt_microsecs_p99")

var ffj_key_ResourceStatistics_NetTcpActiveConnections = []byte("net_tcp_active_connections")

var ffj_key_ResourceStatistics_NetTcpTimeWaitConnections = []byte("net_tcp_time_wait_connections")

var ffj_key_ResourceStatistics_NetTrafficControlStatistics = []byte("net_traffic_control_statistics")

var ffj_key_ResourceStatistics_NetSnmpStatistics = []byte("net_snmp_statistics")

func (uj *ResourceStatistics) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ResourceStatistics) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ResourceStatisticsbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ResourceStatisticsno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_ResourceStatistics_CpusUserTimeSecs, kn) {
						currentKey = ffj_t_ResourceStatistics_CpusUserTimeSecs
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ResourceStatistics_CpusSystemTimeSecs, kn) {
						currentKey = ffj_t_ResourceStatistics_CpusSystemTimeSecs
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ResourceStatistics_CpusLimit, kn) {
						currentKey = ffj_t_ResourceStatistics_CpusLimit
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ResourceStatistics_CpusNrPeriods, kn) {
						currentKey = ffj_t_ResourceStatistics_CpusNrPeriods
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ResourceStatistics_CpusNrThrottled, kn) {
						currentKey = ffj_t_ResourceStatistics_CpusNrThrottled
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ResourceStatistics_CpusThrottledTimeSecs, kn) {
						currentKey = ffj_t_ResourceStatistics_CpusThrottledTimeSecs
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffj_key_ResourceStatistics_DiskLimitBytes, kn) {
						currentKey = ffj_t_ResourceStatistics_DiskLimitBytes
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ResourceStatistics_DiskUsedBytes, kn) {
						currentKey = ffj_t_ResourceStatistics_DiskUsedBytes
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_ResourceStatistics_MemTotalBytes, kn) {
						currentKey = ffj_t_ResourceStatistics_MemTotalBytes
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ResourceStatistics_MemTotalMemswBytes, kn) {
						currentKey = ffj_t_ResourceStatistics_MemTotalMemswBytes
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ResourceStatistics_MemLimitBytes, kn) {
						currentKey = ffj_t_ResourceStatistics_MemLimitBytes
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ResourceStatistics_MemSoftLimitBytes, kn) {
						currentKey = ffj_t_ResourceStatistics_MemSoftLimitBytes
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ResourceStatistics_MemFileBytes, kn) {
						currentKey = ffj_t_ResourceStatistics_MemFileBytes
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ResourceStatistics_MemAnonBytes, kn) {
						currentKey = ffj_t_ResourceStatistics_MemAnonBytes
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ResourceStatistics_MemCacheBytes, kn) {
						currentKey = ffj_t_ResourceStatistics_MemCacheBytes
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ResourceStatistics_MemRssBytes, kn) {
						currentKey = ffj_t_ResourceStatistics_MemRssBytes
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ResourceStatistics_MemMappedFileBytes, kn) {
						currentKey = ffj_t_ResourceStatistics_MemMappedFileBytes
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ResourceStatistics_MemSwapBytes, kn) {
						currentKey = ffj_t_ResourceStatistics_MemSwapBytes
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ResourceStatistics_MemUnevictableBytes, kn) {
						currentKey = ffj_t_ResourceStatistics_MemUnevictableBytes
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ResourceStatistics_MemLowPressureCounter, kn) {
						currentKey = ffj_t_ResourceStatistics_MemLowPressureCounter
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ResourceStatistics_MemMediumPressureCounter, kn) {
						currentKey = ffj_t_ResourceStatistics_MemMediumPressureCounter
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ResourceStatistics_MemCriticalPressureCounter, kn) {
						currentKey = ffj_t_ResourceStatistics_MemCriticalPressureCounter
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffj_key_ResourceStatistics_NetRxPackets, kn) {
						currentKey = ffj_t_ResourceStatistics_NetRxPackets
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ResourceStatistics_NetRxBytes, kn) {
						currentKey = ffj_t_ResourceStatistics_NetRxBytes
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ResourceStatistics_NetRxErrors, kn) {
						currentKey = ffj_t_ResourceStatistics_NetRxErrors
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ResourceStatistics_NetRxDropped, kn) {
						currentKey = ffj_t_ResourceStatistics_NetRxDropped
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ResourceStatistics_NetTxPackets, kn) {
						currentKey = ffj_t_ResourceStatistics_NetTxPackets
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ResourceStatistics_NetTxBytes, kn) {
						currentKey = ffj_t_ResourceStatistics_NetTxBytes
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ResourceStatistics_NetTxErrors, kn) {
						currentKey = ffj_t_ResourceStatistics_NetTxErrors
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ResourceStatistics_NetTxDropped, kn) {
						currentKey = ffj_t_ResourceStatistics_NetTxDropped
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ResourceStatistics_NetTcpRttMicrosecsP50, kn) {
						currentKey = ffj_t_ResourceStatistics_NetTcpRttMicrosecsP50
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ResourceStatistics_NetTcpRttMicrosecsP90, kn) {
						currentKey = ffj_t_ResourceStatistics_NetTcpRttMicrosecsP90
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ResourceStatistics_NetTcpRttMicrosecsP95, kn) {
						currentKey = ffj_t_ResourceStatistics_NetTcpRttMicrosecsP95
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ResourceStatistics_NetTcpRttMicrosecsP99, kn) {
						currentKey = ffj_t_ResourceStatistics_NetTcpRttMicrosecsP99
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ResourceStatistics_NetTcpActiveConnections, kn) {
						currentKey = ffj_t_ResourceStatistics_NetTcpActiveConnections
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ResourceStatistics_NetTcpTimeWaitConnections, kn) {
						currentKey = ffj_t_ResourceStatistics_NetTcpTimeWaitConnections
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ResourceStatistics_NetTrafficControlStatistics, kn) {
						currentKey = ffj_t_ResourceStatistics_NetTrafficControlStatistics
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ResourceStatistics_NetSnmpStatistics, kn) {
						currentKey = ffj_t_ResourceStatistics_NetSnmpStatistics
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_ResourceStatistics_Processes, kn) {
						currentKey = ffj_t_ResourceStatistics_Processes
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ResourceStatistics_Perf, kn) {
						currentKey = ffj_t_ResourceStatistics_Perf
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_ResourceStatistics_Timestamp, kn) {
						currentKey = ffj_t_ResourceStatistics_Timestamp
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ResourceStatistics_Threads, kn) {
						currentKey = ffj_t_ResourceStatistics_Threads
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_ResourceStatistics_NetSnmpStatistics, kn) {
					currentKey = ffj_t_ResourceStatistics_NetSnmpStatistics
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResourceStatistics_NetTrafficControlStatistics, kn) {
					currentKey = ffj_t_ResourceStatistics_NetTrafficControlStatistics
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResourceStatistics_NetTcpTimeWaitConnections, kn) {
					currentKey = ffj_t_ResourceStatistics_NetTcpTimeWaitConnections
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResourceStatistics_NetTcpActiveConnections, kn) {
					currentKey = ffj_t_ResourceStatistics_NetTcpActiveConnections
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResourceStatistics_NetTcpRttMicrosecsP99, kn) {
					currentKey = ffj_t_ResourceStatistics_NetTcpRttMicrosecsP99
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResourceStatistics_NetTcpRttMicrosecsP95, kn) {
					currentKey = ffj_t_ResourceStatistics_NetTcpRttMicrosecsP95
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResourceStatistics_NetTcpRttMicrosecsP90, kn) {
					currentKey = ffj_t_ResourceStatistics_NetTcpRttMicrosecsP90
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResourceStatistics_NetTcpRttMicrosecsP50, kn) {
					currentKey = ffj_t_ResourceStatistics_NetTcpRttMicrosecsP50
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_ResourceStatistics_NetTxDropped, kn) {
					currentKey = ffj_t_ResourceStatistics_NetTxDropped
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResourceStatistics_NetTxErrors, kn) {
					currentKey = ffj_t_ResourceStatistics_NetTxErrors
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResourceStatistics_NetTxBytes, kn) {
					currentKey = ffj_t_ResourceStatistics_NetTxBytes
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResourceStatistics_NetTxPackets, kn) {
					currentKey = ffj_t_ResourceStatistics_NetTxPackets
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_ResourceStatistics_NetRxDropped, kn) {
					currentKey = ffj_t_ResourceStatistics_NetRxDropped
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResourceStatistics_NetRxErrors, kn) {
					currentKey = ffj_t_ResourceStatistics_NetRxErrors
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResourceStatistics_NetRxBytes, kn) {
					currentKey = ffj_t_ResourceStatistics_NetRxBytes
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResourceStatistics_NetRxPackets, kn) {
					currentKey = ffj_t_ResourceStatistics_NetRxPackets
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ResourceStatistics_Perf, kn) {
					currentKey = ffj_t_ResourceStatistics_Perf
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResourceStatistics_DiskUsedBytes, kn) {
					currentKey = ffj_t_ResourceStatistics_DiskUsedBytes
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResourceStatistics_DiskLimitBytes, kn) {
					currentKey = ffj_t_ResourceStatistics_DiskLimitBytes
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResourceStatistics_MemCriticalPressureCounter, kn) {
					currentKey = ffj_t_ResourceStatistics_MemCriticalPressureCounter
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResourceStatistics_MemMediumPressureCounter, kn) {
					currentKey = ffj_t_ResourceStatistics_MemMediumPressureCounter
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResourceStatistics_MemLowPressureCounter, kn) {
					currentKey = ffj_t_ResourceStatistics_MemLowPressureCounter
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResourceStatistics_MemUnevictableBytes, kn) {
					currentKey = ffj_t_ResourceStatistics_MemUnevictableBytes
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResourceStatistics_MemSwapBytes, kn) {
					currentKey = ffj_t_ResourceStatistics_MemSwapBytes
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResourceStatistics_MemMappedFileBytes, kn) {
					currentKey = ffj_t_ResourceStatistics_MemMappedFileBytes
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResourceStatistics_MemRssBytes, kn) {
					currentKey = ffj_t_ResourceStatistics_MemRssBytes
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResourceStatistics_MemCacheBytes, kn) {
					currentKey = ffj_t_ResourceStatistics_MemCacheBytes
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResourceStatistics_MemAnonBytes, kn) {
					currentKey = ffj_t_ResourceStatistics_MemAnonBytes
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResourceStatistics_MemFileBytes, kn) {
					currentKey = ffj_t_ResourceStatistics_MemFileBytes
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResourceStatistics_MemSoftLimitBytes, kn) {
					currentKey = ffj_t_ResourceStatistics_MemSoftLimitBytes
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResourceStatistics_MemLimitBytes, kn) {
					currentKey = ffj_t_ResourceStatistics_MemLimitBytes
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResourceStatistics_MemTotalMemswBytes, kn) {
					currentKey = ffj_t_ResourceStatistics_MemTotalMemswBytes
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResourceStatistics_MemTotalBytes, kn) {
					currentKey = ffj_t_ResourceStatistics_MemTotalBytes
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResourceStatistics_CpusThrottledTimeSecs, kn) {
					currentKey = ffj_t_ResourceStatistics_CpusThrottledTimeSecs
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResourceStatistics_CpusNrThrottled, kn) {
					currentKey = ffj_t_ResourceStatistics_CpusNrThrottled
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResourceStatistics_CpusNrPeriods, kn) {
					currentKey = ffj_t_ResourceStatistics_CpusNrPeriods
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResourceStatistics_CpusLimit, kn) {
					currentKey = ffj_t_ResourceStatistics_CpusLimit
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResourceStatistics_CpusSystemTimeSecs, kn) {
					currentKey = ffj_t_ResourceStatistics_CpusSystemTimeSecs
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResourceStatistics_CpusUserTimeSecs, kn) {
					currentKey = ffj_t_ResourceStatistics_CpusUserTimeSecs
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResourceStatistics_Threads, kn) {
					currentKey = ffj_t_ResourceStatistics_Threads
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResourceStatistics_Processes, kn) {
					currentKey = ffj_t_ResourceStatistics_Processes
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResourceStatistics_Timestamp, kn) {
					currentKey = ffj_t_ResourceStatistics_Timestamp
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ResourceStatisticsno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ResourceStatistics_Timestamp:
					goto handle_Timestamp

				case ffj_t_ResourceStatistics_Processes:
					goto handle_Processes

				case ffj_t_ResourceStatistics_Threads:
					goto handle_Threads

				case ffj_t_ResourceStatistics_CpusUserTimeSecs:
					goto handle_CpusUserTimeSecs

				case ffj_t_ResourceStatistics_CpusSystemTimeSecs:
					goto handle_CpusSystemTimeSecs

				case ffj_t_ResourceStatistics_CpusLimit:
					goto handle_CpusLimit

				case ffj_t_ResourceStatistics_CpusNrPeriods:
					goto handle_CpusNrPeriods

				case ffj_t_ResourceStatistics_CpusNrThrottled:
					goto handle_CpusNrThrottled

				case ffj_t_ResourceStatistics_CpusThrottledTimeSecs:
					goto handle_CpusThrottledTimeSecs

				case ffj_t_ResourceStatistics_MemTotalBytes:
					goto handle_MemTotalBytes

				case ffj_t_ResourceStatistics_MemTotalMemswBytes:
					goto handle_MemTotalMemswBytes

				case ffj_t_ResourceStatistics_MemLimitBytes:
					goto handle_MemLimitBytes

				case ffj_t_ResourceStatistics_MemSoftLimitBytes:
					goto handle_MemSoftLimitBytes

				case ffj_t_ResourceStatistics_MemFileBytes:
					goto handle_MemFileBytes

				case ffj_t_ResourceStatistics_MemAnonBytes:
					goto handle_MemAnonBytes

				case ffj_t_ResourceStatistics_MemCacheBytes:
					goto handle_MemCacheBytes

				case ffj_t_ResourceStatistics_MemRssBytes:
					goto handle_MemRssBytes

				case ffj_t_ResourceStatistics_MemMappedFileBytes:
					goto handle_MemMappedFileBytes

				case ffj_t_ResourceStatistics_MemSwapBytes:
					goto handle_MemSwapBytes

				case ffj_t_ResourceStatistics_MemUnevictableBytes:
					goto handle_MemUnevictableBytes

				case ffj_t_ResourceStatistics_MemLowPressureCounter:
					goto handle_MemLowPressureCounter

				case ffj_t_ResourceStatistics_MemMediumPressureCounter:
					goto handle_MemMediumPressureCounter

				case ffj_t_ResourceStatistics_MemCriticalPressureCounter:
					goto handle_MemCriticalPressureCounter

				case ffj_t_ResourceStatistics_DiskLimitBytes:
					goto handle_DiskLimitBytes

				case ffj_t_ResourceStatistics_DiskUsedBytes:
					goto handle_DiskUsedBytes

				case ffj_t_ResourceStatistics_Perf:
					goto handle_Perf

				case ffj_t_ResourceStatistics_NetRxPackets:
					goto handle_NetRxPackets

				case ffj_t_ResourceStatistics_NetRxBytes:
					goto handle_NetRxBytes

				case ffj_t_ResourceStatistics_NetRxErrors:
					goto handle_NetRxErrors

				case ffj_t_ResourceStatistics_NetRxDropped:
					goto handle_NetRxDropped

				case ffj_t_ResourceStatistics_NetTxPackets:
					goto handle_NetTxPackets

				case ffj_t_ResourceStatistics_NetTxBytes:
					goto handle_NetTxBytes

				case ffj_t_ResourceStatistics_NetTxErrors:
					goto handle_NetTxErrors

				case ffj_t_ResourceStatistics_NetTxDropped:
					goto handle_NetTxDropped

				case ffj_t_ResourceStatistics_NetTcpRttMicrosecsP50:
					goto handle_NetTcpRttMicrosecsP50

				case ffj_t_ResourceStatistics_NetTcpRttMicrosecsP90:
					goto handle_NetTcpRttMicrosecsP90

				case ffj_t_ResourceStatistics_NetTcpRttMicrosecsP95:
					goto handle_NetTcpRttMicrosecsP95

				case ffj_t_ResourceStatistics_NetTcpRttMicrosecsP99:
					goto handle_NetTcpRttMicrosecsP99

				case ffj_t_ResourceStatistics_NetTcpActiveConnections:
					goto handle_NetTcpActiveConnections

				case ffj_t_ResourceStatistics_NetTcpTimeWaitConnections:
					goto handle_NetTcpTimeWaitConnections

				case ffj_t_ResourceStatistics_NetTrafficControlStatistics:
					goto handle_NetTrafficControlStatistics

				case ffj_t_ResourceStatistics_NetSnmpStatistics:
					goto handle_NetSnmpStatistics

				case ffj_t_ResourceStatisticsno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Timestamp:

	/* handler: uj.Timestamp type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Timestamp = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Processes:

	/* handler: uj.Processes type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Processes = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint32(tval)
			uj.Processes = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Threads:

	/* handler: uj.Threads type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Threads = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint32(tval)
			uj.Threads = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CpusUserTimeSecs:

	/* handler: uj.CpusUserTimeSecs type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.CpusUserTimeSecs = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			uj.CpusUserTimeSecs = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CpusSystemTimeSecs:

	/* handler: uj.CpusSystemTimeSecs type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.CpusSystemTimeSecs = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			uj.CpusSystemTimeSecs = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CpusLimit:

	/* handler: uj.CpusLimit type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.CpusLimit = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			uj.CpusLimit = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CpusNrPeriods:

	/* handler: uj.CpusNrPeriods type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.CpusNrPeriods = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint32(tval)
			uj.CpusNrPeriods = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CpusNrThrottled:

	/* handler: uj.CpusNrThrottled type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.CpusNrThrottled = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint32(tval)
			uj.CpusNrThrottled = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CpusThrottledTimeSecs:

	/* handler: uj.CpusThrottledTimeSecs type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.CpusThrottledTimeSecs = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			uj.CpusThrottledTimeSecs = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MemTotalBytes:

	/* handler: uj.MemTotalBytes type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.MemTotalBytes = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.MemTotalBytes = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MemTotalMemswBytes:

	/* handler: uj.MemTotalMemswBytes type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.MemTotalMemswBytes = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.MemTotalMemswBytes = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MemLimitBytes:

	/* handler: uj.MemLimitBytes type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.MemLimitBytes = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.MemLimitBytes = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MemSoftLimitBytes:

	/* handler: uj.MemSoftLimitBytes type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.MemSoftLimitBytes = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.MemSoftLimitBytes = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MemFileBytes:

	/* handler: uj.MemFileBytes type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.MemFileBytes = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.MemFileBytes = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MemAnonBytes:

	/* handler: uj.MemAnonBytes type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.MemAnonBytes = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.MemAnonBytes = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MemCacheBytes:

	/* handler: uj.MemCacheBytes type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.MemCacheBytes = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.MemCacheBytes = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MemRssBytes:

	/* handler: uj.MemRssBytes type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.MemRssBytes = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.MemRssBytes = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MemMappedFileBytes:

	/* handler: uj.MemMappedFileBytes type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.MemMappedFileBytes = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.MemMappedFileBytes = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MemSwapBytes:

	/* handler: uj.MemSwapBytes type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.MemSwapBytes = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.MemSwapBytes = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MemUnevictableBytes:

	/* handler: uj.MemUnevictableBytes type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.MemUnevictableBytes = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.MemUnevictableBytes = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MemLowPressureCounter:

	/* handler: uj.MemLowPressureCounter type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.MemLowPressureCounter = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.MemLowPressureCounter = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MemMediumPressureCounter:

	/* handler: uj.MemMediumPressureCounter type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.MemMediumPressureCounter = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.MemMediumPressureCounter = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MemCriticalPressureCounter:

	/* handler: uj.MemCriticalPressureCounter type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.MemCriticalPressureCounter = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.MemCriticalPressureCounter = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DiskLimitBytes:

	/* handler: uj.DiskLimitBytes type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.DiskLimitBytes = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.DiskLimitBytes = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DiskUsedBytes:

	/* handler: uj.DiskUsedBytes type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.DiskUsedBytes = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.DiskUsedBytes = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Perf:

	/* handler: uj.Perf type=mesos.PerfStatistics kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Perf = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Perf == nil {
			uj.Perf = new(PerfStatistics)
		}

		err = uj.Perf.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NetRxPackets:

	/* handler: uj.NetRxPackets type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.NetRxPackets = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.NetRxPackets = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NetRxBytes:

	/* handler: uj.NetRxBytes type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.NetRxBytes = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.NetRxBytes = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NetRxErrors:

	/* handler: uj.NetRxErrors type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.NetRxErrors = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.NetRxErrors = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NetRxDropped:

	/* handler: uj.NetRxDropped type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.NetRxDropped = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.NetRxDropped = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NetTxPackets:

	/* handler: uj.NetTxPackets type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.NetTxPackets = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.NetTxPackets = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NetTxBytes:

	/* handler: uj.NetTxBytes type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.NetTxBytes = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.NetTxBytes = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NetTxErrors:

	/* handler: uj.NetTxErrors type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.NetTxErrors = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.NetTxErrors = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NetTxDropped:

	/* handler: uj.NetTxDropped type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.NetTxDropped = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.NetTxDropped = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NetTcpRttMicrosecsP50:

	/* handler: uj.NetTcpRttMicrosecsP50 type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.NetTcpRttMicrosecsP50 = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			uj.NetTcpRttMicrosecsP50 = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NetTcpRttMicrosecsP90:

	/* handler: uj.NetTcpRttMicrosecsP90 type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.NetTcpRttMicrosecsP90 = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			uj.NetTcpRttMicrosecsP90 = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NetTcpRttMicrosecsP95:

	/* handler: uj.NetTcpRttMicrosecsP95 type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.NetTcpRttMicrosecsP95 = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			uj.NetTcpRttMicrosecsP95 = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NetTcpRttMicrosecsP99:

	/* handler: uj.NetTcpRttMicrosecsP99 type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.NetTcpRttMicrosecsP99 = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			uj.NetTcpRttMicrosecsP99 = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NetTcpActiveConnections:

	/* handler: uj.NetTcpActiveConnections type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.NetTcpActiveConnections = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			uj.NetTcpActiveConnections = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NetTcpTimeWaitConnections:

	/* handler: uj.NetTcpTimeWaitConnections type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.NetTcpTimeWaitConnections = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			uj.NetTcpTimeWaitConnections = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NetTrafficControlStatistics:

	/* handler: uj.NetTrafficControlStatistics type=[]mesos.TrafficControlStatistics kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.NetTrafficControlStatistics = nil
		} else {

			uj.NetTrafficControlStatistics = make([]TrafficControlStatistics, 0)

			wantVal := true

			for {

				var v TrafficControlStatistics

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=mesos.TrafficControlStatistics kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.NetTrafficControlStatistics = append(uj.NetTrafficControlStatistics, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NetSnmpStatistics:

	/* handler: uj.NetSnmpStatistics type=mesos.SNMPStatistics kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.NetSnmpStatistics = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.NetSnmpStatistics == nil {
			uj.NetSnmpStatistics = new(SNMPStatistics)
		}

		err = uj.NetSnmpStatistics.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *ResourceUsage) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ResourceUsage) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"executors":`)
	if mj.Executors != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Executors {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"total":`)
	if mj.Total != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Total {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ResourceUsagebase = iota
	ffj_t_ResourceUsageno_such_key

	ffj_t_ResourceUsage_Executors

	ffj_t_ResourceUsage_Total
)

var ffj_key_ResourceUsage_Executors = []byte("executors")

var ffj_key_ResourceUsage_Total = []byte("total")

func (uj *ResourceUsage) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ResourceUsage) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ResourceUsagebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ResourceUsageno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'e':

					if bytes.Equal(ffj_key_ResourceUsage_Executors, kn) {
						currentKey = ffj_t_ResourceUsage_Executors
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_ResourceUsage_Total, kn) {
						currentKey = ffj_t_ResourceUsage_Total
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_ResourceUsage_Total, kn) {
					currentKey = ffj_t_ResourceUsage_Total
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResourceUsage_Executors, kn) {
					currentKey = ffj_t_ResourceUsage_Executors
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ResourceUsageno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ResourceUsage_Executors:
					goto handle_Executors

				case ffj_t_ResourceUsage_Total:
					goto handle_Total

				case ffj_t_ResourceUsageno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Executors:

	/* handler: uj.Executors type=[]mesos.ResourceUsage_Executor kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Executors = nil
		} else {

			uj.Executors = make([]ResourceUsage_Executor, 0)

			wantVal := true

			for {

				var v ResourceUsage_Executor

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=mesos.ResourceUsage_Executor kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Executors = append(uj.Executors, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Total:

	/* handler: uj.Total type=[]mesos.Resource kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Total = nil
		} else {

			uj.Total = make([]Resource, 0)

			wantVal := true

			for {

				var v Resource

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=mesos.Resource kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Total = append(uj.Total, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *ResourceUsage_Executor) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ResourceUsage_Executor) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"executor_info":`)

	{

		err = mj.ExecutorInfo.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteString(`,"allocated":`)
	if mj.Allocated != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Allocated {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte(',')
	if mj.Statistics != nil {
		if true {
			buf.WriteString(`"statistics":`)

			{

				err = mj.Statistics.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.WriteString(`"container_id":`)

	{

		err = mj.ContainerID.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ResourceUsage_Executorbase = iota
	ffj_t_ResourceUsage_Executorno_such_key

	ffj_t_ResourceUsage_Executor_ExecutorInfo

	ffj_t_ResourceUsage_Executor_Allocated

	ffj_t_ResourceUsage_Executor_Statistics

	ffj_t_ResourceUsage_Executor_ContainerID
)

var ffj_key_ResourceUsage_Executor_ExecutorInfo = []byte("executor_info")

var ffj_key_ResourceUsage_Executor_Allocated = []byte("allocated")

var ffj_key_ResourceUsage_Executor_Statistics = []byte("statistics")

var ffj_key_ResourceUsage_Executor_ContainerID = []byte("container_id")

func (uj *ResourceUsage_Executor) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ResourceUsage_Executor) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ResourceUsage_Executorbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ResourceUsage_Executorno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_ResourceUsage_Executor_Allocated, kn) {
						currentKey = ffj_t_ResourceUsage_Executor_Allocated
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffj_key_ResourceUsage_Executor_ContainerID, kn) {
						currentKey = ffj_t_ResourceUsage_Executor_ContainerID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffj_key_ResourceUsage_Executor_ExecutorInfo, kn) {
						currentKey = ffj_t_ResourceUsage_Executor_ExecutorInfo
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_ResourceUsage_Executor_Statistics, kn) {
						currentKey = ffj_t_ResourceUsage_Executor_Statistics
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffj_key_ResourceUsage_Executor_ContainerID, kn) {
					currentKey = ffj_t_ResourceUsage_Executor_ContainerID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResourceUsage_Executor_Statistics, kn) {
					currentKey = ffj_t_ResourceUsage_Executor_Statistics
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ResourceUsage_Executor_Allocated, kn) {
					currentKey = ffj_t_ResourceUsage_Executor_Allocated
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_ResourceUsage_Executor_ExecutorInfo, kn) {
					currentKey = ffj_t_ResourceUsage_Executor_ExecutorInfo
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ResourceUsage_Executorno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ResourceUsage_Executor_ExecutorInfo:
					goto handle_ExecutorInfo

				case ffj_t_ResourceUsage_Executor_Allocated:
					goto handle_Allocated

				case ffj_t_ResourceUsage_Executor_Statistics:
					goto handle_Statistics

				case ffj_t_ResourceUsage_Executor_ContainerID:
					goto handle_ContainerID

				case ffj_t_ResourceUsage_Executorno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ExecutorInfo:

	/* handler: uj.ExecutorInfo type=mesos.ExecutorInfo kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.ExecutorInfo.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Allocated:

	/* handler: uj.Allocated type=[]mesos.Resource kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Allocated = nil
		} else {

			uj.Allocated = make([]Resource, 0)

			wantVal := true

			for {

				var v Resource

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=mesos.Resource kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Allocated = append(uj.Allocated, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Statistics:

	/* handler: uj.Statistics type=mesos.ResourceStatistics kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Statistics = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Statistics == nil {
			uj.Statistics = new(ResourceStatistics)
		}

		err = uj.Statistics.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ContainerID:

	/* handler: uj.ContainerID type=mesos.ContainerID kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.ContainerID.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Resource_DiskInfo) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Resource_DiskInfo) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.Persistence != nil {
		if true {
			buf.WriteString(`"persistence":`)

			{

				err = mj.Persistence.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.Volume != nil {
		if true {
			buf.WriteString(`"volume":`)

			{

				err = mj.Volume.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.Source != nil {
		if true {
			buf.WriteString(`"source":`)

			{

				err = mj.Source.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Resource_DiskInfobase = iota
	ffj_t_Resource_DiskInfono_such_key

	ffj_t_Resource_DiskInfo_Persistence

	ffj_t_Resource_DiskInfo_Volume

	ffj_t_Resource_DiskInfo_Source
)

var ffj_key_Resource_DiskInfo_Persistence = []byte("persistence")

var ffj_key_Resource_DiskInfo_Volume = []byte("volume")

var ffj_key_Resource_DiskInfo_Source = []byte("source")

func (uj *Resource_DiskInfo) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Resource_DiskInfo) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Resource_DiskInfobase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Resource_DiskInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'p':

					if bytes.Equal(ffj_key_Resource_DiskInfo_Persistence, kn) {
						currentKey = ffj_t_Resource_DiskInfo_Persistence
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_Resource_DiskInfo_Source, kn) {
						currentKey = ffj_t_Resource_DiskInfo_Source
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'v':

					if bytes.Equal(ffj_key_Resource_DiskInfo_Volume, kn) {
						currentKey = ffj_t_Resource_DiskInfo_Volume
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_Resource_DiskInfo_Source, kn) {
					currentKey = ffj_t_Resource_DiskInfo_Source
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Resource_DiskInfo_Volume, kn) {
					currentKey = ffj_t_Resource_DiskInfo_Volume
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Resource_DiskInfo_Persistence, kn) {
					currentKey = ffj_t_Resource_DiskInfo_Persistence
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Resource_DiskInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Resource_DiskInfo_Persistence:
					goto handle_Persistence

				case ffj_t_Resource_DiskInfo_Volume:
					goto handle_Volume

				case ffj_t_Resource_DiskInfo_Source:
					goto handle_Source

				case ffj_t_Resource_DiskInfono_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Persistence:

	/* handler: uj.Persistence type=mesos.Resource_DiskInfo_Persistence kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Persistence = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Persistence == nil {
			uj.Persistence = new(Resource_DiskInfo_Persistence)
		}

		err = uj.Persistence.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Volume:

	/* handler: uj.Volume type=mesos.Volume kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Volume = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Volume == nil {
			uj.Volume = new(Volume)
		}

		err = uj.Volume.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Source:

	/* handler: uj.Source type=mesos.Resource_DiskInfo_Source kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Source = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Source == nil {
			uj.Source = new(Resource_DiskInfo_Source)
		}

		err = uj.Source.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Resource_DiskInfo_Persistence) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Resource_DiskInfo_Persistence) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "id":`)
	fflib.WriteJsonString(buf, string(mj.ID))
	buf.WriteByte(',')
	if mj.Principal != nil {
		if true {
			buf.WriteString(`"principal":`)
			fflib.WriteJsonString(buf, string(*mj.Principal))
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Resource_DiskInfo_Persistencebase = iota
	ffj_t_Resource_DiskInfo_Persistenceno_such_key

	ffj_t_Resource_DiskInfo_Persistence_ID

	ffj_t_Resource_DiskInfo_Persistence_Principal
)

var ffj_key_Resource_DiskInfo_Persistence_ID = []byte("id")

var ffj_key_Resource_DiskInfo_Persistence_Principal = []byte("principal")

func (uj *Resource_DiskInfo_Persistence) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Resource_DiskInfo_Persistence) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Resource_DiskInfo_Persistencebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Resource_DiskInfo_Persistenceno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'i':

					if bytes.Equal(ffj_key_Resource_DiskInfo_Persistence_ID, kn) {
						currentKey = ffj_t_Resource_DiskInfo_Persistence_ID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_Resource_DiskInfo_Persistence_Principal, kn) {
						currentKey = ffj_t_Resource_DiskInfo_Persistence_Principal
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_Resource_DiskInfo_Persistence_Principal, kn) {
					currentKey = ffj_t_Resource_DiskInfo_Persistence_Principal
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Resource_DiskInfo_Persistence_ID, kn) {
					currentKey = ffj_t_Resource_DiskInfo_Persistence_ID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Resource_DiskInfo_Persistenceno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Resource_DiskInfo_Persistence_ID:
					goto handle_ID

				case ffj_t_Resource_DiskInfo_Persistence_Principal:
					goto handle_Principal

				case ffj_t_Resource_DiskInfo_Persistenceno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ID:

	/* handler: uj.ID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.ID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Principal:

	/* handler: uj.Principal type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Principal = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Principal = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Resource_DiskInfo_Source) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Resource_DiskInfo_Source) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.Type != nil {
		if true {
			buf.WriteString(`"type":`)

			{

				obj, err = mj.Type.MarshalJSON()
				if err != nil {
					return err
				}
				buf.Write(obj)

			}
			buf.WriteByte(',')
		}
	}
	if mj.Path != nil {
		if true {
			buf.WriteString(`"path":`)

			{

				err = mj.Path.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.Mount != nil {
		if true {
			buf.WriteString(`"mount":`)

			{

				err = mj.Mount.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Resource_DiskInfo_Sourcebase = iota
	ffj_t_Resource_DiskInfo_Sourceno_such_key

	ffj_t_Resource_DiskInfo_Source_Type

	ffj_t_Resource_DiskInfo_Source_Path

	ffj_t_Resource_DiskInfo_Source_Mount
)

var ffj_key_Resource_DiskInfo_Source_Type = []byte("type")

var ffj_key_Resource_DiskInfo_Source_Path = []byte("path")

var ffj_key_Resource_DiskInfo_Source_Mount = []byte("mount")

func (uj *Resource_DiskInfo_Source) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Resource_DiskInfo_Source) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Resource_DiskInfo_Sourcebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Resource_DiskInfo_Sourceno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'm':

					if bytes.Equal(ffj_key_Resource_DiskInfo_Source_Mount, kn) {
						currentKey = ffj_t_Resource_DiskInfo_Source_Mount
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_Resource_DiskInfo_Source_Path, kn) {
						currentKey = ffj_t_Resource_DiskInfo_Source_Path
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_Resource_DiskInfo_Source_Type, kn) {
						currentKey = ffj_t_Resource_DiskInfo_Source_Type
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_Resource_DiskInfo_Source_Mount, kn) {
					currentKey = ffj_t_Resource_DiskInfo_Source_Mount
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Resource_DiskInfo_Source_Path, kn) {
					currentKey = ffj_t_Resource_DiskInfo_Source_Path
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Resource_DiskInfo_Source_Type, kn) {
					currentKey = ffj_t_Resource_DiskInfo_Source_Type
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Resource_DiskInfo_Sourceno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Resource_DiskInfo_Source_Type:
					goto handle_Type

				case ffj_t_Resource_DiskInfo_Source_Path:
					goto handle_Path

				case ffj_t_Resource_DiskInfo_Source_Mount:
					goto handle_Mount

				case ffj_t_Resource_DiskInfo_Sourceno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Type:

	/* handler: uj.Type type=mesos.Resource_DiskInfo_Source_Type kind=int32 quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Type = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		if uj.Type == nil {
			uj.Type = new(Resource_DiskInfo_Source_Type)
		}

		err = uj.Type.UnmarshalJSON(tbuf)
		if err != nil {
			return fs.WrapErr(err)
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Path:

	/* handler: uj.Path type=mesos.Resource_DiskInfo_Source_Path kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Path = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Path == nil {
			uj.Path = new(Resource_DiskInfo_Source_Path)
		}

		err = uj.Path.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Mount:

	/* handler: uj.Mount type=mesos.Resource_DiskInfo_Source_Mount kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Mount = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Mount == nil {
			uj.Mount = new(Resource_DiskInfo_Source_Mount)
		}

		err = uj.Mount.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Resource_DiskInfo_Source_Mount) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Resource_DiskInfo_Source_Mount) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"root":`)
	fflib.WriteJsonString(buf, string(mj.Root))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Resource_DiskInfo_Source_Mountbase = iota
	ffj_t_Resource_DiskInfo_Source_Mountno_such_key

	ffj_t_Resource_DiskInfo_Source_Mount_Root
)

var ffj_key_Resource_DiskInfo_Source_Mount_Root = []byte("root")

func (uj *Resource_DiskInfo_Source_Mount) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Resource_DiskInfo_Source_Mount) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Resource_DiskInfo_Source_Mountbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Resource_DiskInfo_Source_Mountno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'r':

					if bytes.Equal(ffj_key_Resource_DiskInfo_Source_Mount_Root, kn) {
						currentKey = ffj_t_Resource_DiskInfo_Source_Mount_Root
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_Resource_DiskInfo_Source_Mount_Root, kn) {
					currentKey = ffj_t_Resource_DiskInfo_Source_Mount_Root
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Resource_DiskInfo_Source_Mountno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Resource_DiskInfo_Source_Mount_Root:
					goto handle_Root

				case ffj_t_Resource_DiskInfo_Source_Mountno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Root:

	/* handler: uj.Root type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Root = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Resource_DiskInfo_Source_Path) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Resource_DiskInfo_Source_Path) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"root":`)
	fflib.WriteJsonString(buf, string(mj.Root))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Resource_DiskInfo_Source_Pathbase = iota
	ffj_t_Resource_DiskInfo_Source_Pathno_such_key

	ffj_t_Resource_DiskInfo_Source_Path_Root
)

var ffj_key_Resource_DiskInfo_Source_Path_Root = []byte("root")

func (uj *Resource_DiskInfo_Source_Path) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Resource_DiskInfo_Source_Path) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Resource_DiskInfo_Source_Pathbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Resource_DiskInfo_Source_Pathno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'r':

					if bytes.Equal(ffj_key_Resource_DiskInfo_Source_Path_Root, kn) {
						currentKey = ffj_t_Resource_DiskInfo_Source_Path_Root
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_Resource_DiskInfo_Source_Path_Root, kn) {
					currentKey = ffj_t_Resource_DiskInfo_Source_Path_Root
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Resource_DiskInfo_Source_Pathno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Resource_DiskInfo_Source_Path_Root:
					goto handle_Root

				case ffj_t_Resource_DiskInfo_Source_Pathno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Root:

	/* handler: uj.Root type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Root = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Resource_ReservationInfo) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Resource_ReservationInfo) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.Principal != nil {
		if true {
			buf.WriteString(`"principal":`)
			fflib.WriteJsonString(buf, string(*mj.Principal))
			buf.WriteByte(',')
		}
	}
	if mj.Labels != nil {
		if true {
			buf.WriteString(`"labels":`)

			{

				err = mj.Labels.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Resource_ReservationInfobase = iota
	ffj_t_Resource_ReservationInfono_such_key

	ffj_t_Resource_ReservationInfo_Principal

	ffj_t_Resource_ReservationInfo_Labels
)

var ffj_key_Resource_ReservationInfo_Principal = []byte("principal")

var ffj_key_Resource_ReservationInfo_Labels = []byte("labels")

func (uj *Resource_ReservationInfo) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Resource_ReservationInfo) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Resource_ReservationInfobase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Resource_ReservationInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'l':

					if bytes.Equal(ffj_key_Resource_ReservationInfo_Labels, kn) {
						currentKey = ffj_t_Resource_ReservationInfo_Labels
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_Resource_ReservationInfo_Principal, kn) {
						currentKey = ffj_t_Resource_ReservationInfo_Principal
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_Resource_ReservationInfo_Labels, kn) {
					currentKey = ffj_t_Resource_ReservationInfo_Labels
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Resource_ReservationInfo_Principal, kn) {
					currentKey = ffj_t_Resource_ReservationInfo_Principal
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Resource_ReservationInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Resource_ReservationInfo_Principal:
					goto handle_Principal

				case ffj_t_Resource_ReservationInfo_Labels:
					goto handle_Labels

				case ffj_t_Resource_ReservationInfono_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Principal:

	/* handler: uj.Principal type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Principal = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Principal = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Labels:

	/* handler: uj.Labels type=mesos.Labels kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Labels = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Labels == nil {
			uj.Labels = new(Labels)
		}

		err = uj.Labels.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Resource_RevocableInfo) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Resource_RevocableInfo) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{}`)
	return nil
}

const (
	ffj_t_Resource_RevocableInfobase = iota
	ffj_t_Resource_RevocableInfono_such_key
)

func (uj *Resource_RevocableInfo) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Resource_RevocableInfo) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Resource_RevocableInfobase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Resource_RevocableInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				}

				currentKey = ffj_t_Resource_RevocableInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Resource_RevocableInfono_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *SNMPStatistics) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *SNMPStatistics) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.IpStats != nil {
		if true {
			buf.WriteString(`"ip_stats":`)

			{

				err = mj.IpStats.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.IcmpStats != nil {
		if true {
			buf.WriteString(`"icmp_stats":`)

			{

				err = mj.IcmpStats.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.TcpStats != nil {
		if true {
			buf.WriteString(`"tcp_stats":`)

			{

				err = mj.TcpStats.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.UdpStats != nil {
		if true {
			buf.WriteString(`"udp_stats":`)

			{

				err = mj.UdpStats.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_SNMPStatisticsbase = iota
	ffj_t_SNMPStatisticsno_such_key

	ffj_t_SNMPStatistics_IpStats

	ffj_t_SNMPStatistics_IcmpStats

	ffj_t_SNMPStatistics_TcpStats

	ffj_t_SNMPStatistics_UdpStats
)

var ffj_key_SNMPStatistics_IpStats = []byte("ip_stats")

var ffj_key_SNMPStatistics_IcmpStats = []byte("icmp_stats")

var ffj_key_SNMPStatistics_TcpStats = []byte("tcp_stats")

var ffj_key_SNMPStatistics_UdpStats = []byte("udp_stats")

func (uj *SNMPStatistics) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *SNMPStatistics) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_SNMPStatisticsbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_SNMPStatisticsno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'i':

					if bytes.Equal(ffj_key_SNMPStatistics_IpStats, kn) {
						currentKey = ffj_t_SNMPStatistics_IpStats
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_SNMPStatistics_IcmpStats, kn) {
						currentKey = ffj_t_SNMPStatistics_IcmpStats
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_SNMPStatistics_TcpStats, kn) {
						currentKey = ffj_t_SNMPStatistics_TcpStats
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffj_key_SNMPStatistics_UdpStats, kn) {
						currentKey = ffj_t_SNMPStatistics_UdpStats
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_SNMPStatistics_UdpStats, kn) {
					currentKey = ffj_t_SNMPStatistics_UdpStats
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_SNMPStatistics_TcpStats, kn) {
					currentKey = ffj_t_SNMPStatistics_TcpStats
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_SNMPStatistics_IcmpStats, kn) {
					currentKey = ffj_t_SNMPStatistics_IcmpStats
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_SNMPStatistics_IpStats, kn) {
					currentKey = ffj_t_SNMPStatistics_IpStats
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_SNMPStatisticsno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_SNMPStatistics_IpStats:
					goto handle_IpStats

				case ffj_t_SNMPStatistics_IcmpStats:
					goto handle_IcmpStats

				case ffj_t_SNMPStatistics_TcpStats:
					goto handle_TcpStats

				case ffj_t_SNMPStatistics_UdpStats:
					goto handle_UdpStats

				case ffj_t_SNMPStatisticsno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_IpStats:

	/* handler: uj.IpStats type=mesos.IpStatistics kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.IpStats = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.IpStats == nil {
			uj.IpStats = new(IpStatistics)
		}

		err = uj.IpStats.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_IcmpStats:

	/* handler: uj.IcmpStats type=mesos.IcmpStatistics kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.IcmpStats = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.IcmpStats == nil {
			uj.IcmpStats = new(IcmpStatistics)
		}

		err = uj.IcmpStats.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TcpStats:

	/* handler: uj.TcpStats type=mesos.TcpStatistics kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.TcpStats = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.TcpStats == nil {
			uj.TcpStats = new(TcpStatistics)
		}

		err = uj.TcpStats.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_UdpStats:

	/* handler: uj.UdpStats type=mesos.UdpStatistics kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.UdpStats = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.UdpStats == nil {
			uj.UdpStats = new(UdpStatistics)
		}

		err = uj.UdpStats.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *TaskID) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *TaskID) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"value":`)
	fflib.WriteJsonString(buf, string(mj.Value))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_TaskIDbase = iota
	ffj_t_TaskIDno_such_key

	ffj_t_TaskID_Value
)

var ffj_key_TaskID_Value = []byte("value")

func (uj *TaskID) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *TaskID) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_TaskIDbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_TaskIDno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'v':

					if bytes.Equal(ffj_key_TaskID_Value, kn) {
						currentKey = ffj_t_TaskID_Value
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_TaskID_Value, kn) {
					currentKey = ffj_t_TaskID_Value
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_TaskIDno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_TaskID_Value:
					goto handle_Value

				case ffj_t_TaskIDno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Value:

	/* handler: uj.Value type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Value = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *TaskInfo) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *TaskInfo) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "name":`)
	fflib.WriteJsonString(buf, string(mj.Name))
	buf.WriteString(`,"task_id":`)

	{

		err = mj.TaskID.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteString(`,"agent_id":`)

	{

		err = mj.AgentID.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteString(`,"resources":`)
	if mj.Resources != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Resources {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte(',')
	if mj.Executor != nil {
		if true {
			buf.WriteString(`"executor":`)

			{

				err = mj.Executor.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.Command != nil {
		if true {
			buf.WriteString(`"command":`)

			{

				err = mj.Command.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.Container != nil {
		if true {
			buf.WriteString(`"container":`)

			{

				err = mj.Container.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if len(mj.Data) != 0 {
		buf.WriteString(`"data":`)
		if mj.Data != nil {
			buf.WriteString(`"`)
			{
				enc := base64.NewEncoder(base64.StdEncoding, buf)
				enc.Write(reflect.Indirect(reflect.ValueOf(mj.Data)).Bytes())
				enc.Close()
			}
			buf.WriteString(`"`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if mj.HealthCheck != nil {
		if true {
			buf.WriteString(`"health_check":`)

			{

				err = mj.HealthCheck.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.Labels != nil {
		if true {
			buf.WriteString(`"labels":`)

			{

				err = mj.Labels.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.Discovery != nil {
		if true {
			buf.WriteString(`"discovery":`)

			{

				err = mj.Discovery.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_TaskInfobase = iota
	ffj_t_TaskInfono_such_key

	ffj_t_TaskInfo_Name

	ffj_t_TaskInfo_TaskID

	ffj_t_TaskInfo_AgentID

	ffj_t_TaskInfo_Resources

	ffj_t_TaskInfo_Executor

	ffj_t_TaskInfo_Command

	ffj_t_TaskInfo_Container

	ffj_t_TaskInfo_Data

	ffj_t_TaskInfo_HealthCheck

	ffj_t_TaskInfo_Labels

	ffj_t_TaskInfo_Discovery
)

var ffj_key_TaskInfo_Name = []byte("name")

var ffj_key_TaskInfo_TaskID = []byte("task_id")

var ffj_key_TaskInfo_AgentID = []byte("agent_id")

var ffj_key_TaskInfo_Resources = []byte("resources")

var ffj_key_TaskInfo_Executor = []byte("executor")

var ffj_key_TaskInfo_Command = []byte("command")

var ffj_key_TaskInfo_Container = []byte("container")

var ffj_key_TaskInfo_Data = []byte("data")

var ffj_key_TaskInfo_HealthCheck = []byte("health_check")

var ffj_key_TaskInfo_Labels = []byte("labels")

var ffj_key_TaskInfo_Discovery = []byte("discovery")

func (uj *TaskInfo) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *TaskInfo) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_TaskInfobase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_TaskInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_TaskInfo_AgentID, kn) {
						currentKey = ffj_t_TaskInfo_AgentID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffj_key_TaskInfo_Command, kn) {
						currentKey = ffj_t_TaskInfo_Command
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_TaskInfo_Container, kn) {
						currentKey = ffj_t_TaskInfo_Container
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffj_key_TaskInfo_Data, kn) {
						currentKey = ffj_t_TaskInfo_Data
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_TaskInfo_Discovery, kn) {
						currentKey = ffj_t_TaskInfo_Discovery
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffj_key_TaskInfo_Executor, kn) {
						currentKey = ffj_t_TaskInfo_Executor
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'h':

					if bytes.Equal(ffj_key_TaskInfo_HealthCheck, kn) {
						currentKey = ffj_t_TaskInfo_HealthCheck
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffj_key_TaskInfo_Labels, kn) {
						currentKey = ffj_t_TaskInfo_Labels
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffj_key_TaskInfo_Name, kn) {
						currentKey = ffj_t_TaskInfo_Name
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_TaskInfo_Resources, kn) {
						currentKey = ffj_t_TaskInfo_Resources
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_TaskInfo_TaskID, kn) {
						currentKey = ffj_t_TaskInfo_TaskID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_TaskInfo_Discovery, kn) {
					currentKey = ffj_t_TaskInfo_Discovery
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_TaskInfo_Labels, kn) {
					currentKey = ffj_t_TaskInfo_Labels
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_TaskInfo_HealthCheck, kn) {
					currentKey = ffj_t_TaskInfo_HealthCheck
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_TaskInfo_Data, kn) {
					currentKey = ffj_t_TaskInfo_Data
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_TaskInfo_Container, kn) {
					currentKey = ffj_t_TaskInfo_Container
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_TaskInfo_Command, kn) {
					currentKey = ffj_t_TaskInfo_Command
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_TaskInfo_Executor, kn) {
					currentKey = ffj_t_TaskInfo_Executor
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_TaskInfo_Resources, kn) {
					currentKey = ffj_t_TaskInfo_Resources
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_TaskInfo_AgentID, kn) {
					currentKey = ffj_t_TaskInfo_AgentID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_TaskInfo_TaskID, kn) {
					currentKey = ffj_t_TaskInfo_TaskID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_TaskInfo_Name, kn) {
					currentKey = ffj_t_TaskInfo_Name
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_TaskInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_TaskInfo_Name:
					goto handle_Name

				case ffj_t_TaskInfo_TaskID:
					goto handle_TaskID

				case ffj_t_TaskInfo_AgentID:
					goto handle_AgentID

				case ffj_t_TaskInfo_Resources:
					goto handle_Resources

				case ffj_t_TaskInfo_Executor:
					goto handle_Executor

				case ffj_t_TaskInfo_Command:
					goto handle_Command

				case ffj_t_TaskInfo_Container:
					goto handle_Container

				case ffj_t_TaskInfo_Data:
					goto handle_Data

				case ffj_t_TaskInfo_HealthCheck:
					goto handle_HealthCheck

				case ffj_t_TaskInfo_Labels:
					goto handle_Labels

				case ffj_t_TaskInfo_Discovery:
					goto handle_Discovery

				case ffj_t_TaskInfono_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Name:

	/* handler: uj.Name type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Name = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TaskID:

	/* handler: uj.TaskID type=mesos.TaskID kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.TaskID.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AgentID:

	/* handler: uj.AgentID type=mesos.AgentID kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.AgentID.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Resources:

	/* handler: uj.Resources type=[]mesos.Resource kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Resources = nil
		} else {

			uj.Resources = make([]Resource, 0)

			wantVal := true

			for {

				var v Resource

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=mesos.Resource kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Resources = append(uj.Resources, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Executor:

	/* handler: uj.Executor type=mesos.ExecutorInfo kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Executor = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Executor == nil {
			uj.Executor = new(ExecutorInfo)
		}

		err = uj.Executor.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Command:

	/* handler: uj.Command type=mesos.CommandInfo kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Command = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Command == nil {
			uj.Command = new(CommandInfo)
		}

		err = uj.Command.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Container:

	/* handler: uj.Container type=mesos.ContainerInfo kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Container = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Container == nil {
			uj.Container = new(ContainerInfo)
		}

		err = uj.Container.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Data:

	/* handler: uj.Data type=[]uint8 kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Data = nil
		} else {
			b := make([]byte, base64.StdEncoding.DecodedLen(fs.Output.Len()))
			n, err := base64.StdEncoding.Decode(b, fs.Output.Bytes())
			if err != nil {
				return fs.WrapErr(err)
			}

			v := reflect.ValueOf(&uj.Data).Elem()
			v.SetBytes(b[0:n])

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_HealthCheck:

	/* handler: uj.HealthCheck type=mesos.HealthCheck kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.HealthCheck = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.HealthCheck == nil {
			uj.HealthCheck = new(HealthCheck)
		}

		err = uj.HealthCheck.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Labels:

	/* handler: uj.Labels type=mesos.Labels kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Labels = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Labels == nil {
			uj.Labels = new(Labels)
		}

		err = uj.Labels.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Discovery:

	/* handler: uj.Discovery type=mesos.DiscoveryInfo kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Discovery = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Discovery == nil {
			uj.Discovery = new(DiscoveryInfo)
		}

		err = uj.Discovery.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *TaskStatus) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *TaskStatus) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "task_id":`)

	{

		err = mj.TaskID.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte(',')
	if mj.State != nil {
		if true {
			buf.WriteString(`"state":`)

			{

				obj, err = mj.State.MarshalJSON()
				if err != nil {
					return err
				}
				buf.Write(obj)

			}
			buf.WriteByte(',')
		}
	}
	if mj.Message != nil {
		if true {
			buf.WriteString(`"message":`)
			fflib.WriteJsonString(buf, string(*mj.Message))
			buf.WriteByte(',')
		}
	}
	if mj.Source != nil {
		if true {
			buf.WriteString(`"source":`)

			{

				obj, err = mj.Source.MarshalJSON()
				if err != nil {
					return err
				}
				buf.Write(obj)

			}
			buf.WriteByte(',')
		}
	}
	if mj.Reason != nil {
		if true {
			buf.WriteString(`"reason":`)

			{

				obj, err = mj.Reason.MarshalJSON()
				if err != nil {
					return err
				}
				buf.Write(obj)

			}
			buf.WriteByte(',')
		}
	}
	if len(mj.Data) != 0 {
		buf.WriteString(`"data":`)
		if mj.Data != nil {
			buf.WriteString(`"`)
			{
				enc := base64.NewEncoder(base64.StdEncoding, buf)
				enc.Write(reflect.Indirect(reflect.ValueOf(mj.Data)).Bytes())
				enc.Close()
			}
			buf.WriteString(`"`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if mj.AgentID != nil {
		if true {
			buf.WriteString(`"agent_id":`)

			{

				err = mj.AgentID.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.ExecutorID != nil {
		if true {
			buf.WriteString(`"executor_id":`)

			{

				err = mj.ExecutorID.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.Timestamp != nil {
		if true {
			buf.WriteString(`"timestamp":`)
			fflib.AppendFloat(buf, float64(*mj.Timestamp), 'g', -1, 64)
			buf.WriteByte(',')
		}
	}
	if len(mj.UUID) != 0 {
		buf.WriteString(`"uuid":`)
		if mj.UUID != nil {
			buf.WriteString(`"`)
			{
				enc := base64.NewEncoder(base64.StdEncoding, buf)
				enc.Write(reflect.Indirect(reflect.ValueOf(mj.UUID)).Bytes())
				enc.Close()
			}
			buf.WriteString(`"`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if mj.Healthy != nil {
		if true {
			if *mj.Healthy {
				buf.WriteString(`"healthy":true`)
			} else {
				buf.WriteString(`"healthy":false`)
			}
			buf.WriteByte(',')
		}
	}
	if mj.Labels != nil {
		if true {
			buf.WriteString(`"labels":`)

			{

				err = mj.Labels.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.ContainerStatus != nil {
		if true {
			buf.WriteString(`"container_status":`)

			{

				err = mj.ContainerStatus.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_TaskStatusbase = iota
	ffj_t_TaskStatusno_such_key

	ffj_t_TaskStatus_TaskID

	ffj_t_TaskStatus_State

	ffj_t_TaskStatus_Message

	ffj_t_TaskStatus_Source

	ffj_t_TaskStatus_Reason

	ffj_t_TaskStatus_Data

	ffj_t_TaskStatus_AgentID

	ffj_t_TaskStatus_ExecutorID

	ffj_t_TaskStatus_Timestamp

	ffj_t_TaskStatus_UUID

	ffj_t_TaskStatus_Healthy

	ffj_t_TaskStatus_Labels

	ffj_t_TaskStatus_ContainerStatus
)

var ffj_key_TaskStatus_TaskID = []byte("task_id")

var ffj_key_TaskStatus_State = []byte("state")

var ffj_key_TaskStatus_Message = []byte("message")

var ffj_key_TaskStatus_Source = []byte("source")

var ffj_key_TaskStatus_Reason = []byte("reason")

var ffj_key_TaskStatus_Data = []byte("data")

var ffj_key_TaskStatus_AgentID = []byte("agent_id")

var ffj_key_TaskStatus_ExecutorID = []byte("executor_id")

var ffj_key_TaskStatus_Timestamp = []byte("timestamp")

var ffj_key_TaskStatus_UUID = []byte("uuid")

var ffj_key_TaskStatus_Healthy = []byte("healthy")

var ffj_key_TaskStatus_Labels = []byte("labels")

var ffj_key_TaskStatus_ContainerStatus = []byte("container_status")

func (uj *TaskStatus) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *TaskStatus) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_TaskStatusbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_TaskStatusno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_TaskStatus_AgentID, kn) {
						currentKey = ffj_t_TaskStatus_AgentID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffj_key_TaskStatus_ContainerStatus, kn) {
						currentKey = ffj_t_TaskStatus_ContainerStatus
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffj_key_TaskStatus_Data, kn) {
						currentKey = ffj_t_TaskStatus_Data
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffj_key_TaskStatus_ExecutorID, kn) {
						currentKey = ffj_t_TaskStatus_ExecutorID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'h':

					if bytes.Equal(ffj_key_TaskStatus_Healthy, kn) {
						currentKey = ffj_t_TaskStatus_Healthy
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffj_key_TaskStatus_Labels, kn) {
						currentKey = ffj_t_TaskStatus_Labels
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_TaskStatus_Message, kn) {
						currentKey = ffj_t_TaskStatus_Message
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_TaskStatus_Reason, kn) {
						currentKey = ffj_t_TaskStatus_Reason
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_TaskStatus_State, kn) {
						currentKey = ffj_t_TaskStatus_State
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_TaskStatus_Source, kn) {
						currentKey = ffj_t_TaskStatus_Source
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_TaskStatus_TaskID, kn) {
						currentKey = ffj_t_TaskStatus_TaskID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_TaskStatus_Timestamp, kn) {
						currentKey = ffj_t_TaskStatus_Timestamp
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffj_key_TaskStatus_UUID, kn) {
						currentKey = ffj_t_TaskStatus_UUID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_TaskStatus_ContainerStatus, kn) {
					currentKey = ffj_t_TaskStatus_ContainerStatus
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_TaskStatus_Labels, kn) {
					currentKey = ffj_t_TaskStatus_Labels
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_TaskStatus_Healthy, kn) {
					currentKey = ffj_t_TaskStatus_Healthy
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_TaskStatus_UUID, kn) {
					currentKey = ffj_t_TaskStatus_UUID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_TaskStatus_Timestamp, kn) {
					currentKey = ffj_t_TaskStatus_Timestamp
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_TaskStatus_ExecutorID, kn) {
					currentKey = ffj_t_TaskStatus_ExecutorID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_TaskStatus_AgentID, kn) {
					currentKey = ffj_t_TaskStatus_AgentID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_TaskStatus_Data, kn) {
					currentKey = ffj_t_TaskStatus_Data
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_TaskStatus_Reason, kn) {
					currentKey = ffj_t_TaskStatus_Reason
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_TaskStatus_Source, kn) {
					currentKey = ffj_t_TaskStatus_Source
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_TaskStatus_Message, kn) {
					currentKey = ffj_t_TaskStatus_Message
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_TaskStatus_State, kn) {
					currentKey = ffj_t_TaskStatus_State
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_TaskStatus_TaskID, kn) {
					currentKey = ffj_t_TaskStatus_TaskID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_TaskStatusno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_TaskStatus_TaskID:
					goto handle_TaskID

				case ffj_t_TaskStatus_State:
					goto handle_State

				case ffj_t_TaskStatus_Message:
					goto handle_Message

				case ffj_t_TaskStatus_Source:
					goto handle_Source

				case ffj_t_TaskStatus_Reason:
					goto handle_Reason

				case ffj_t_TaskStatus_Data:
					goto handle_Data

				case ffj_t_TaskStatus_AgentID:
					goto handle_AgentID

				case ffj_t_TaskStatus_ExecutorID:
					goto handle_ExecutorID

				case ffj_t_TaskStatus_Timestamp:
					goto handle_Timestamp

				case ffj_t_TaskStatus_UUID:
					goto handle_UUID

				case ffj_t_TaskStatus_Healthy:
					goto handle_Healthy

				case ffj_t_TaskStatus_Labels:
					goto handle_Labels

				case ffj_t_TaskStatus_ContainerStatus:
					goto handle_ContainerStatus

				case ffj_t_TaskStatusno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_TaskID:

	/* handler: uj.TaskID type=mesos.TaskID kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.TaskID.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_State:

	/* handler: uj.State type=mesos.TaskState kind=int32 quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.State = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		if uj.State == nil {
			uj.State = new(TaskState)
		}

		err = uj.State.UnmarshalJSON(tbuf)
		if err != nil {
			return fs.WrapErr(err)
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Message:

	/* handler: uj.Message type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Message = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Message = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Source:

	/* handler: uj.Source type=mesos.TaskStatus_Source kind=int32 quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Source = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		if uj.Source == nil {
			uj.Source = new(TaskStatus_Source)
		}

		err = uj.Source.UnmarshalJSON(tbuf)
		if err != nil {
			return fs.WrapErr(err)
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Reason:

	/* handler: uj.Reason type=mesos.TaskStatus_Reason kind=int32 quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Reason = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		if uj.Reason == nil {
			uj.Reason = new(TaskStatus_Reason)
		}

		err = uj.Reason.UnmarshalJSON(tbuf)
		if err != nil {
			return fs.WrapErr(err)
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Data:

	/* handler: uj.Data type=[]uint8 kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Data = nil
		} else {
			b := make([]byte, base64.StdEncoding.DecodedLen(fs.Output.Len()))
			n, err := base64.StdEncoding.Decode(b, fs.Output.Bytes())
			if err != nil {
				return fs.WrapErr(err)
			}

			v := reflect.ValueOf(&uj.Data).Elem()
			v.SetBytes(b[0:n])

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AgentID:

	/* handler: uj.AgentID type=mesos.AgentID kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.AgentID = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.AgentID == nil {
			uj.AgentID = new(AgentID)
		}

		err = uj.AgentID.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ExecutorID:

	/* handler: uj.ExecutorID type=mesos.ExecutorID kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.ExecutorID = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.ExecutorID == nil {
			uj.ExecutorID = new(ExecutorID)
		}

		err = uj.ExecutorID.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Timestamp:

	/* handler: uj.Timestamp type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Timestamp = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			uj.Timestamp = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_UUID:

	/* handler: uj.UUID type=[]uint8 kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.UUID = nil
		} else {
			b := make([]byte, base64.StdEncoding.DecodedLen(fs.Output.Len()))
			n, err := base64.StdEncoding.Decode(b, fs.Output.Bytes())
			if err != nil {
				return fs.WrapErr(err)
			}

			v := reflect.ValueOf(&uj.UUID).Elem()
			v.SetBytes(b[0:n])

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Healthy:

	/* handler: uj.Healthy type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

			uj.Healthy = nil

		} else {
			tmpb := fs.Output.Bytes()

			var tval bool

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				tval = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				tval = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

			uj.Healthy = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Labels:

	/* handler: uj.Labels type=mesos.Labels kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Labels = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Labels == nil {
			uj.Labels = new(Labels)
		}

		err = uj.Labels.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ContainerStatus:

	/* handler: uj.ContainerStatus type=mesos.ContainerStatus kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.ContainerStatus = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.ContainerStatus == nil {
			uj.ContainerStatus = new(ContainerStatus)
		}

		err = uj.ContainerStatus.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *TcpStatistics) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *TcpStatistics) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.RtoAlgorithm != nil {
		if true {
			buf.WriteString(`"RtoAlgorithm":`)
			fflib.FormatBits2(buf, uint64(*mj.RtoAlgorithm), 10, *mj.RtoAlgorithm < 0)
			buf.WriteByte(',')
		}
	}
	if mj.RtoMin != nil {
		if true {
			buf.WriteString(`"RtoMin":`)
			fflib.FormatBits2(buf, uint64(*mj.RtoMin), 10, *mj.RtoMin < 0)
			buf.WriteByte(',')
		}
	}
	if mj.RtoMax != nil {
		if true {
			buf.WriteString(`"RtoMax":`)
			fflib.FormatBits2(buf, uint64(*mj.RtoMax), 10, *mj.RtoMax < 0)
			buf.WriteByte(',')
		}
	}
	if mj.MaxConn != nil {
		if true {
			buf.WriteString(`"MaxConn":`)
			fflib.FormatBits2(buf, uint64(*mj.MaxConn), 10, *mj.MaxConn < 0)
			buf.WriteByte(',')
		}
	}
	if mj.ActiveOpens != nil {
		if true {
			buf.WriteString(`"ActiveOpens":`)
			fflib.FormatBits2(buf, uint64(*mj.ActiveOpens), 10, *mj.ActiveOpens < 0)
			buf.WriteByte(',')
		}
	}
	if mj.PassiveOpens != nil {
		if true {
			buf.WriteString(`"PassiveOpens":`)
			fflib.FormatBits2(buf, uint64(*mj.PassiveOpens), 10, *mj.PassiveOpens < 0)
			buf.WriteByte(',')
		}
	}
	if mj.AttemptFails != nil {
		if true {
			buf.WriteString(`"AttemptFails":`)
			fflib.FormatBits2(buf, uint64(*mj.AttemptFails), 10, *mj.AttemptFails < 0)
			buf.WriteByte(',')
		}
	}
	if mj.EstabResets != nil {
		if true {
			buf.WriteString(`"EstabResets":`)
			fflib.FormatBits2(buf, uint64(*mj.EstabResets), 10, *mj.EstabResets < 0)
			buf.WriteByte(',')
		}
	}
	if mj.CurrEstab != nil {
		if true {
			buf.WriteString(`"CurrEstab":`)
			fflib.FormatBits2(buf, uint64(*mj.CurrEstab), 10, *mj.CurrEstab < 0)
			buf.WriteByte(',')
		}
	}
	if mj.InSegs != nil {
		if true {
			buf.WriteString(`"InSegs":`)
			fflib.FormatBits2(buf, uint64(*mj.InSegs), 10, *mj.InSegs < 0)
			buf.WriteByte(',')
		}
	}
	if mj.OutSegs != nil {
		if true {
			buf.WriteString(`"OutSegs":`)
			fflib.FormatBits2(buf, uint64(*mj.OutSegs), 10, *mj.OutSegs < 0)
			buf.WriteByte(',')
		}
	}
	if mj.RetransSegs != nil {
		if true {
			buf.WriteString(`"RetransSegs":`)
			fflib.FormatBits2(buf, uint64(*mj.RetransSegs), 10, *mj.RetransSegs < 0)
			buf.WriteByte(',')
		}
	}
	if mj.InErrs != nil {
		if true {
			buf.WriteString(`"InErrs":`)
			fflib.FormatBits2(buf, uint64(*mj.InErrs), 10, *mj.InErrs < 0)
			buf.WriteByte(',')
		}
	}
	if mj.OutRsts != nil {
		if true {
			buf.WriteString(`"OutRsts":`)
			fflib.FormatBits2(buf, uint64(*mj.OutRsts), 10, *mj.OutRsts < 0)
			buf.WriteByte(',')
		}
	}
	if mj.InCsumErrors != nil {
		if true {
			buf.WriteString(`"InCsumErrors":`)
			fflib.FormatBits2(buf, uint64(*mj.InCsumErrors), 10, *mj.InCsumErrors < 0)
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_TcpStatisticsbase = iota
	ffj_t_TcpStatisticsno_such_key

	ffj_t_TcpStatistics_RtoAlgorithm

	ffj_t_TcpStatistics_RtoMin

	ffj_t_TcpStatistics_RtoMax

	ffj_t_TcpStatistics_MaxConn

	ffj_t_TcpStatistics_ActiveOpens

	ffj_t_TcpStatistics_PassiveOpens

	ffj_t_TcpStatistics_AttemptFails

	ffj_t_TcpStatistics_EstabResets

	ffj_t_TcpStatistics_CurrEstab

	ffj_t_TcpStatistics_InSegs

	ffj_t_TcpStatistics_OutSegs

	ffj_t_TcpStatistics_RetransSegs

	ffj_t_TcpStatistics_InErrs

	ffj_t_TcpStatistics_OutRsts

	ffj_t_TcpStatistics_InCsumErrors
)

var ffj_key_TcpStatistics_RtoAlgorithm = []byte("RtoAlgorithm")

var ffj_key_TcpStatistics_RtoMin = []byte("RtoMin")

var ffj_key_TcpStatistics_RtoMax = []byte("RtoMax")

var ffj_key_TcpStatistics_MaxConn = []byte("MaxConn")

var ffj_key_TcpStatistics_ActiveOpens = []byte("ActiveOpens")

var ffj_key_TcpStatistics_PassiveOpens = []byte("PassiveOpens")

var ffj_key_TcpStatistics_AttemptFails = []byte("AttemptFails")

var ffj_key_TcpStatistics_EstabResets = []byte("EstabResets")

var ffj_key_TcpStatistics_CurrEstab = []byte("CurrEstab")

var ffj_key_TcpStatistics_InSegs = []byte("InSegs")

var ffj_key_TcpStatistics_OutSegs = []byte("OutSegs")

var ffj_key_TcpStatistics_RetransSegs = []byte("RetransSegs")

var ffj_key_TcpStatistics_InErrs = []byte("InErrs")

var ffj_key_TcpStatistics_OutRsts = []byte("OutRsts")

var ffj_key_TcpStatistics_InCsumErrors = []byte("InCsumErrors")

func (uj *TcpStatistics) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *TcpStatistics) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_TcpStatisticsbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_TcpStatisticsno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'A':

					if bytes.Equal(ffj_key_TcpStatistics_ActiveOpens, kn) {
						currentKey = ffj_t_TcpStatistics_ActiveOpens
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_TcpStatistics_AttemptFails, kn) {
						currentKey = ffj_t_TcpStatistics_AttemptFails
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'C':

					if bytes.Equal(ffj_key_TcpStatistics_CurrEstab, kn) {
						currentKey = ffj_t_TcpStatistics_CurrEstab
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'E':

					if bytes.Equal(ffj_key_TcpStatistics_EstabResets, kn) {
						currentKey = ffj_t_TcpStatistics_EstabResets
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'I':

					if bytes.Equal(ffj_key_TcpStatistics_InSegs, kn) {
						currentKey = ffj_t_TcpStatistics_InSegs
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_TcpStatistics_InErrs, kn) {
						currentKey = ffj_t_TcpStatistics_InErrs
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_TcpStatistics_InCsumErrors, kn) {
						currentKey = ffj_t_TcpStatistics_InCsumErrors
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'M':

					if bytes.Equal(ffj_key_TcpStatistics_MaxConn, kn) {
						currentKey = ffj_t_TcpStatistics_MaxConn
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'O':

					if bytes.Equal(ffj_key_TcpStatistics_OutSegs, kn) {
						currentKey = ffj_t_TcpStatistics_OutSegs
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_TcpStatistics_OutRsts, kn) {
						currentKey = ffj_t_TcpStatistics_OutRsts
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'P':

					if bytes.Equal(ffj_key_TcpStatistics_PassiveOpens, kn) {
						currentKey = ffj_t_TcpStatistics_PassiveOpens
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'R':

					if bytes.Equal(ffj_key_TcpStatistics_RtoAlgorithm, kn) {
						currentKey = ffj_t_TcpStatistics_RtoAlgorithm
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_TcpStatistics_RtoMin, kn) {
						currentKey = ffj_t_TcpStatistics_RtoMin
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_TcpStatistics_RtoMax, kn) {
						currentKey = ffj_t_TcpStatistics_RtoMax
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_TcpStatistics_RetransSegs, kn) {
						currentKey = ffj_t_TcpStatistics_RetransSegs
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_TcpStatistics_InCsumErrors, kn) {
					currentKey = ffj_t_TcpStatistics_InCsumErrors
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_TcpStatistics_OutRsts, kn) {
					currentKey = ffj_t_TcpStatistics_OutRsts
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_TcpStatistics_InErrs, kn) {
					currentKey = ffj_t_TcpStatistics_InErrs
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_TcpStatistics_RetransSegs, kn) {
					currentKey = ffj_t_TcpStatistics_RetransSegs
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_TcpStatistics_OutSegs, kn) {
					currentKey = ffj_t_TcpStatistics_OutSegs
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_TcpStatistics_InSegs, kn) {
					currentKey = ffj_t_TcpStatistics_InSegs
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_TcpStatistics_CurrEstab, kn) {
					currentKey = ffj_t_TcpStatistics_CurrEstab
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_TcpStatistics_EstabResets, kn) {
					currentKey = ffj_t_TcpStatistics_EstabResets
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_TcpStatistics_AttemptFails, kn) {
					currentKey = ffj_t_TcpStatistics_AttemptFails
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_TcpStatistics_PassiveOpens, kn) {
					currentKey = ffj_t_TcpStatistics_PassiveOpens
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_TcpStatistics_ActiveOpens, kn) {
					currentKey = ffj_t_TcpStatistics_ActiveOpens
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_TcpStatistics_MaxConn, kn) {
					currentKey = ffj_t_TcpStatistics_MaxConn
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_TcpStatistics_RtoMax, kn) {
					currentKey = ffj_t_TcpStatistics_RtoMax
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_TcpStatistics_RtoMin, kn) {
					currentKey = ffj_t_TcpStatistics_RtoMin
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_TcpStatistics_RtoAlgorithm, kn) {
					currentKey = ffj_t_TcpStatistics_RtoAlgorithm
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_TcpStatisticsno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_TcpStatistics_RtoAlgorithm:
					goto handle_RtoAlgorithm

				case ffj_t_TcpStatistics_RtoMin:
					goto handle_RtoMin

				case ffj_t_TcpStatistics_RtoMax:
					goto handle_RtoMax

				case ffj_t_TcpStatistics_MaxConn:
					goto handle_MaxConn

				case ffj_t_TcpStatistics_ActiveOpens:
					goto handle_ActiveOpens

				case ffj_t_TcpStatistics_PassiveOpens:
					goto handle_PassiveOpens

				case ffj_t_TcpStatistics_AttemptFails:
					goto handle_AttemptFails

				case ffj_t_TcpStatistics_EstabResets:
					goto handle_EstabResets

				case ffj_t_TcpStatistics_CurrEstab:
					goto handle_CurrEstab

				case ffj_t_TcpStatistics_InSegs:
					goto handle_InSegs

				case ffj_t_TcpStatistics_OutSegs:
					goto handle_OutSegs

				case ffj_t_TcpStatistics_RetransSegs:
					goto handle_RetransSegs

				case ffj_t_TcpStatistics_InErrs:
					goto handle_InErrs

				case ffj_t_TcpStatistics_OutRsts:
					goto handle_OutRsts

				case ffj_t_TcpStatistics_InCsumErrors:
					goto handle_InCsumErrors

				case ffj_t_TcpStatisticsno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_RtoAlgorithm:

	/* handler: uj.RtoAlgorithm type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.RtoAlgorithm = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			uj.RtoAlgorithm = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RtoMin:

	/* handler: uj.RtoMin type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.RtoMin = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			uj.RtoMin = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RtoMax:

	/* handler: uj.RtoMax type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.RtoMax = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			uj.RtoMax = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MaxConn:

	/* handler: uj.MaxConn type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.MaxConn = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			uj.MaxConn = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ActiveOpens:

	/* handler: uj.ActiveOpens type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.ActiveOpens = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			uj.ActiveOpens = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PassiveOpens:

	/* handler: uj.PassiveOpens type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.PassiveOpens = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			uj.PassiveOpens = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AttemptFails:

	/* handler: uj.AttemptFails type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.AttemptFails = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			uj.AttemptFails = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_EstabResets:

	/* handler: uj.EstabResets type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.EstabResets = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			uj.EstabResets = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CurrEstab:

	/* handler: uj.CurrEstab type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.CurrEstab = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			uj.CurrEstab = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InSegs:

	/* handler: uj.InSegs type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.InSegs = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			uj.InSegs = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_OutSegs:

	/* handler: uj.OutSegs type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.OutSegs = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			uj.OutSegs = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RetransSegs:

	/* handler: uj.RetransSegs type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.RetransSegs = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			uj.RetransSegs = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InErrs:

	/* handler: uj.InErrs type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.InErrs = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			uj.InErrs = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_OutRsts:

	/* handler: uj.OutRsts type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.OutRsts = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			uj.OutRsts = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InCsumErrors:

	/* handler: uj.InCsumErrors type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.InCsumErrors = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			uj.InCsumErrors = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *TimeInfo) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *TimeInfo) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"nanoseconds":`)
	fflib.FormatBits2(buf, uint64(mj.Nanoseconds), 10, mj.Nanoseconds < 0)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_TimeInfobase = iota
	ffj_t_TimeInfono_such_key

	ffj_t_TimeInfo_Nanoseconds
)

var ffj_key_TimeInfo_Nanoseconds = []byte("nanoseconds")

func (uj *TimeInfo) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *TimeInfo) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_TimeInfobase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_TimeInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'n':

					if bytes.Equal(ffj_key_TimeInfo_Nanoseconds, kn) {
						currentKey = ffj_t_TimeInfo_Nanoseconds
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_TimeInfo_Nanoseconds, kn) {
					currentKey = ffj_t_TimeInfo_Nanoseconds
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_TimeInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_TimeInfo_Nanoseconds:
					goto handle_Nanoseconds

				case ffj_t_TimeInfono_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Nanoseconds:

	/* handler: uj.Nanoseconds type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Nanoseconds = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *TrafficControlStatistics) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *TrafficControlStatistics) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "id":`)
	fflib.WriteJsonString(buf, string(mj.ID))
	buf.WriteByte(',')
	if mj.Backlog != nil {
		if true {
			buf.WriteString(`"backlog":`)
			fflib.FormatBits2(buf, uint64(*mj.Backlog), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.Bytes != nil {
		if true {
			buf.WriteString(`"bytes":`)
			fflib.FormatBits2(buf, uint64(*mj.Bytes), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.Drops != nil {
		if true {
			buf.WriteString(`"drops":`)
			fflib.FormatBits2(buf, uint64(*mj.Drops), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.Overlimits != nil {
		if true {
			buf.WriteString(`"overlimits":`)
			fflib.FormatBits2(buf, uint64(*mj.Overlimits), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.Packets != nil {
		if true {
			buf.WriteString(`"packets":`)
			fflib.FormatBits2(buf, uint64(*mj.Packets), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.Qlen != nil {
		if true {
			buf.WriteString(`"qlen":`)
			fflib.FormatBits2(buf, uint64(*mj.Qlen), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.Ratebps != nil {
		if true {
			buf.WriteString(`"ratebps":`)
			fflib.FormatBits2(buf, uint64(*mj.Ratebps), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.Ratepps != nil {
		if true {
			buf.WriteString(`"ratepps":`)
			fflib.FormatBits2(buf, uint64(*mj.Ratepps), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.Requeues != nil {
		if true {
			buf.WriteString(`"requeues":`)
			fflib.FormatBits2(buf, uint64(*mj.Requeues), 10, false)
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_TrafficControlStatisticsbase = iota
	ffj_t_TrafficControlStatisticsno_such_key

	ffj_t_TrafficControlStatistics_ID

	ffj_t_TrafficControlStatistics_Backlog

	ffj_t_TrafficControlStatistics_Bytes

	ffj_t_TrafficControlStatistics_Drops

	ffj_t_TrafficControlStatistics_Overlimits

	ffj_t_TrafficControlStatistics_Packets

	ffj_t_TrafficControlStatistics_Qlen

	ffj_t_TrafficControlStatistics_Ratebps

	ffj_t_TrafficControlStatistics_Ratepps

	ffj_t_TrafficControlStatistics_Requeues
)

var ffj_key_TrafficControlStatistics_ID = []byte("id")

var ffj_key_TrafficControlStatistics_Backlog = []byte("backlog")

var ffj_key_TrafficControlStatistics_Bytes = []byte("bytes")

var ffj_key_TrafficControlStatistics_Drops = []byte("drops")

var ffj_key_TrafficControlStatistics_Overlimits = []byte("overlimits")

var ffj_key_TrafficControlStatistics_Packets = []byte("packets")

var ffj_key_TrafficControlStatistics_Qlen = []byte("qlen")

var ffj_key_TrafficControlStatistics_Ratebps = []byte("ratebps")

var ffj_key_TrafficControlStatistics_Ratepps = []byte("ratepps")

var ffj_key_TrafficControlStatistics_Requeues = []byte("requeues")

func (uj *TrafficControlStatistics) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *TrafficControlStatistics) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_TrafficControlStatisticsbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_TrafficControlStatisticsno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'b':

					if bytes.Equal(ffj_key_TrafficControlStatistics_Backlog, kn) {
						currentKey = ffj_t_TrafficControlStatistics_Backlog
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_TrafficControlStatistics_Bytes, kn) {
						currentKey = ffj_t_TrafficControlStatistics_Bytes
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffj_key_TrafficControlStatistics_Drops, kn) {
						currentKey = ffj_t_TrafficControlStatistics_Drops
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_TrafficControlStatistics_ID, kn) {
						currentKey = ffj_t_TrafficControlStatistics_ID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'o':

					if bytes.Equal(ffj_key_TrafficControlStatistics_Overlimits, kn) {
						currentKey = ffj_t_TrafficControlStatistics_Overlimits
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_TrafficControlStatistics_Packets, kn) {
						currentKey = ffj_t_TrafficControlStatistics_Packets
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'q':

					if bytes.Equal(ffj_key_TrafficControlStatistics_Qlen, kn) {
						currentKey = ffj_t_TrafficControlStatistics_Qlen
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_TrafficControlStatistics_Ratebps, kn) {
						currentKey = ffj_t_TrafficControlStatistics_Ratebps
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_TrafficControlStatistics_Ratepps, kn) {
						currentKey = ffj_t_TrafficControlStatistics_Ratepps
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_TrafficControlStatistics_Requeues, kn) {
						currentKey = ffj_t_TrafficControlStatistics_Requeues
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_TrafficControlStatistics_Requeues, kn) {
					currentKey = ffj_t_TrafficControlStatistics_Requeues
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_TrafficControlStatistics_Ratepps, kn) {
					currentKey = ffj_t_TrafficControlStatistics_Ratepps
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_TrafficControlStatistics_Ratebps, kn) {
					currentKey = ffj_t_TrafficControlStatistics_Ratebps
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_TrafficControlStatistics_Qlen, kn) {
					currentKey = ffj_t_TrafficControlStatistics_Qlen
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_TrafficControlStatistics_Packets, kn) {
					currentKey = ffj_t_TrafficControlStatistics_Packets
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_TrafficControlStatistics_Overlimits, kn) {
					currentKey = ffj_t_TrafficControlStatistics_Overlimits
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_TrafficControlStatistics_Drops, kn) {
					currentKey = ffj_t_TrafficControlStatistics_Drops
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_TrafficControlStatistics_Bytes, kn) {
					currentKey = ffj_t_TrafficControlStatistics_Bytes
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_TrafficControlStatistics_Backlog, kn) {
					currentKey = ffj_t_TrafficControlStatistics_Backlog
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_TrafficControlStatistics_ID, kn) {
					currentKey = ffj_t_TrafficControlStatistics_ID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_TrafficControlStatisticsno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_TrafficControlStatistics_ID:
					goto handle_ID

				case ffj_t_TrafficControlStatistics_Backlog:
					goto handle_Backlog

				case ffj_t_TrafficControlStatistics_Bytes:
					goto handle_Bytes

				case ffj_t_TrafficControlStatistics_Drops:
					goto handle_Drops

				case ffj_t_TrafficControlStatistics_Overlimits:
					goto handle_Overlimits

				case ffj_t_TrafficControlStatistics_Packets:
					goto handle_Packets

				case ffj_t_TrafficControlStatistics_Qlen:
					goto handle_Qlen

				case ffj_t_TrafficControlStatistics_Ratebps:
					goto handle_Ratebps

				case ffj_t_TrafficControlStatistics_Ratepps:
					goto handle_Ratepps

				case ffj_t_TrafficControlStatistics_Requeues:
					goto handle_Requeues

				case ffj_t_TrafficControlStatisticsno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ID:

	/* handler: uj.ID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.ID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Backlog:

	/* handler: uj.Backlog type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Backlog = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.Backlog = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Bytes:

	/* handler: uj.Bytes type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Bytes = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.Bytes = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Drops:

	/* handler: uj.Drops type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Drops = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.Drops = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Overlimits:

	/* handler: uj.Overlimits type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Overlimits = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.Overlimits = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Packets:

	/* handler: uj.Packets type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Packets = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.Packets = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Qlen:

	/* handler: uj.Qlen type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Qlen = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.Qlen = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Ratebps:

	/* handler: uj.Ratebps type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Ratebps = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.Ratebps = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Ratepps:

	/* handler: uj.Ratepps type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Ratepps = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.Ratepps = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Requeues:

	/* handler: uj.Requeues type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Requeues = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.Requeues = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *URL) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *URL) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "scheme":`)
	fflib.WriteJsonString(buf, string(mj.Scheme))
	buf.WriteString(`,"address":`)

	{

		err = mj.Address.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte(',')
	if mj.Path != nil {
		if true {
			buf.WriteString(`"path":`)
			fflib.WriteJsonString(buf, string(*mj.Path))
			buf.WriteByte(',')
		}
	}
	buf.WriteString(`"query":`)
	if mj.Query != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Query {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte(',')
	if mj.Fragment != nil {
		if true {
			buf.WriteString(`"fragment":`)
			fflib.WriteJsonString(buf, string(*mj.Fragment))
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_URLbase = iota
	ffj_t_URLno_such_key

	ffj_t_URL_Scheme

	ffj_t_URL_Address

	ffj_t_URL_Path

	ffj_t_URL_Query

	ffj_t_URL_Fragment
)

var ffj_key_URL_Scheme = []byte("scheme")

var ffj_key_URL_Address = []byte("address")

var ffj_key_URL_Path = []byte("path")

var ffj_key_URL_Query = []byte("query")

var ffj_key_URL_Fragment = []byte("fragment")

func (uj *URL) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *URL) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_URLbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_URLno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_URL_Address, kn) {
						currentKey = ffj_t_URL_Address
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffj_key_URL_Fragment, kn) {
						currentKey = ffj_t_URL_Fragment
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_URL_Path, kn) {
						currentKey = ffj_t_URL_Path
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'q':

					if bytes.Equal(ffj_key_URL_Query, kn) {
						currentKey = ffj_t_URL_Query
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_URL_Scheme, kn) {
						currentKey = ffj_t_URL_Scheme
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_URL_Fragment, kn) {
					currentKey = ffj_t_URL_Fragment
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_URL_Query, kn) {
					currentKey = ffj_t_URL_Query
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_URL_Path, kn) {
					currentKey = ffj_t_URL_Path
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_URL_Address, kn) {
					currentKey = ffj_t_URL_Address
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_URL_Scheme, kn) {
					currentKey = ffj_t_URL_Scheme
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_URLno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_URL_Scheme:
					goto handle_Scheme

				case ffj_t_URL_Address:
					goto handle_Address

				case ffj_t_URL_Path:
					goto handle_Path

				case ffj_t_URL_Query:
					goto handle_Query

				case ffj_t_URL_Fragment:
					goto handle_Fragment

				case ffj_t_URLno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Scheme:

	/* handler: uj.Scheme type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Scheme = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Address:

	/* handler: uj.Address type=mesos.Address kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.Address.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Path:

	/* handler: uj.Path type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Path = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Path = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Query:

	/* handler: uj.Query type=[]mesos.Parameter kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Query = nil
		} else {

			uj.Query = make([]Parameter, 0)

			wantVal := true

			for {

				var v Parameter

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=mesos.Parameter kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Query = append(uj.Query, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Fragment:

	/* handler: uj.Fragment type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Fragment = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Fragment = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *UdpStatistics) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *UdpStatistics) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.InDatagrams != nil {
		if true {
			buf.WriteString(`"InDatagrams":`)
			fflib.FormatBits2(buf, uint64(*mj.InDatagrams), 10, *mj.InDatagrams < 0)
			buf.WriteByte(',')
		}
	}
	if mj.NoPorts != nil {
		if true {
			buf.WriteString(`"NoPorts":`)
			fflib.FormatBits2(buf, uint64(*mj.NoPorts), 10, *mj.NoPorts < 0)
			buf.WriteByte(',')
		}
	}
	if mj.InErrors != nil {
		if true {
			buf.WriteString(`"InErrors":`)
			fflib.FormatBits2(buf, uint64(*mj.InErrors), 10, *mj.InErrors < 0)
			buf.WriteByte(',')
		}
	}
	if mj.OutDatagrams != nil {
		if true {
			buf.WriteString(`"OutDatagrams":`)
			fflib.FormatBits2(buf, uint64(*mj.OutDatagrams), 10, *mj.OutDatagrams < 0)
			buf.WriteByte(',')
		}
	}
	if mj.RcvbufErrors != nil {
		if true {
			buf.WriteString(`"RcvbufErrors":`)
			fflib.FormatBits2(buf, uint64(*mj.RcvbufErrors), 10, *mj.RcvbufErrors < 0)
			buf.WriteByte(',')
		}
	}
	if mj.SndbufErrors != nil {
		if true {
			buf.WriteString(`"SndbufErrors":`)
			fflib.FormatBits2(buf, uint64(*mj.SndbufErrors), 10, *mj.SndbufErrors < 0)
			buf.WriteByte(',')
		}
	}
	if mj.InCsumErrors != nil {
		if true {
			buf.WriteString(`"InCsumErrors":`)
			fflib.FormatBits2(buf, uint64(*mj.InCsumErrors), 10, *mj.InCsumErrors < 0)
			buf.WriteByte(',')
		}
	}
	if mj.IgnoredMulti != nil {
		if true {
			buf.WriteString(`"IgnoredMulti":`)
			fflib.FormatBits2(buf, uint64(*mj.IgnoredMulti), 10, *mj.IgnoredMulti < 0)
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_UdpStatisticsbase = iota
	ffj_t_UdpStatisticsno_such_key

	ffj_t_UdpStatistics_InDatagrams

	ffj_t_UdpStatistics_NoPorts

	ffj_t_UdpStatistics_InErrors

	ffj_t_UdpStatistics_OutDatagrams

	ffj_t_UdpStatistics_RcvbufErrors

	ffj_t_UdpStatistics_SndbufErrors

	ffj_t_UdpStatistics_InCsumErrors

	ffj_t_UdpStatistics_IgnoredMulti
)

var ffj_key_UdpStatistics_InDatagrams = []byte("InDatagrams")

var ffj_key_UdpStatistics_NoPorts = []byte("NoPorts")

var ffj_key_UdpStatistics_InErrors = []byte("InErrors")

var ffj_key_UdpStatistics_OutDatagrams = []byte("OutDatagrams")

var ffj_key_UdpStatistics_RcvbufErrors = []byte("RcvbufErrors")

var ffj_key_UdpStatistics_SndbufErrors = []byte("SndbufErrors")

var ffj_key_UdpStatistics_InCsumErrors = []byte("InCsumErrors")

var ffj_key_UdpStatistics_IgnoredMulti = []byte("IgnoredMulti")

func (uj *UdpStatistics) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *UdpStatistics) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_UdpStatisticsbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_UdpStatisticsno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'I':

					if bytes.Equal(ffj_key_UdpStatistics_InDatagrams, kn) {
						currentKey = ffj_t_UdpStatistics_InDatagrams
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_UdpStatistics_InErrors, kn) {
						currentKey = ffj_t_UdpStatistics_InErrors
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_UdpStatistics_InCsumErrors, kn) {
						currentKey = ffj_t_UdpStatistics_InCsumErrors
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_UdpStatistics_IgnoredMulti, kn) {
						currentKey = ffj_t_UdpStatistics_IgnoredMulti
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'N':

					if bytes.Equal(ffj_key_UdpStatistics_NoPorts, kn) {
						currentKey = ffj_t_UdpStatistics_NoPorts
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'O':

					if bytes.Equal(ffj_key_UdpStatistics_OutDatagrams, kn) {
						currentKey = ffj_t_UdpStatistics_OutDatagrams
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'R':

					if bytes.Equal(ffj_key_UdpStatistics_RcvbufErrors, kn) {
						currentKey = ffj_t_UdpStatistics_RcvbufErrors
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'S':

					if bytes.Equal(ffj_key_UdpStatistics_SndbufErrors, kn) {
						currentKey = ffj_t_UdpStatistics_SndbufErrors
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_UdpStatistics_IgnoredMulti, kn) {
					currentKey = ffj_t_UdpStatistics_IgnoredMulti
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_UdpStatistics_InCsumErrors, kn) {
					currentKey = ffj_t_UdpStatistics_InCsumErrors
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_UdpStatistics_SndbufErrors, kn) {
					currentKey = ffj_t_UdpStatistics_SndbufErrors
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_UdpStatistics_RcvbufErrors, kn) {
					currentKey = ffj_t_UdpStatistics_RcvbufErrors
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_UdpStatistics_OutDatagrams, kn) {
					currentKey = ffj_t_UdpStatistics_OutDatagrams
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_UdpStatistics_InErrors, kn) {
					currentKey = ffj_t_UdpStatistics_InErrors
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_UdpStatistics_NoPorts, kn) {
					currentKey = ffj_t_UdpStatistics_NoPorts
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_UdpStatistics_InDatagrams, kn) {
					currentKey = ffj_t_UdpStatistics_InDatagrams
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_UdpStatisticsno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_UdpStatistics_InDatagrams:
					goto handle_InDatagrams

				case ffj_t_UdpStatistics_NoPorts:
					goto handle_NoPorts

				case ffj_t_UdpStatistics_InErrors:
					goto handle_InErrors

				case ffj_t_UdpStatistics_OutDatagrams:
					goto handle_OutDatagrams

				case ffj_t_UdpStatistics_RcvbufErrors:
					goto handle_RcvbufErrors

				case ffj_t_UdpStatistics_SndbufErrors:
					goto handle_SndbufErrors

				case ffj_t_UdpStatistics_InCsumErrors:
					goto handle_InCsumErrors

				case ffj_t_UdpStatistics_IgnoredMulti:
					goto handle_IgnoredMulti

				case ffj_t_UdpStatisticsno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_InDatagrams:

	/* handler: uj.InDatagrams type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.InDatagrams = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			uj.InDatagrams = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NoPorts:

	/* handler: uj.NoPorts type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.NoPorts = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			uj.NoPorts = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InErrors:

	/* handler: uj.InErrors type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.InErrors = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			uj.InErrors = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_OutDatagrams:

	/* handler: uj.OutDatagrams type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.OutDatagrams = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			uj.OutDatagrams = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RcvbufErrors:

	/* handler: uj.RcvbufErrors type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.RcvbufErrors = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			uj.RcvbufErrors = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SndbufErrors:

	/* handler: uj.SndbufErrors type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.SndbufErrors = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			uj.SndbufErrors = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InCsumErrors:

	/* handler: uj.InCsumErrors type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.InCsumErrors = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			uj.InCsumErrors = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_IgnoredMulti:

	/* handler: uj.IgnoredMulti type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.IgnoredMulti = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			uj.IgnoredMulti = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Unavailability) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Unavailability) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "start":`)

	{

		err = mj.Start.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte(',')
	if mj.Duration != nil {
		if true {
			buf.WriteString(`"duration":`)

			{

				err = mj.Duration.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Unavailabilitybase = iota
	ffj_t_Unavailabilityno_such_key

	ffj_t_Unavailability_Start

	ffj_t_Unavailability_Duration
)

var ffj_key_Unavailability_Start = []byte("start")

var ffj_key_Unavailability_Duration = []byte("duration")

func (uj *Unavailability) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Unavailability) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Unavailabilitybase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Unavailabilityno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'd':

					if bytes.Equal(ffj_key_Unavailability_Duration, kn) {
						currentKey = ffj_t_Unavailability_Duration
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_Unavailability_Start, kn) {
						currentKey = ffj_t_Unavailability_Start
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_Unavailability_Duration, kn) {
					currentKey = ffj_t_Unavailability_Duration
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Unavailability_Start, kn) {
					currentKey = ffj_t_Unavailability_Start
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Unavailabilityno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Unavailability_Start:
					goto handle_Start

				case ffj_t_Unavailability_Duration:
					goto handle_Duration

				case ffj_t_Unavailabilityno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Start:

	/* handler: uj.Start type=mesos.TimeInfo kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.Start.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Duration:

	/* handler: uj.Duration type=mesos.DurationInfo kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Duration = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Duration == nil {
			uj.Duration = new(DurationInfo)
		}

		err = uj.Duration.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Value) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Value) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.Type != nil {
		if true {
			buf.WriteString(`"type":`)

			{

				obj, err = mj.Type.MarshalJSON()
				if err != nil {
					return err
				}
				buf.Write(obj)

			}
			buf.WriteByte(',')
		}
	}
	if mj.Scalar != nil {
		if true {
			buf.WriteString(`"scalar":`)

			{

				err = mj.Scalar.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.Ranges != nil {
		if true {
			buf.WriteString(`"ranges":`)

			{

				err = mj.Ranges.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.Set != nil {
		if true {
			buf.WriteString(`"set":`)

			{

				err = mj.Set.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.Text != nil {
		if true {
			buf.WriteString(`"text":`)

			{

				err = mj.Text.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Valuebase = iota
	ffj_t_Valueno_such_key

	ffj_t_Value_Type

	ffj_t_Value_Scalar

	ffj_t_Value_Ranges

	ffj_t_Value_Set

	ffj_t_Value_Text
)

var ffj_key_Value_Type = []byte("type")

var ffj_key_Value_Scalar = []byte("scalar")

var ffj_key_Value_Ranges = []byte("ranges")

var ffj_key_Value_Set = []byte("set")

var ffj_key_Value_Text = []byte("text")

func (uj *Value) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Value) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Valuebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Valueno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'r':

					if bytes.Equal(ffj_key_Value_Ranges, kn) {
						currentKey = ffj_t_Value_Ranges
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_Value_Scalar, kn) {
						currentKey = ffj_t_Value_Scalar
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Value_Set, kn) {
						currentKey = ffj_t_Value_Set
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_Value_Type, kn) {
						currentKey = ffj_t_Value_Type
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Value_Text, kn) {
						currentKey = ffj_t_Value_Text
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_Value_Text, kn) {
					currentKey = ffj_t_Value_Text
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Value_Set, kn) {
					currentKey = ffj_t_Value_Set
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Value_Ranges, kn) {
					currentKey = ffj_t_Value_Ranges
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Value_Scalar, kn) {
					currentKey = ffj_t_Value_Scalar
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Value_Type, kn) {
					currentKey = ffj_t_Value_Type
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Valueno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Value_Type:
					goto handle_Type

				case ffj_t_Value_Scalar:
					goto handle_Scalar

				case ffj_t_Value_Ranges:
					goto handle_Ranges

				case ffj_t_Value_Set:
					goto handle_Set

				case ffj_t_Value_Text:
					goto handle_Text

				case ffj_t_Valueno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Type:

	/* handler: uj.Type type=mesos.Value_Type kind=int32 quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Type = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		if uj.Type == nil {
			uj.Type = new(Value_Type)
		}

		err = uj.Type.UnmarshalJSON(tbuf)
		if err != nil {
			return fs.WrapErr(err)
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Scalar:

	/* handler: uj.Scalar type=mesos.Value_Scalar kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Scalar = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Scalar == nil {
			uj.Scalar = new(Value_Scalar)
		}

		err = uj.Scalar.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Ranges:

	/* handler: uj.Ranges type=mesos.Value_Ranges kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Ranges = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Ranges == nil {
			uj.Ranges = new(Value_Ranges)
		}

		err = uj.Ranges.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Set:

	/* handler: uj.Set type=mesos.Value_Set kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Set = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Set == nil {
			uj.Set = new(Value_Set)
		}

		err = uj.Set.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Text:

	/* handler: uj.Text type=mesos.Value_Text kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Text = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Text == nil {
			uj.Text = new(Value_Text)
		}

		err = uj.Text.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Value_Range) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Value_Range) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"begin":`)
	fflib.FormatBits2(buf, uint64(mj.Begin), 10, false)
	buf.WriteString(`,"end":`)
	fflib.FormatBits2(buf, uint64(mj.End), 10, false)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Value_Rangebase = iota
	ffj_t_Value_Rangeno_such_key

	ffj_t_Value_Range_Begin

	ffj_t_Value_Range_End
)

var ffj_key_Value_Range_Begin = []byte("begin")

var ffj_key_Value_Range_End = []byte("end")

func (uj *Value_Range) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Value_Range) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Value_Rangebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Value_Rangeno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'b':

					if bytes.Equal(ffj_key_Value_Range_Begin, kn) {
						currentKey = ffj_t_Value_Range_Begin
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffj_key_Value_Range_End, kn) {
						currentKey = ffj_t_Value_Range_End
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_Value_Range_End, kn) {
					currentKey = ffj_t_Value_Range_End
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Value_Range_Begin, kn) {
					currentKey = ffj_t_Value_Range_Begin
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Value_Rangeno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Value_Range_Begin:
					goto handle_Begin

				case ffj_t_Value_Range_End:
					goto handle_End

				case ffj_t_Value_Rangeno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Begin:

	/* handler: uj.Begin type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Begin = uint64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_End:

	/* handler: uj.End type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.End = uint64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Value_Ranges) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Value_Ranges) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"range":`)
	if mj.Range != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Range {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Value_Rangesbase = iota
	ffj_t_Value_Rangesno_such_key

	ffj_t_Value_Ranges_Range
)

var ffj_key_Value_Ranges_Range = []byte("range")

func (uj *Value_Ranges) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Value_Ranges) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Value_Rangesbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Value_Rangesno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'r':

					if bytes.Equal(ffj_key_Value_Ranges_Range, kn) {
						currentKey = ffj_t_Value_Ranges_Range
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_Value_Ranges_Range, kn) {
					currentKey = ffj_t_Value_Ranges_Range
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Value_Rangesno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Value_Ranges_Range:
					goto handle_Range

				case ffj_t_Value_Rangesno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Range:

	/* handler: uj.Range type=[]mesos.Value_Range kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Range = nil
		} else {

			uj.Range = make([]Value_Range, 0)

			wantVal := true

			for {

				var v Value_Range

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=mesos.Value_Range kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Range = append(uj.Range, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Value_Scalar) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Value_Scalar) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"value":`)
	fflib.AppendFloat(buf, float64(mj.Value), 'g', -1, 64)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Value_Scalarbase = iota
	ffj_t_Value_Scalarno_such_key

	ffj_t_Value_Scalar_Value
)

var ffj_key_Value_Scalar_Value = []byte("value")

func (uj *Value_Scalar) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Value_Scalar) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Value_Scalarbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Value_Scalarno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'v':

					if bytes.Equal(ffj_key_Value_Scalar_Value, kn) {
						currentKey = ffj_t_Value_Scalar_Value
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_Value_Scalar_Value, kn) {
					currentKey = ffj_t_Value_Scalar_Value
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Value_Scalarno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Value_Scalar_Value:
					goto handle_Value

				case ffj_t_Value_Scalarno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Value:

	/* handler: uj.Value type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Value = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Value_Set) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Value_Set) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(mj.Item) != 0 {
		buf.WriteString(`"item":`)
		if mj.Item != nil {
			buf.WriteString(`[`)
			for i, v := range mj.Item {
				if i != 0 {
					buf.WriteString(`,`)
				}
				fflib.WriteJsonString(buf, string(v))
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Value_Setbase = iota
	ffj_t_Value_Setno_such_key

	ffj_t_Value_Set_Item
)

var ffj_key_Value_Set_Item = []byte("item")

func (uj *Value_Set) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Value_Set) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Value_Setbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Value_Setno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'i':

					if bytes.Equal(ffj_key_Value_Set_Item, kn) {
						currentKey = ffj_t_Value_Set_Item
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_Value_Set_Item, kn) {
					currentKey = ffj_t_Value_Set_Item
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Value_Setno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Value_Set_Item:
					goto handle_Item

				case ffj_t_Value_Setno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Item:

	/* handler: uj.Item type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Item = nil
		} else {

			uj.Item = make([]string, 0)

			wantVal := true

			for {

				var v string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						v = string(string(outBuf))

					}
				}

				uj.Item = append(uj.Item, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Value_Text) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Value_Text) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"value":`)
	fflib.WriteJsonString(buf, string(mj.Value))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Value_Textbase = iota
	ffj_t_Value_Textno_such_key

	ffj_t_Value_Text_Value
)

var ffj_key_Value_Text_Value = []byte("value")

func (uj *Value_Text) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Value_Text) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Value_Textbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Value_Textno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'v':

					if bytes.Equal(ffj_key_Value_Text_Value, kn) {
						currentKey = ffj_t_Value_Text_Value
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_Value_Text_Value, kn) {
					currentKey = ffj_t_Value_Text_Value
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Value_Textno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Value_Text_Value:
					goto handle_Value

				case ffj_t_Value_Textno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Value:

	/* handler: uj.Value type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Value = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Volume) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Volume) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.Mode != nil {
		if true {
			buf.WriteString(`"mode":`)

			{

				obj, err = mj.Mode.MarshalJSON()
				if err != nil {
					return err
				}
				buf.Write(obj)

			}
			buf.WriteByte(',')
		}
	}
	buf.WriteString(`"container_path":`)
	fflib.WriteJsonString(buf, string(mj.ContainerPath))
	buf.WriteByte(',')
	if mj.HostPath != nil {
		if true {
			buf.WriteString(`"host_path":`)
			fflib.WriteJsonString(buf, string(*mj.HostPath))
			buf.WriteByte(',')
		}
	}
	if mj.Image != nil {
		if true {
			buf.WriteString(`"image":`)

			{

				err = mj.Image.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Volumebase = iota
	ffj_t_Volumeno_such_key

	ffj_t_Volume_Mode

	ffj_t_Volume_ContainerPath

	ffj_t_Volume_HostPath

	ffj_t_Volume_Image
)

var ffj_key_Volume_Mode = []byte("mode")

var ffj_key_Volume_ContainerPath = []byte("container_path")

var ffj_key_Volume_HostPath = []byte("host_path")

var ffj_key_Volume_Image = []byte("image")

func (uj *Volume) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Volume) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Volumebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Volumeno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_Volume_ContainerPath, kn) {
						currentKey = ffj_t_Volume_ContainerPath
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'h':

					if bytes.Equal(ffj_key_Volume_HostPath, kn) {
						currentKey = ffj_t_Volume_HostPath
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_Volume_Image, kn) {
						currentKey = ffj_t_Volume_Image
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_Volume_Mode, kn) {
						currentKey = ffj_t_Volume_Mode
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_Volume_Image, kn) {
					currentKey = ffj_t_Volume_Image
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Volume_HostPath, kn) {
					currentKey = ffj_t_Volume_HostPath
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_Volume_ContainerPath, kn) {
					currentKey = ffj_t_Volume_ContainerPath
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Volume_Mode, kn) {
					currentKey = ffj_t_Volume_Mode
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Volumeno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Volume_Mode:
					goto handle_Mode

				case ffj_t_Volume_ContainerPath:
					goto handle_ContainerPath

				case ffj_t_Volume_HostPath:
					goto handle_HostPath

				case ffj_t_Volume_Image:
					goto handle_Image

				case ffj_t_Volumeno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Mode:

	/* handler: uj.Mode type=mesos.Volume_Mode kind=int32 quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Mode = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		if uj.Mode == nil {
			uj.Mode = new(Volume_Mode)
		}

		err = uj.Mode.UnmarshalJSON(tbuf)
		if err != nil {
			return fs.WrapErr(err)
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ContainerPath:

	/* handler: uj.ContainerPath type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.ContainerPath = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_HostPath:

	/* handler: uj.HostPath type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.HostPath = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.HostPath = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Image:

	/* handler: uj.Image type=mesos.Image kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Image = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Image == nil {
			uj.Image = new(Image)
		}

		err = uj.Image.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *WeightInfo) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *WeightInfo) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "weight":`)
	fflib.AppendFloat(buf, float64(mj.Weight), 'g', -1, 64)
	buf.WriteByte(',')
	if mj.Role != nil {
		if true {
			buf.WriteString(`"role":`)
			fflib.WriteJsonString(buf, string(*mj.Role))
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_WeightInfobase = iota
	ffj_t_WeightInfono_such_key

	ffj_t_WeightInfo_Weight

	ffj_t_WeightInfo_Role
)

var ffj_key_WeightInfo_Weight = []byte("weight")

var ffj_key_WeightInfo_Role = []byte("role")

func (uj *WeightInfo) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *WeightInfo) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_WeightInfobase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_WeightInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'r':

					if bytes.Equal(ffj_key_WeightInfo_Role, kn) {
						currentKey = ffj_t_WeightInfo_Role
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'w':

					if bytes.Equal(ffj_key_WeightInfo_Weight, kn) {
						currentKey = ffj_t_WeightInfo_Weight
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_WeightInfo_Role, kn) {
					currentKey = ffj_t_WeightInfo_Role
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_WeightInfo_Weight, kn) {
					currentKey = ffj_t_WeightInfo_Weight
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_WeightInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_WeightInfo_Weight:
					goto handle_Weight

				case ffj_t_WeightInfo_Role:
					goto handle_Role

				case ffj_t_WeightInfono_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Weight:

	/* handler: uj.Weight type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Weight = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Role:

	/* handler: uj.Role type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Role = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Role = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}
